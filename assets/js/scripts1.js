!function() {
    "use strict";
    var e = {
        setBrowserClasses: function() {
            this.removeClass(document.documentElement, "no-js"),
            this.addClass(document.documentElement, "js"),
            this.isBrowserEdge() && this.addClass(document.documentElement, "is-edge"),
            this.isBrowserIE() && this.addClass(document.documentElement, "is-ie"),
            this.isBrowserIOS() && this.addClass(document.documentElement, "is-ios"),
            document.documentElement.setAttribute("data-useragent", navigator.userAgent)
        },
        hasClass: function(e, t) {
            return e.classList.contains(t)
        },
        addClass: function(e, t) {
            if (!this.hasClass(e, t))
                return e.classList.add(t)
        },
        removeClass: function(e, t) {
            if (this.hasClass(e, t))
                return e.classList.remove(t)
        },
        toggleClass: function(e, t) {
            return e.classList.toggle(t)
        },
        prependChild: function(e, t) {
            e.childNodes.length > 0 ? e.insertBefore(t, e.childNodes[0]) : e.appendChild(t)
        },
        removeFromDOM: function(e) {
            e.parentNode && e.parentNode.removeChild(e)
        },
        querySelector: function(e, t) {
            return e.querySelector(t)
        },
        querySelectorAll: function(e, t) {
            return Array.prototype.slice.call(e.querySelectorAll(t), 0)
        },
        stylePrefixTransform: function() {
            var e = "transform"
              , t = "";
            for (t in ["webkit", "Moz", "O", "ms"])
                void 0 !== document.body.style[t + "Transform"] && (e = t + "Transform");
            return e
        },
        isBrowserEdge: function() {
            return window.navigator.userAgent.indexOf("Edge/") > 0
        },
        isBrowserIE: function() {
            var e = window.navigator.userAgent;
            return e.indexOf("MSIE ") > 0 || e.indexOf("Trident/") > 0
        },
        isBrowserIOS: function() {
            var e = window.navigator.userAgent.toLowerCase();
            return e.indexOf("ipad") >= 0 || e.indexOf("iphone") >= 0 || e.indexOf("ipod") >= 0 || "MacIntel" === window.navigator.platform && window.navigator.maxTouchPoints > 1
        },
        isBrowserMobile: function() {
            var e = /iphone|ipod|android|blackberry|opera|mini|windows\sce|palm|smartphone|iemobile/i.test(navigator.userAgent.toLowerCase())
              , t = /ipad|android|android 3.0|xoom|sch-i800|playbook|tablet|kindle/i.test(navigator.userAgent.toLowerCase());
            return !(!e && !t)
        }
    };
    function t(e, t) {
        if (!(e instanceof t))
            throw new TypeError("Cannot call a class as a function")
    }
    function n(e, t) {
        for (var n = 0; n < t.length; n++) {
            var i = t[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i)
        }
    }
    function i(e, t, i) {
        return t && n(e.prototype, t),
        i && n(e, i),
        e
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger && (Number.isInteger = function(e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }
    ),
    void 0 === Math.sign && (Math.sign = function(e) {
        return e < 0 ? -1 : e > 0 ? 1 : +e
    }
    ),
    "name"in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }),
    void 0 === Object.assign && (Object.assign = function(e) {
        if (null == e)
            throw new TypeError("Cannot convert undefined or null to object");
        const t = Object(e);
        for (let e = 1; e < arguments.length; e++) {
            const n = arguments[e];
            if (null != n)
                for (const e in n)
                    Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e])
        }
        return t
    }
    );
    function r() {}
    Object.assign(r.prototype, {
        addEventListener: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[e] && (n[e] = []),
            -1 === n[e].indexOf(t) && n[e].push(t)
        },
        hasEventListener: function(e, t) {
            if (void 0 === this._listeners)
                return !1;
            var n = this._listeners;
            return void 0 !== n[e] && -1 !== n[e].indexOf(t)
        },
        removeEventListener: function(e, t) {
            if (void 0 !== this._listeners) {
                var n = this._listeners[e];
                if (void 0 !== n) {
                    var i = n.indexOf(t);
                    -1 !== i && n.splice(i, 1)
                }
            }
        },
        dispatchEvent: function(e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var n = t.slice(0), i = 0, r = n.length; i < r; i++)
                        n[i].call(this, e)
                }
            }
        }
    });
    for (var a = [], o = 0; o < 256; o++)
        a[o] = (o < 16 ? "0" : "") + o.toString(16);
    var s, c = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            var e = 4294967295 * Math.random() | 0
              , t = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , i = 4294967295 * Math.random() | 0;
            return (a[255 & e] + a[e >> 8 & 255] + a[e >> 16 & 255] + a[e >> 24 & 255] + "-" + a[255 & t] + a[t >> 8 & 255] + "-" + a[t >> 16 & 15 | 64] + a[t >> 24 & 255] + "-" + a[63 & n | 128] + a[n >> 8 & 255] + "-" + a[n >> 16 & 255] + a[n >> 24 & 255] + a[255 & i] + a[i >> 8 & 255] + a[i >> 16 & 255] + a[i >> 24 & 255]).toUpperCase()
        },
        clamp: function(e, t, n) {
            return Math.max(t, Math.min(n, e))
        },
        euclideanModulo: function(e, t) {
            return (e % t + t) % t
        },
        mapLinear: function(e, t, n, i, r) {
            return i + (e - t) * (r - i) / (n - t)
        },
        lerp: function(e, t, n) {
            return (1 - n) * e + n * t
        },
        smoothstep: function(e, t, n) {
            return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
        },
        smootherstep: function(e, t, n) {
            return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function(e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function(e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function(e) {
            return e * (.5 - Math.random())
        },
        degToRad: function(e) {
            return e * c.DEG2RAD
        },
        radToDeg: function(e) {
            return e * c.RAD2DEG
        },
        isPowerOfTwo: function(e) {
            return 0 == (e & e - 1) && 0 !== e
        },
        ceilPowerOfTwo: function(e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        },
        floorPowerOfTwo: function(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        },
        setQuaternionFromProperEuler: function(e, t, n, i, r) {
            var a = Math.cos
              , o = Math.sin
              , s = a(n / 2)
              , c = o(n / 2)
              , h = a((t + i) / 2)
              , l = o((t + i) / 2)
              , u = a((t - i) / 2)
              , p = o((t - i) / 2)
              , d = a((i - t) / 2)
              , f = o((i - t) / 2);
            switch (r) {
            case "XYX":
                e.set(s * l, c * u, c * p, s * h);
                break;
            case "YZY":
                e.set(c * p, s * l, c * u, s * h);
                break;
            case "ZXZ":
                e.set(c * u, c * p, s * l, s * h);
                break;
            case "XZX":
                e.set(s * l, c * f, c * d, s * h);
                break;
            case "YXY":
                e.set(c * d, s * l, c * f, s * h);
                break;
            case "ZYZ":
                e.set(c * f, c * d, s * l, s * h);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
            }
        }
    };
    function h(e, t) {
        this.x = e || 0,
        this.y = t || 0
    }
    function l() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.defineProperties(h.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(e) {
                this.x = e
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(e) {
                this.y = e
            }
        }
    }),
    Object.assign(h.prototype, {
        isVector2: !0,
        set: function(e, t) {
            return this.x = e,
            this.y = t,
            this
        },
        setScalar: function(e) {
            return this.x = e,
            this.y = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this
        },
        multiply: function(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this
        },
        divide: function(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        applyMatrix3: function(e) {
            var t = this.x
              , n = this.y
              , i = e.elements;
            return this.x = i[0] * t + i[3] * n + i[6],
            this.y = i[1] * t + i[4] * n + i[7],
            this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this
        },
        clampLength: function(e, t) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y
        },
        cross: function(e) {
            return this.x * e.y - this.y * e.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x
              , n = this.y - e.y;
            return t * t + n * n
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this
        },
        lerpVectors: function(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n,
            this.y = e.y + (t.y - e.y) * n,
            this
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.x = e[t],
            this.y = e[t + 1],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.x,
            e[t + 1] = this.y,
            e
        },
        fromBufferAttribute: function(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this
        },
        rotateAround: function(e, t) {
            var n = Math.cos(t)
              , i = Math.sin(t)
              , r = this.x - e.x
              , a = this.y - e.y;
            return this.x = r * n - a * i + e.x,
            this.y = r * i + a * n + e.y,
            this
        },
        random: function() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this
        }
    }),
    Object.assign(l.prototype, {
        isMatrix3: !0,
        set: function(e, t, n, i, r, a, o, s, c) {
            var h = this.elements;
            return h[0] = e,
            h[1] = i,
            h[2] = o,
            h[3] = t,
            h[4] = r,
            h[5] = s,
            h[6] = n,
            h[7] = a,
            h[8] = c,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements
              , n = e.elements;
            return t[0] = n[0],
            t[1] = n[1],
            t[2] = n[2],
            t[3] = n[3],
            t[4] = n[4],
            t[5] = n[5],
            t[6] = n[6],
            t[7] = n[7],
            t[8] = n[8],
            this
        },
        extractBasis: function(e, t, n) {
            return e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
        },
        setFromMatrix4: function(e) {
            var t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
        },
        multiply: function(e) {
            return this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var n = e.elements
              , i = t.elements
              , r = this.elements
              , a = n[0]
              , o = n[3]
              , s = n[6]
              , c = n[1]
              , h = n[4]
              , l = n[7]
              , u = n[2]
              , p = n[5]
              , d = n[8]
              , f = i[0]
              , m = i[3]
              , v = i[6]
              , g = i[1]
              , y = i[4]
              , x = i[7]
              , b = i[2]
              , _ = i[5]
              , w = i[8];
            return r[0] = a * f + o * g + s * b,
            r[3] = a * m + o * y + s * _,
            r[6] = a * v + o * x + s * w,
            r[1] = c * f + h * g + l * b,
            r[4] = c * m + h * y + l * _,
            r[7] = c * v + h * x + l * w,
            r[2] = u * f + p * g + d * b,
            r[5] = u * m + p * y + d * _,
            r[8] = u * v + p * x + d * w,
            this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e,
            t[3] *= e,
            t[6] *= e,
            t[1] *= e,
            t[4] *= e,
            t[7] *= e,
            t[2] *= e,
            t[5] *= e,
            t[8] *= e,
            this
        },
        determinant: function() {
            var e = this.elements
              , t = e[0]
              , n = e[1]
              , i = e[2]
              , r = e[3]
              , a = e[4]
              , o = e[5]
              , s = e[6]
              , c = e[7]
              , h = e[8];
            return t * a * h - t * o * c - n * r * h + n * o * s + i * r * c - i * a * s
        },
        getInverse: function(e, t) {
            void 0 !== t && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
            var n = e.elements
              , i = this.elements
              , r = n[0]
              , a = n[1]
              , o = n[2]
              , s = n[3]
              , c = n[4]
              , h = n[5]
              , l = n[6]
              , u = n[7]
              , p = n[8]
              , d = p * c - h * u
              , f = h * l - p * s
              , m = u * s - c * l
              , v = r * d + a * f + o * m;
            if (0 === v)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            var g = 1 / v;
            return i[0] = d * g,
            i[1] = (o * u - p * a) * g,
            i[2] = (h * a - o * c) * g,
            i[3] = f * g,
            i[4] = (p * r - o * l) * g,
            i[5] = (o * s - h * r) * g,
            i[6] = m * g,
            i[7] = (a * l - u * r) * g,
            i[8] = (c * r - a * s) * g,
            this
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1],
            t[1] = t[3],
            t[3] = e,
            e = t[2],
            t[2] = t[6],
            t[6] = e,
            e = t[5],
            t[5] = t[7],
            t[7] = e,
            this
        },
        getNormalMatrix: function(e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        },
        transposeIntoArray: function(e) {
            var t = this.elements;
            return e[0] = t[0],
            e[1] = t[3],
            e[2] = t[6],
            e[3] = t[1],
            e[4] = t[4],
            e[5] = t[7],
            e[6] = t[2],
            e[7] = t[5],
            e[8] = t[8],
            this
        },
        setUvTransform: function(e, t, n, i, r, a, o) {
            var s = Math.cos(r)
              , c = Math.sin(r);
            this.set(n * s, n * c, -n * (s * a + c * o) + a + e, -i * c, i * s, -i * (-c * a + s * o) + o + t, 0, 0, 1)
        },
        scale: function(e, t) {
            var n = this.elements;
            return n[0] *= e,
            n[3] *= e,
            n[6] *= e,
            n[1] *= t,
            n[4] *= t,
            n[7] *= t,
            this
        },
        rotate: function(e) {
            var t = Math.cos(e)
              , n = Math.sin(e)
              , i = this.elements
              , r = i[0]
              , a = i[3]
              , o = i[6]
              , s = i[1]
              , c = i[4]
              , h = i[7];
            return i[0] = t * r + n * s,
            i[3] = t * a + n * c,
            i[6] = t * o + n * h,
            i[1] = -n * r + t * s,
            i[4] = -n * a + t * c,
            i[7] = -n * o + t * h,
            this
        },
        translate: function(e, t) {
            var n = this.elements;
            return n[0] += e * n[2],
            n[3] += e * n[5],
            n[6] += e * n[8],
            n[1] += t * n[2],
            n[4] += t * n[5],
            n[7] += t * n[8],
            this
        },
        equals: function(e) {
            for (var t = this.elements, n = e.elements, i = 0; i < 9; i++)
                if (t[i] !== n[i])
                    return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var n = 0; n < 9; n++)
                this.elements[n] = e[n + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []),
            void 0 === t && (t = 0);
            var n = this.elements;
            return e[t] = n[0],
            e[t + 1] = n[1],
            e[t + 2] = n[2],
            e[t + 3] = n[3],
            e[t + 4] = n[4],
            e[t + 5] = n[5],
            e[t + 6] = n[6],
            e[t + 7] = n[7],
            e[t + 8] = n[8],
            e
        }
    });
    var u = {
        getDataURL: function(e) {
            var t;
            if ("undefined" == typeof HTMLCanvasElement)
                return e.src;
            if (e instanceof HTMLCanvasElement)
                t = e;
            else {
                void 0 === s && (s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                s.width = e.width,
                s.height = e.height;
                var n = s.getContext("2d");
                e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
                t = s
            }
            return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
        }
    }
      , p = 0;
    function d(e, t, n, i, r, a, o, s, u, f) {
        Object.defineProperty(this, "id", {
            value: p++
        }),
        this.uuid = c.generateUUID(),
        this.name = "",
        this.image = void 0 !== e ? e : d.DEFAULT_IMAGE,
        this.mipmaps = [],
        this.mapping = void 0 !== t ? t : d.DEFAULT_MAPPING,
        this.wrapS = void 0 !== n ? n : 1001,
        this.wrapT = void 0 !== i ? i : 1001,
        this.magFilter = void 0 !== r ? r : 1006,
        this.minFilter = void 0 !== a ? a : 1008,
        this.anisotropy = void 0 !== u ? u : 1,
        this.format = void 0 !== o ? o : 1023,
        this.internalFormat = null,
        this.type = void 0 !== s ? s : 1009,
        this.offset = new h(0,0),
        this.repeat = new h(1,1),
        this.center = new h(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new l,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = void 0 !== f ? f : 3e3,
        this.version = 0,
        this.onUpdate = null
    }
    function f(e, t, n, i) {
        this.x = e || 0,
        this.y = t || 0,
        this.z = n || 0,
        this.w = void 0 !== i ? i : 1
    }
    function m(e, t, n) {
        this.width = e,
        this.height = t,
        this.scissor = new f(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new f(0,0,e,t),
        n = n || {},
        this.texture = new d(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
        this.texture.image = {},
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps,
        this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006,
        this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
        this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer,
        this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }
    function v(e, t, n) {
        m.call(this, e, t, n),
        this.samples = 4
    }
    function g(e, t, n, i) {
        this._x = e || 0,
        this._y = t || 0,
        this._z = n || 0,
        this._w = void 0 !== i ? i : 1
    }
    d.DEFAULT_IMAGE = void 0,
    d.DEFAULT_MAPPING = 300,
    d.prototype = Object.assign(Object.create(r.prototype), {
        constructor: d,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.name = e.name,
            this.image = e.image,
            this.mipmaps = e.mipmaps.slice(0),
            this.mapping = e.mapping,
            this.wrapS = e.wrapS,
            this.wrapT = e.wrapT,
            this.magFilter = e.magFilter,
            this.minFilter = e.minFilter,
            this.anisotropy = e.anisotropy,
            this.format = e.format,
            this.internalFormat = e.internalFormat,
            this.type = e.type,
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            this.rotation = e.rotation,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrix.copy(e.matrix),
            this.generateMipmaps = e.generateMipmaps,
            this.premultiplyAlpha = e.premultiplyAlpha,
            this.flipY = e.flipY,
            this.unpackAlignment = e.unpackAlignment,
            this.encoding = e.encoding,
            this
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid])
                return e.textures[this.uuid];
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var i = this.image;
                if (void 0 === i.uuid && (i.uuid = c.generateUUID()),
                !t && void 0 === e.images[i.uuid]) {
                    var r;
                    if (Array.isArray(i)) {
                        r = [];
                        for (var a = 0, o = i.length; a < o; a++)
                            r.push(u.getDataURL(i[a]))
                    } else
                        r = u.getDataURL(i);
                    e.images[i.uuid] = {
                        uuid: i.uuid,
                        url: r
                    }
                }
                n.image = i.uuid
            }
            return t || (e.textures[this.uuid] = n),
            n
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(e) {
            if (300 !== this.mapping)
                return e;
            if (e.applyMatrix3(this.matrix),
            e.x < 0 || e.x > 1)
                switch (this.wrapS) {
                case 1e3:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case 1001:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case 1002:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
            if (e.y < 0 || e.y > 1)
                switch (this.wrapT) {
                case 1e3:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case 1001:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case 1002:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
            return this.flipY && (e.y = 1 - e.y),
            e
        }
    }),
    Object.defineProperty(d.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.defineProperties(f.prototype, {
        width: {
            get: function() {
                return this.z
            },
            set: function(e) {
                this.z = e
            }
        },
        height: {
            get: function() {
                return this.w
            },
            set: function(e) {
                this.w = e
            }
        }
    }),
    Object.assign(f.prototype, {
        isVector4: !0,
        set: function(e, t, n, i) {
            return this.x = e,
            this.y = t,
            this.z = n,
            this.w = i,
            this
        },
        setScalar: function(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this.w = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setZ: function(e) {
            return this.z = e,
            this
        },
        setW: function(e) {
            return this.w = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this.w = void 0 !== e.w ? e.w : 1,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this.w += e.w,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this.w += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this.w = e.w + t.w,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this.w += e.w * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this.w -= e.w,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this.w -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this.w = e.w - t.w,
            this
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this.w *= e,
            this
        },
        applyMatrix4: function(e) {
            var t = this.x
              , n = this.y
              , i = this.z
              , r = this.w
              , a = e.elements;
            return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r,
            this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r,
            this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r,
            this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        setAxisAngleFromQuaternion: function(e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1,
            this.y = 0,
            this.z = 0) : (this.x = e.x / t,
            this.y = e.y / t,
            this.z = e.z / t),
            this
        },
        setAxisAngleFromRotationMatrix: function(e) {
            var t, n, i, r, a = e.elements, o = a[0], s = a[4], c = a[8], h = a[1], l = a[5], u = a[9], p = a[2], d = a[6], f = a[10];
            if (Math.abs(s - h) < .01 && Math.abs(c - p) < .01 && Math.abs(u - d) < .01) {
                if (Math.abs(s + h) < .1 && Math.abs(c + p) < .1 && Math.abs(u + d) < .1 && Math.abs(o + l + f - 3) < .1)
                    return this.set(1, 0, 0, 0),
                    this;
                t = Math.PI;
                var m = (o + 1) / 2
                  , v = (l + 1) / 2
                  , g = (f + 1) / 2
                  , y = (s + h) / 4
                  , x = (c + p) / 4
                  , b = (u + d) / 4;
                return m > v && m > g ? m < .01 ? (n = 0,
                i = .707106781,
                r = .707106781) : (i = y / (n = Math.sqrt(m)),
                r = x / n) : v > g ? v < .01 ? (n = .707106781,
                i = 0,
                r = .707106781) : (n = y / (i = Math.sqrt(v)),
                r = b / i) : g < .01 ? (n = .707106781,
                i = .707106781,
                r = 0) : (n = x / (r = Math.sqrt(g)),
                i = b / r),
                this.set(n, i, r, t),
                this
            }
            var _ = Math.sqrt((d - u) * (d - u) + (c - p) * (c - p) + (h - s) * (h - s));
            return Math.abs(_) < .001 && (_ = 1),
            this.x = (d - u) / _,
            this.y = (c - p) / _,
            this.z = (h - s) / _,
            this.w = Math.acos((o + l + f - 1) / 2),
            this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this.w = Math.min(this.w, e.w),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this.w = Math.max(this.w, e.w),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this.w = Math.max(e.w, Math.min(t.w, this.w)),
            this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this.z = Math.max(e, Math.min(t, this.z)),
            this.w = Math.max(e, Math.min(t, this.w)),
            this
        },
        clampLength: function(e, t) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this.w += (e.w - this.w) * t,
            this
        },
        lerpVectors: function(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n,
            this.y = e.y + (t.y - e.y) * n,
            this.z = e.z + (t.z - e.z) * n,
            this.w = e.w + (t.w - e.w) * n,
            this
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this.w = e[t + 3],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e[t + 3] = this.w,
            e
        },
        fromBufferAttribute: function(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this.w = e.getW(t),
            this
        },
        random: function() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this.w = Math.random(),
            this
        }
    }),
    m.prototype = Object.assign(Object.create(r.prototype), {
        constructor: m,
        isWebGLRenderTarget: !0,
        setSize: function(e, t) {
            this.width === e && this.height === t || (this.width = e,
            this.height = t,
            this.texture.image.width = e,
            this.texture.image.height = t,
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.width = e.width,
            this.height = e.height,
            this.viewport.copy(e.viewport),
            this.texture = e.texture.clone(),
            this.depthBuffer = e.depthBuffer,
            this.stencilBuffer = e.stencilBuffer,
            this.depthTexture = e.depthTexture,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    v.prototype = Object.assign(Object.create(m.prototype), {
        constructor: v,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(e) {
            return m.prototype.copy.call(this, e),
            this.samples = e.samples,
            this
        }
    }),
    Object.assign(g, {
        slerp: function(e, t, n, i) {
            return n.copy(e).slerp(t, i)
        },
        slerpFlat: function(e, t, n, i, r, a, o) {
            var s = n[i + 0]
              , c = n[i + 1]
              , h = n[i + 2]
              , l = n[i + 3]
              , u = r[a + 0]
              , p = r[a + 1]
              , d = r[a + 2]
              , f = r[a + 3];
            if (l !== f || s !== u || c !== p || h !== d) {
                var m = 1 - o
                  , v = s * u + c * p + h * d + l * f
                  , g = v >= 0 ? 1 : -1
                  , y = 1 - v * v;
                if (y > Number.EPSILON) {
                    var x = Math.sqrt(y)
                      , b = Math.atan2(x, v * g);
                    m = Math.sin(m * b) / x,
                    o = Math.sin(o * b) / x
                }
                var _ = o * g;
                if (s = s * m + u * _,
                c = c * m + p * _,
                h = h * m + d * _,
                l = l * m + f * _,
                m === 1 - o) {
                    var w = 1 / Math.sqrt(s * s + c * c + h * h + l * l);
                    s *= w,
                    c *= w,
                    h *= w,
                    l *= w
                }
            }
            e[t] = s,
            e[t + 1] = c,
            e[t + 2] = h,
            e[t + 3] = l
        },
        multiplyQuaternionsFlat: function(e, t, n, i, r, a) {
            var o = n[i]
              , s = n[i + 1]
              , c = n[i + 2]
              , h = n[i + 3]
              , l = r[a]
              , u = r[a + 1]
              , p = r[a + 2]
              , d = r[a + 3];
            return e[t] = o * d + h * l + s * p - c * u,
            e[t + 1] = s * d + h * u + c * l - o * p,
            e[t + 2] = c * d + h * p + o * u - s * l,
            e[t + 3] = h * d - o * l - s * u - c * p,
            e
        }
    }),
    Object.defineProperties(g.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e,
                this._onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e,
                this._onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e,
                this._onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(e) {
                this._w = e,
                this._onChangeCallback()
            }
        }
    }),
    Object.assign(g.prototype, {
        isQuaternion: !0,
        set: function(e, t, n, i) {
            return this._x = e,
            this._y = t,
            this._z = n,
            this._w = i,
            this._onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        },
        copy: function(e) {
            return this._x = e.x,
            this._y = e.y,
            this._z = e.z,
            this._w = e.w,
            this._onChangeCallback(),
            this
        },
        setFromEuler: function(e, t) {
            if (!e || !e.isEuler)
                throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var n = e._x
              , i = e._y
              , r = e._z
              , a = e.order
              , o = Math.cos
              , s = Math.sin
              , c = o(n / 2)
              , h = o(i / 2)
              , l = o(r / 2)
              , u = s(n / 2)
              , p = s(i / 2)
              , d = s(r / 2);
            switch (a) {
            case "XYZ":
                this._x = u * h * l + c * p * d,
                this._y = c * p * l - u * h * d,
                this._z = c * h * d + u * p * l,
                this._w = c * h * l - u * p * d;
                break;
            case "YXZ":
                this._x = u * h * l + c * p * d,
                this._y = c * p * l - u * h * d,
                this._z = c * h * d - u * p * l,
                this._w = c * h * l + u * p * d;
                break;
            case "ZXY":
                this._x = u * h * l - c * p * d,
                this._y = c * p * l + u * h * d,
                this._z = c * h * d + u * p * l,
                this._w = c * h * l - u * p * d;
                break;
            case "ZYX":
                this._x = u * h * l - c * p * d,
                this._y = c * p * l + u * h * d,
                this._z = c * h * d - u * p * l,
                this._w = c * h * l + u * p * d;
                break;
            case "YZX":
                this._x = u * h * l + c * p * d,
                this._y = c * p * l + u * h * d,
                this._z = c * h * d - u * p * l,
                this._w = c * h * l - u * p * d;
                break;
            case "XZY":
                this._x = u * h * l - c * p * d,
                this._y = c * p * l - u * h * d,
                this._z = c * h * d + u * p * l,
                this._w = c * h * l + u * p * d;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
            }
            return !1 !== t && this._onChangeCallback(),
            this
        },
        setFromAxisAngle: function(e, t) {
            var n = t / 2
              , i = Math.sin(n);
            return this._x = e.x * i,
            this._y = e.y * i,
            this._z = e.z * i,
            this._w = Math.cos(n),
            this._onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(e) {
            var t, n = e.elements, i = n[0], r = n[4], a = n[8], o = n[1], s = n[5], c = n[9], h = n[2], l = n[6], u = n[10], p = i + s + u;
            return p > 0 ? (t = .5 / Math.sqrt(p + 1),
            this._w = .25 / t,
            this._x = (l - c) * t,
            this._y = (a - h) * t,
            this._z = (o - r) * t) : i > s && i > u ? (t = 2 * Math.sqrt(1 + i - s - u),
            this._w = (l - c) / t,
            this._x = .25 * t,
            this._y = (r + o) / t,
            this._z = (a + h) / t) : s > u ? (t = 2 * Math.sqrt(1 + s - i - u),
            this._w = (a - h) / t,
            this._x = (r + o) / t,
            this._y = .25 * t,
            this._z = (c + l) / t) : (t = 2 * Math.sqrt(1 + u - i - s),
            this._w = (o - r) / t,
            this._x = (a + h) / t,
            this._y = (c + l) / t,
            this._z = .25 * t),
            this._onChangeCallback(),
            this
        },
        setFromUnitVectors: function(e, t) {
            var n = e.dot(t) + 1;
            return n < 1e-6 ? (n = 0,
            Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
            this._y = e.x,
            this._z = 0,
            this._w = n) : (this._x = 0,
            this._y = -e.z,
            this._z = e.y,
            this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
            this._y = e.z * t.x - e.x * t.z,
            this._z = e.x * t.y - e.y * t.x,
            this._w = n),
            this.normalize()
        },
        angleTo: function(e) {
            return 2 * Math.acos(Math.abs(c.clamp(this.dot(e), -1, 1)))
        },
        rotateTowards: function(e, t) {
            var n = this.angleTo(e);
            if (0 === n)
                return this;
            var i = Math.min(1, t / n);
            return this.slerp(e, i),
            this
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this._onChangeCallback(),
            this
        },
        dot: function(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var e = this.length();
            return 0 === e ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (e = 1 / e,
            this._x = this._x * e,
            this._y = this._y * e,
            this._z = this._z * e,
            this._w = this._w * e),
            this._onChangeCallback(),
            this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        premultiply: function(e) {
            return this.multiplyQuaternions(e, this)
        },
        multiplyQuaternions: function(e, t) {
            var n = e._x
              , i = e._y
              , r = e._z
              , a = e._w
              , o = t._x
              , s = t._y
              , c = t._z
              , h = t._w;
            return this._x = n * h + a * o + i * c - r * s,
            this._y = i * h + a * s + r * o - n * c,
            this._z = r * h + a * c + n * s - i * o,
            this._w = a * h - n * o - i * s - r * c,
            this._onChangeCallback(),
            this
        },
        slerp: function(e, t) {
            if (0 === t)
                return this;
            if (1 === t)
                return this.copy(e);
            var n = this._x
              , i = this._y
              , r = this._z
              , a = this._w
              , o = a * e._w + n * e._x + i * e._y + r * e._z;
            if (o < 0 ? (this._w = -e._w,
            this._x = -e._x,
            this._y = -e._y,
            this._z = -e._z,
            o = -o) : this.copy(e),
            o >= 1)
                return this._w = a,
                this._x = n,
                this._y = i,
                this._z = r,
                this;
            var s = 1 - o * o;
            if (s <= Number.EPSILON) {
                var c = 1 - t;
                return this._w = c * a + t * this._w,
                this._x = c * n + t * this._x,
                this._y = c * i + t * this._y,
                this._z = c * r + t * this._z,
                this.normalize(),
                this._onChangeCallback(),
                this
            }
            var h = Math.sqrt(s)
              , l = Math.atan2(h, o)
              , u = Math.sin((1 - t) * l) / h
              , p = Math.sin(t * l) / h;
            return this._w = a * u + this._w * p,
            this._x = n * u + this._x * p,
            this._y = i * u + this._y * p,
            this._z = r * u + this._z * p,
            this._onChangeCallback(),
            this
        },
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this._x = e[t],
            this._y = e[t + 1],
            this._z = e[t + 2],
            this._w = e[t + 3],
            this._onChangeCallback(),
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._w,
            e
        },
        fromBufferAttribute: function(e, t) {
            return this._x = e.getX(t),
            this._y = e.getY(t),
            this._z = e.getZ(t),
            this._w = e.getW(t),
            this
        },
        _onChange: function(e) {
            return this._onChangeCallback = e,
            this
        },
        _onChangeCallback: function() {}
    });
    var y = new b
      , x = new g;
    function b(e, t, n) {
        this.x = e || 0,
        this.y = t || 0,
        this.z = n || 0
    }
    Object.assign(b.prototype, {
        isVector3: !0,
        set: function(e, t, n) {
            return this.x = e,
            this.y = t,
            this.z = n,
            this
        },
        setScalar: function(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setZ: function(e) {
            return this.z = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(e, t)) : (this.x *= e.x,
            this.y *= e.y,
            this.z *= e.z,
            this)
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this
        },
        multiplyVectors: function(e, t) {
            return this.x = e.x * t.x,
            this.y = e.y * t.y,
            this.z = e.z * t.z,
            this
        },
        applyEuler: function(e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
            this.applyQuaternion(x.setFromEuler(e))
        },
        applyAxisAngle: function(e, t) {
            return this.applyQuaternion(x.setFromAxisAngle(e, t))
        },
        applyMatrix3: function(e) {
            var t = this.x
              , n = this.y
              , i = this.z
              , r = e.elements;
            return this.x = r[0] * t + r[3] * n + r[6] * i,
            this.y = r[1] * t + r[4] * n + r[7] * i,
            this.z = r[2] * t + r[5] * n + r[8] * i,
            this
        },
        applyNormalMatrix: function(e) {
            return this.applyMatrix3(e).normalize()
        },
        applyMatrix4: function(e) {
            var t = this.x
              , n = this.y
              , i = this.z
              , r = e.elements
              , a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a,
            this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a,
            this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a,
            this
        },
        applyQuaternion: function(e) {
            var t = this.x
              , n = this.y
              , i = this.z
              , r = e.x
              , a = e.y
              , o = e.z
              , s = e.w
              , c = s * t + a * i - o * n
              , h = s * n + o * t - r * i
              , l = s * i + r * n - a * t
              , u = -r * t - a * n - o * i;
            return this.x = c * s + u * -r + h * -o - l * -a,
            this.y = h * s + u * -a + l * -r - c * -o,
            this.z = l * s + u * -o + c * -a - h * -r,
            this
        },
        project: function(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        },
        unproject: function(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        },
        transformDirection: function(e) {
            var t = this.x
              , n = this.y
              , i = this.z
              , r = e.elements;
            return this.x = r[0] * t + r[4] * n + r[8] * i,
            this.y = r[1] * t + r[5] * n + r[9] * i,
            this.z = r[2] * t + r[6] * n + r[10] * i,
            this.normalize()
        },
        divide: function(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this.z /= e.z,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this.z = Math.max(e, Math.min(t, this.z)),
            this
        },
        clampLength: function(e, t) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this
        },
        lerpVectors: function(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n,
            this.y = e.y + (t.y - e.y) * n,
            this.z = e.z + (t.z - e.z) * n,
            this
        },
        cross: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(e, t)) : this.crossVectors(this, e)
        },
        crossVectors: function(e, t) {
            var n = e.x
              , i = e.y
              , r = e.z
              , a = t.x
              , o = t.y
              , s = t.z;
            return this.x = i * s - r * o,
            this.y = r * a - n * s,
            this.z = n * o - i * a,
            this
        },
        projectOnVector: function(e) {
            var t = e.lengthSq();
            if (0 === t)
                return this.set(0, 0, 0);
            var n = e.dot(this) / t;
            return this.copy(e).multiplyScalar(n)
        },
        projectOnPlane: function(e) {
            return y.copy(this).projectOnVector(e),
            this.sub(y)
        },
        reflect: function(e) {
            return this.sub(y.copy(e).multiplyScalar(2 * this.dot(e)))
        },
        angleTo: function(e) {
            var t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (0 === t)
                return Math.PI / 2;
            var n = this.dot(e) / t;
            return Math.acos(c.clamp(n, -1, 1))
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x
              , n = this.y - e.y
              , i = this.z - e.z;
            return t * t + n * n + i * i
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        },
        setFromSpherical: function(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        },
        setFromSphericalCoords: function(e, t, n) {
            var i = Math.sin(t) * e;
            return this.x = i * Math.sin(n),
            this.y = Math.cos(t) * e,
            this.z = i * Math.cos(n),
            this
        },
        setFromCylindrical: function(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        },
        setFromCylindricalCoords: function(e, t, n) {
            return this.x = e * Math.sin(t),
            this.y = n,
            this.z = e * Math.cos(t),
            this
        },
        setFromMatrixPosition: function(e) {
            var t = e.elements;
            return this.x = t[12],
            this.y = t[13],
            this.z = t[14],
            this
        },
        setFromMatrixScale: function(e) {
            var t = this.setFromMatrixColumn(e, 0).length()
              , n = this.setFromMatrixColumn(e, 1).length()
              , i = this.setFromMatrixColumn(e, 2).length();
            return this.x = t,
            this.y = n,
            this.z = i,
            this
        },
        setFromMatrixColumn: function(e, t) {
            return this.fromArray(e.elements, 4 * t)
        },
        setFromMatrix3Column: function(e, t) {
            return this.fromArray(e.elements, 3 * t)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e
        },
        fromBufferAttribute: function(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this
        },
        random: function() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this
        }
    });
    var _ = new b
      , w = new L
      , M = new b(0,0,0)
      , S = new b(1,1,1)
      , T = new b
      , E = new b
      , A = new b;
    function L() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.assign(L.prototype, {
        isMatrix4: !0,
        set: function(e, t, n, i, r, a, o, s, c, h, l, u, p, d, f, m) {
            var v = this.elements;
            return v[0] = e,
            v[4] = t,
            v[8] = n,
            v[12] = i,
            v[1] = r,
            v[5] = a,
            v[9] = o,
            v[13] = s,
            v[2] = c,
            v[6] = h,
            v[10] = l,
            v[14] = u,
            v[3] = p,
            v[7] = d,
            v[11] = f,
            v[15] = m,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new L).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements
              , n = e.elements;
            return t[0] = n[0],
            t[1] = n[1],
            t[2] = n[2],
            t[3] = n[3],
            t[4] = n[4],
            t[5] = n[5],
            t[6] = n[6],
            t[7] = n[7],
            t[8] = n[8],
            t[9] = n[9],
            t[10] = n[10],
            t[11] = n[11],
            t[12] = n[12],
            t[13] = n[13],
            t[14] = n[14],
            t[15] = n[15],
            this
        },
        copyPosition: function(e) {
            var t = this.elements
              , n = e.elements;
            return t[12] = n[12],
            t[13] = n[13],
            t[14] = n[14],
            this
        },
        extractBasis: function(e, t, n) {
            return e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
        },
        makeBasis: function(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
            this
        },
        extractRotation: function(e) {
            var t = this.elements
              , n = e.elements
              , i = 1 / _.setFromMatrixColumn(e, 0).length()
              , r = 1 / _.setFromMatrixColumn(e, 1).length()
              , a = 1 / _.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * i,
            t[1] = n[1] * i,
            t[2] = n[2] * i,
            t[3] = 0,
            t[4] = n[4] * r,
            t[5] = n[5] * r,
            t[6] = n[6] * r,
            t[7] = 0,
            t[8] = n[8] * a,
            t[9] = n[9] * a,
            t[10] = n[10] * a,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            this
        },
        makeRotationFromEuler: function(e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements
              , n = e.x
              , i = e.y
              , r = e.z
              , a = Math.cos(n)
              , o = Math.sin(n)
              , s = Math.cos(i)
              , c = Math.sin(i)
              , h = Math.cos(r)
              , l = Math.sin(r);
            if ("XYZ" === e.order) {
                var u = a * h
                  , p = a * l
                  , d = o * h
                  , f = o * l;
                t[0] = s * h,
                t[4] = -s * l,
                t[8] = c,
                t[1] = p + d * c,
                t[5] = u - f * c,
                t[9] = -o * s,
                t[2] = f - u * c,
                t[6] = d + p * c,
                t[10] = a * s
            } else if ("YXZ" === e.order) {
                var m = s * h
                  , v = s * l
                  , g = c * h
                  , y = c * l;
                t[0] = m + y * o,
                t[4] = g * o - v,
                t[8] = a * c,
                t[1] = a * l,
                t[5] = a * h,
                t[9] = -o,
                t[2] = v * o - g,
                t[6] = y + m * o,
                t[10] = a * s
            } else if ("ZXY" === e.order) {
                m = s * h,
                v = s * l,
                g = c * h,
                y = c * l;
                t[0] = m - y * o,
                t[4] = -a * l,
                t[8] = g + v * o,
                t[1] = v + g * o,
                t[5] = a * h,
                t[9] = y - m * o,
                t[2] = -a * c,
                t[6] = o,
                t[10] = a * s
            } else if ("ZYX" === e.order) {
                u = a * h,
                p = a * l,
                d = o * h,
                f = o * l;
                t[0] = s * h,
                t[4] = d * c - p,
                t[8] = u * c + f,
                t[1] = s * l,
                t[5] = f * c + u,
                t[9] = p * c - d,
                t[2] = -c,
                t[6] = o * s,
                t[10] = a * s
            } else if ("YZX" === e.order) {
                var x = a * s
                  , b = a * c
                  , _ = o * s
                  , w = o * c;
                t[0] = s * h,
                t[4] = w - x * l,
                t[8] = _ * l + b,
                t[1] = l,
                t[5] = a * h,
                t[9] = -o * h,
                t[2] = -c * h,
                t[6] = b * l + _,
                t[10] = x - w * l
            } else if ("XZY" === e.order) {
                x = a * s,
                b = a * c,
                _ = o * s,
                w = o * c;
                t[0] = s * h,
                t[4] = -l,
                t[8] = c * h,
                t[1] = x * l + w,
                t[5] = a * h,
                t[9] = b * l - _,
                t[2] = _ * l - b,
                t[6] = o * h,
                t[10] = w * l + x
            }
            return t[3] = 0,
            t[7] = 0,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            this
        },
        makeRotationFromQuaternion: function(e) {
            return this.compose(M, e, S)
        },
        lookAt: function(e, t, n) {
            var i = this.elements;
            return A.subVectors(e, t),
            0 === A.lengthSq() && (A.z = 1),
            A.normalize(),
            T.crossVectors(n, A),
            0 === T.lengthSq() && (1 === Math.abs(n.z) ? A.x += 1e-4 : A.z += 1e-4,
            A.normalize(),
            T.crossVectors(n, A)),
            T.normalize(),
            E.crossVectors(A, T),
            i[0] = T.x,
            i[4] = E.x,
            i[8] = A.x,
            i[1] = T.y,
            i[5] = E.y,
            i[9] = A.y,
            i[2] = T.z,
            i[6] = E.z,
            i[10] = A.z,
            this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var n = e.elements
              , i = t.elements
              , r = this.elements
              , a = n[0]
              , o = n[4]
              , s = n[8]
              , c = n[12]
              , h = n[1]
              , l = n[5]
              , u = n[9]
              , p = n[13]
              , d = n[2]
              , f = n[6]
              , m = n[10]
              , v = n[14]
              , g = n[3]
              , y = n[7]
              , x = n[11]
              , b = n[15]
              , _ = i[0]
              , w = i[4]
              , M = i[8]
              , S = i[12]
              , T = i[1]
              , E = i[5]
              , A = i[9]
              , L = i[13]
              , R = i[2]
              , P = i[6]
              , C = i[10]
              , O = i[14]
              , I = i[3]
              , D = i[7]
              , N = i[11]
              , U = i[15];
            return r[0] = a * _ + o * T + s * R + c * I,
            r[4] = a * w + o * E + s * P + c * D,
            r[8] = a * M + o * A + s * C + c * N,
            r[12] = a * S + o * L + s * O + c * U,
            r[1] = h * _ + l * T + u * R + p * I,
            r[5] = h * w + l * E + u * P + p * D,
            r[9] = h * M + l * A + u * C + p * N,
            r[13] = h * S + l * L + u * O + p * U,
            r[2] = d * _ + f * T + m * R + v * I,
            r[6] = d * w + f * E + m * P + v * D,
            r[10] = d * M + f * A + m * C + v * N,
            r[14] = d * S + f * L + m * O + v * U,
            r[3] = g * _ + y * T + x * R + b * I,
            r[7] = g * w + y * E + x * P + b * D,
            r[11] = g * M + y * A + x * C + b * N,
            r[15] = g * S + y * L + x * O + b * U,
            this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e,
            t[4] *= e,
            t[8] *= e,
            t[12] *= e,
            t[1] *= e,
            t[5] *= e,
            t[9] *= e,
            t[13] *= e,
            t[2] *= e,
            t[6] *= e,
            t[10] *= e,
            t[14] *= e,
            t[3] *= e,
            t[7] *= e,
            t[11] *= e,
            t[15] *= e,
            this
        },
        determinant: function() {
            var e = this.elements
              , t = e[0]
              , n = e[4]
              , i = e[8]
              , r = e[12]
              , a = e[1]
              , o = e[5]
              , s = e[9]
              , c = e[13]
              , h = e[2]
              , l = e[6]
              , u = e[10]
              , p = e[14];
            return e[3] * (+r * s * l - i * c * l - r * o * u + n * c * u + i * o * p - n * s * p) + e[7] * (+t * s * p - t * c * u + r * a * u - i * a * p + i * c * h - r * s * h) + e[11] * (+t * c * l - t * o * p - r * a * l + n * a * p + r * o * h - n * c * h) + e[15] * (-i * o * h - t * s * l + t * o * u + i * a * l - n * a * u + n * s * h)
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1],
            t[1] = t[4],
            t[4] = e,
            e = t[2],
            t[2] = t[8],
            t[8] = e,
            e = t[6],
            t[6] = t[9],
            t[9] = e,
            e = t[3],
            t[3] = t[12],
            t[12] = e,
            e = t[7],
            t[7] = t[13],
            t[13] = e,
            e = t[11],
            t[11] = t[14],
            t[14] = e,
            this
        },
        setPosition: function(e, t, n) {
            var i = this.elements;
            return e.isVector3 ? (i[12] = e.x,
            i[13] = e.y,
            i[14] = e.z) : (i[12] = e,
            i[13] = t,
            i[14] = n),
            this
        },
        getInverse: function(e, t) {
            void 0 !== t && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
            var n = this.elements
              , i = e.elements
              , r = i[0]
              , a = i[1]
              , o = i[2]
              , s = i[3]
              , c = i[4]
              , h = i[5]
              , l = i[6]
              , u = i[7]
              , p = i[8]
              , d = i[9]
              , f = i[10]
              , m = i[11]
              , v = i[12]
              , g = i[13]
              , y = i[14]
              , x = i[15]
              , b = d * y * u - g * f * u + g * l * m - h * y * m - d * l * x + h * f * x
              , _ = v * f * u - p * y * u - v * l * m + c * y * m + p * l * x - c * f * x
              , w = p * g * u - v * d * u + v * h * m - c * g * m - p * h * x + c * d * x
              , M = v * d * l - p * g * l - v * h * f + c * g * f + p * h * y - c * d * y
              , S = r * b + a * _ + o * w + s * M;
            if (0 === S)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            var T = 1 / S;
            return n[0] = b * T,
            n[1] = (g * f * s - d * y * s - g * o * m + a * y * m + d * o * x - a * f * x) * T,
            n[2] = (h * y * s - g * l * s + g * o * u - a * y * u - h * o * x + a * l * x) * T,
            n[3] = (d * l * s - h * f * s - d * o * u + a * f * u + h * o * m - a * l * m) * T,
            n[4] = _ * T,
            n[5] = (p * y * s - v * f * s + v * o * m - r * y * m - p * o * x + r * f * x) * T,
            n[6] = (v * l * s - c * y * s - v * o * u + r * y * u + c * o * x - r * l * x) * T,
            n[7] = (c * f * s - p * l * s + p * o * u - r * f * u - c * o * m + r * l * m) * T,
            n[8] = w * T,
            n[9] = (v * d * s - p * g * s - v * a * m + r * g * m + p * a * x - r * d * x) * T,
            n[10] = (c * g * s - v * h * s + v * a * u - r * g * u - c * a * x + r * h * x) * T,
            n[11] = (p * h * s - c * d * s - p * a * u + r * d * u + c * a * m - r * h * m) * T,
            n[12] = M * T,
            n[13] = (p * g * o - v * d * o + v * a * f - r * g * f - p * a * y + r * d * y) * T,
            n[14] = (v * h * o - c * g * o - v * a * l + r * g * l + c * a * y - r * h * y) * T,
            n[15] = (c * d * o - p * h * o + p * a * l - r * d * l - c * a * f + r * h * f) * T,
            this
        },
        scale: function(e) {
            var t = this.elements
              , n = e.x
              , i = e.y
              , r = e.z;
            return t[0] *= n,
            t[4] *= i,
            t[8] *= r,
            t[1] *= n,
            t[5] *= i,
            t[9] *= r,
            t[2] *= n,
            t[6] *= i,
            t[10] *= r,
            t[3] *= n,
            t[7] *= i,
            t[11] *= r,
            this
        },
        getMaxScaleOnAxis: function() {
            var e = this.elements
              , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
              , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
              , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, i))
        },
        makeTranslation: function(e, t, n) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
            this
        },
        makeRotationX: function(e) {
            var t = Math.cos(e)
              , n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
            this
        },
        makeRotationY: function(e) {
            var t = Math.cos(e)
              , n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
            this
        },
        makeRotationZ: function(e) {
            var t = Math.cos(e)
              , n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        makeRotationAxis: function(e, t) {
            var n = Math.cos(t)
              , i = Math.sin(t)
              , r = 1 - n
              , a = e.x
              , o = e.y
              , s = e.z
              , c = r * a
              , h = r * o;
            return this.set(c * a + n, c * o - i * s, c * s + i * o, 0, c * o + i * s, h * o + n, h * s - i * a, 0, c * s - i * o, h * s + i * a, r * s * s + n, 0, 0, 0, 0, 1),
            this
        },
        makeScale: function(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
            this
        },
        makeShear: function(e, t, n) {
            return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1),
            this
        },
        compose: function(e, t, n) {
            var i = this.elements
              , r = t._x
              , a = t._y
              , o = t._z
              , s = t._w
              , c = r + r
              , h = a + a
              , l = o + o
              , u = r * c
              , p = r * h
              , d = r * l
              , f = a * h
              , m = a * l
              , v = o * l
              , g = s * c
              , y = s * h
              , x = s * l
              , b = n.x
              , _ = n.y
              , w = n.z;
            return i[0] = (1 - (f + v)) * b,
            i[1] = (p + x) * b,
            i[2] = (d - y) * b,
            i[3] = 0,
            i[4] = (p - x) * _,
            i[5] = (1 - (u + v)) * _,
            i[6] = (m + g) * _,
            i[7] = 0,
            i[8] = (d + y) * w,
            i[9] = (m - g) * w,
            i[10] = (1 - (u + f)) * w,
            i[11] = 0,
            i[12] = e.x,
            i[13] = e.y,
            i[14] = e.z,
            i[15] = 1,
            this
        },
        decompose: function(e, t, n) {
            var i = this.elements
              , r = _.set(i[0], i[1], i[2]).length()
              , a = _.set(i[4], i[5], i[6]).length()
              , o = _.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r),
            e.x = i[12],
            e.y = i[13],
            e.z = i[14],
            w.copy(this);
            var s = 1 / r
              , c = 1 / a
              , h = 1 / o;
            return w.elements[0] *= s,
            w.elements[1] *= s,
            w.elements[2] *= s,
            w.elements[4] *= c,
            w.elements[5] *= c,
            w.elements[6] *= c,
            w.elements[8] *= h,
            w.elements[9] *= h,
            w.elements[10] *= h,
            t.setFromRotationMatrix(w),
            n.x = r,
            n.y = a,
            n.z = o,
            this
        },
        makePerspective: function(e, t, n, i, r, a) {
            void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var o = this.elements
              , s = 2 * r / (t - e)
              , c = 2 * r / (n - i)
              , h = (t + e) / (t - e)
              , l = (n + i) / (n - i)
              , u = -(a + r) / (a - r)
              , p = -2 * a * r / (a - r);
            return o[0] = s,
            o[4] = 0,
            o[8] = h,
            o[12] = 0,
            o[1] = 0,
            o[5] = c,
            o[9] = l,
            o[13] = 0,
            o[2] = 0,
            o[6] = 0,
            o[10] = u,
            o[14] = p,
            o[3] = 0,
            o[7] = 0,
            o[11] = -1,
            o[15] = 0,
            this
        },
        makeOrthographic: function(e, t, n, i, r, a) {
            var o = this.elements
              , s = 1 / (t - e)
              , c = 1 / (n - i)
              , h = 1 / (a - r)
              , l = (t + e) * s
              , u = (n + i) * c
              , p = (a + r) * h;
            return o[0] = 2 * s,
            o[4] = 0,
            o[8] = 0,
            o[12] = -l,
            o[1] = 0,
            o[5] = 2 * c,
            o[9] = 0,
            o[13] = -u,
            o[2] = 0,
            o[6] = 0,
            o[10] = -2 * h,
            o[14] = -p,
            o[3] = 0,
            o[7] = 0,
            o[11] = 0,
            o[15] = 1,
            this
        },
        equals: function(e) {
            for (var t = this.elements, n = e.elements, i = 0; i < 16; i++)
                if (t[i] !== n[i])
                    return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var n = 0; n < 16; n++)
                this.elements[n] = e[n + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []),
            void 0 === t && (t = 0);
            var n = this.elements;
            return e[t] = n[0],
            e[t + 1] = n[1],
            e[t + 2] = n[2],
            e[t + 3] = n[3],
            e[t + 4] = n[4],
            e[t + 5] = n[5],
            e[t + 6] = n[6],
            e[t + 7] = n[7],
            e[t + 8] = n[8],
            e[t + 9] = n[9],
            e[t + 10] = n[10],
            e[t + 11] = n[11],
            e[t + 12] = n[12],
            e[t + 13] = n[13],
            e[t + 14] = n[14],
            e[t + 15] = n[15],
            e
        }
    });
    var R = new L
      , P = new g;
    function C(e, t, n, i) {
        this._x = e || 0,
        this._y = t || 0,
        this._z = n || 0,
        this._order = i || C.DefaultOrder
    }
    function O() {
        this.mask = 1
    }
    C.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
    C.DefaultOrder = "XYZ",
    Object.defineProperties(C.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e,
                this._onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e,
                this._onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e,
                this._onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(e) {
                this._order = e,
                this._onChangeCallback()
            }
        }
    }),
    Object.assign(C.prototype, {
        isEuler: !0,
        set: function(e, t, n, i) {
            return this._x = e,
            this._y = t,
            this._z = n,
            this._order = i || this._order,
            this._onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        },
        copy: function(e) {
            return this._x = e._x,
            this._y = e._y,
            this._z = e._z,
            this._order = e._order,
            this._onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(e, t, n) {
            var i = c.clamp
              , r = e.elements
              , a = r[0]
              , o = r[4]
              , s = r[8]
              , h = r[1]
              , l = r[5]
              , u = r[9]
              , p = r[2]
              , d = r[6]
              , f = r[10];
            switch (t = t || this._order) {
            case "XYZ":
                this._y = Math.asin(i(s, -1, 1)),
                Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, f),
                this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, l),
                this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-i(u, -1, 1)),
                Math.abs(u) < .9999999 ? (this._y = Math.atan2(s, f),
                this._z = Math.atan2(h, l)) : (this._y = Math.atan2(-p, a),
                this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(i(d, -1, 1)),
                Math.abs(d) < .9999999 ? (this._y = Math.atan2(-p, f),
                this._z = Math.atan2(-o, l)) : (this._y = 0,
                this._z = Math.atan2(h, a));
                break;
            case "ZYX":
                this._y = Math.asin(-i(p, -1, 1)),
                Math.abs(p) < .9999999 ? (this._x = Math.atan2(d, f),
                this._z = Math.atan2(h, a)) : (this._x = 0,
                this._z = Math.atan2(-o, l));
                break;
            case "YZX":
                this._z = Math.asin(i(h, -1, 1)),
                Math.abs(h) < .9999999 ? (this._x = Math.atan2(-u, l),
                this._y = Math.atan2(-p, a)) : (this._x = 0,
                this._y = Math.atan2(s, f));
                break;
            case "XZY":
                this._z = Math.asin(-i(o, -1, 1)),
                Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, l),
                this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-u, f),
                this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
            }
            return this._order = t,
            !1 !== n && this._onChangeCallback(),
            this
        },
        setFromQuaternion: function(e, t, n) {
            return R.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(R, t, n)
        },
        setFromVector3: function(e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: function(e) {
            return P.setFromEuler(this),
            this.setFromQuaternion(P, e)
        },
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function(e) {
            return this._x = e[0],
            this._y = e[1],
            this._z = e[2],
            void 0 !== e[3] && (this._order = e[3]),
            this._onChangeCallback(),
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._order,
            e
        },
        toVector3: function(e) {
            return e ? e.set(this._x, this._y, this._z) : new b(this._x,this._y,this._z)
        },
        _onChange: function(e) {
            return this._onChangeCallback = e,
            this
        },
        _onChangeCallback: function() {}
    }),
    Object.assign(O.prototype, {
        set: function(e) {
            this.mask = 1 << e | 0
        },
        enable: function(e) {
            this.mask |= 1 << e | 0
        },
        enableAll: function() {
            this.mask = -1
        },
        toggle: function(e) {
            this.mask ^= 1 << e | 0
        },
        disable: function(e) {
            this.mask &= ~(1 << e | 0)
        },
        disableAll: function() {
            this.mask = 0
        },
        test: function(e) {
            return 0 != (this.mask & e.mask)
        }
    });
    let I = 0;
    const D = new b
      , N = new g
      , U = new L
      , z = new b
      , B = new b
      , F = new b
      , H = new g
      , k = new b(1,0,0)
      , G = new b(0,1,0)
      , V = new b(0,0,1)
      , j = {
        type: "added"
    }
      , W = {
        type: "removed"
    };
    function q() {
        Object.defineProperty(this, "id", {
            value: I++
        }),
        this.uuid = c.generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = q.DefaultUp.clone();
        var e = new b
          , t = new C
          , n = new g
          , i = new b(1,1,1);
        t._onChange((function() {
            n.setFromEuler(t, !1)
        }
        )),
        n._onChange((function() {
            t.setFromQuaternion(n, void 0, !1)
        }
        )),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new L
            },
            normalMatrix: {
                value: new l
            }
        }),
        this.matrix = new L,
        this.matrixWorld = new L,
        this.matrixAutoUpdate = q.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new O,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.userData = {}
    }
    function X() {
        q.call(this),
        this.type = "Scene",
       // this.background = null,
        this.environment = null,
        this.fog = null,
        this.overrideMaterial = null,
        this.autoUpdate = !0,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    q.DefaultUp = new b(0,1,0),
    q.DefaultMatrixAutoUpdate = !0,
    q.prototype = Object.assign(Object.create(r.prototype), {
        constructor: q,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix4: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(e) {
            return this.quaternion.premultiply(e),
            this
        },
        setRotationFromAxisAngle: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function(e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function(e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function(e, t) {
            return N.setFromAxisAngle(e, t),
            this.quaternion.multiply(N),
            this
        },
        rotateOnWorldAxis: function(e, t) {
            return N.setFromAxisAngle(e, t),
            this.quaternion.premultiply(N),
            this
        },
        rotateX: function(e) {
            return this.rotateOnAxis(k, e)
        },
        rotateY: function(e) {
            return this.rotateOnAxis(G, e)
        },
        rotateZ: function(e) {
            return this.rotateOnAxis(V, e)
        },
        translateOnAxis: function(e, t) {
            return D.copy(e).applyQuaternion(this.quaternion),
            this.position.add(D.multiplyScalar(t)),
            this
        },
        translateX: function(e) {
            return this.translateOnAxis(k, e)
        },
        translateY: function(e) {
            return this.translateOnAxis(G, e)
        },
        translateZ: function(e) {
            return this.translateOnAxis(V, e)
        },
        localToWorld: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function(e) {
            return e.applyMatrix4(U.getInverse(this.matrixWorld))
        },
        lookAt: function(e, t, n) {
            e.isVector3 ? z.copy(e) : z.set(e, t, n);
            var i = this.parent;
            this.updateWorldMatrix(!0, !1),
            B.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? U.lookAt(B, z, this.up) : U.lookAt(z, B, this.up),
            this.quaternion.setFromRotationMatrix(U),
            i && (U.extractRotation(i.matrixWorld),
            N.setFromRotationMatrix(U),
            this.quaternion.premultiply(N.inverse()))
        },
        add: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++)
                    this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
            this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e),
            e.parent = this,
            this.children.push(e),
            e.dispatchEvent(j)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
            this)
        },
        remove: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++)
                    this.remove(arguments[t]);
                return this
            }
            var n = this.children.indexOf(e);
            return -1 !== n && (e.parent = null,
            this.children.splice(n, 1),
            e.dispatchEvent(W)),
            this
        },
        attach: function(e) {
            return this.updateWorldMatrix(!0, !1),
            U.getInverse(this.matrixWorld),
            null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
            U.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(U),
            e.updateWorldMatrix(!1, !1),
            this.add(e),
            this
        },
        getObjectById: function(e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function(e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function(e, t) {
            if (this[e] === t)
                return this;
            for (var n = 0, i = this.children.length; n < i; n++) {
                var r = this.children[n].getObjectByProperty(e, t);
                if (void 0 !== r)
                    return r
            }
        },
        getWorldPosition: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
            e = new b),
            this.updateMatrixWorld(!0),
            e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
            e = new g),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(B, e, F),
            e
        },
        getWorldScale: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
            e = new b),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(B, H, e),
            e
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
            e = new b),
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        },
        raycast: function() {},
        traverse: function(e) {
            e(this);
            for (var t = this.children, n = 0, i = t.length; n < i; n++)
                t[n].traverse(e)
        },
        traverseVisible: function(e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, n = 0, i = t.length; n < i; n++)
                    t[n].traverseVisible(e)
            }
        },
        traverseAncestors: function(e) {
            var t = this.parent;
            null !== t && (e(t),
            t.traverseAncestors(e))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            e = !0);
            for (var t = this.children, n = 0, i = t.length; n < i; n++)
                t[n].updateMatrixWorld(e)
        },
        updateWorldMatrix: function(e, t) {
            var n = this.parent;
            if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === t)
                for (var i = this.children, r = 0, a = i.length; r < a; r++)
                    i[r].updateWorldMatrix(!1, !0)
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e
              , n = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            },
            n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var i = {};
            function r(t, n) {
                return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)),
                n.uuid
            }
            if (i.uuid = this.uuid,
            i.type = this.type,
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
            i.layers = this.layers.mask,
            i.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh && (i.type = "InstancedMesh",
            i.count = this.count,
            i.instanceMatrix = this.instanceMatrix.toJSON()),
            this.isMesh || this.isLine || this.isPoints) {
                i.geometry = r(e.geometries, this.geometry);
                var a = this.geometry.parameters;
                if (void 0 !== a && void 0 !== a.shapes) {
                    var o = a.shapes;
                    if (Array.isArray(o))
                        for (var s = 0, c = o.length; s < c; s++) {
                            var h = o[s];
                            r(e.shapes, h)
                        }
                    else
                        r(e.shapes, o)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    var l = [];
                    for (s = 0,
                    c = this.material.length; s < c; s++)
                        l.push(r(e.materials, this.material[s]));
                    i.material = l
                } else
                    i.material = r(e.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (s = 0; s < this.children.length; s++)
                    i.children.push(this.children[s].toJSON(e).object)
            }
            if (t) {
                var u = m(e.geometries)
                  , p = m(e.materials)
                  , d = m(e.textures)
                  , f = m(e.images);
                o = m(e.shapes);
                u.length > 0 && (n.geometries = u),
                p.length > 0 && (n.materials = p),
                d.length > 0 && (n.textures = d),
                f.length > 0 && (n.images = f),
                o.length > 0 && (n.shapes = o)
            }
            return n.object = i,
            n;
            function m(e) {
                var t = [];
                for (var n in e) {
                    var i = e[n];
                    delete i.metadata,
                    t.push(i)
                }
                return t
            }
        },
        clone: function(e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function(e, t) {
            if (void 0 === t && (t = !0),
            this.name = e.name,
            this.up.copy(e.up),
            this.position.copy(e.position),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
            this.layers.mask = e.layers.mask,
            this.visible = e.visible,
            this.castShadow = e.castShadow,
            this.receiveShadow = e.receiveShadow,
            this.frustumCulled = e.frustumCulled,
            this.renderOrder = e.renderOrder,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            !0 === t)
                for (var n = 0; n < e.children.length; n++) {
                    var i = e.children[n];
                    this.add(i.clone())
                }
            return this
        }
    }),
    X.prototype = Object.assign(Object.create(q.prototype), {
        constructor: X,
        isScene: !0,
        copy: function(e, t) {
            return q.prototype.copy.call(this, e, t),
           // null !== e.background && (this.background = e.background.clone()),
            null !== e.environment && (this.environment = e.environment.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
            this.autoUpdate = e.autoUpdate,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this
        },
        toJSON: function(e) {
            var t = q.prototype.toJSON.call(this, e);
          //  return null !== this.background && (t.object.background = this.background.toJSON(e)),
            null !== this.environment && (t.object.environment = this.environment.toJSON(e)),
            null !== this.fog && (t.object.fog = this.fog.toJSON()),
            t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var Y = [new b, new b, new b, new b, new b, new b, new b, new b]
      , Z = new b
      , J = new se
      , K = new b
      , Q = new b
      , $ = new b
      , ee = new b
      , te = new b
      , ne = new b
      , ie = new b
      , re = new b
      , ae = new b
      , oe = new b;
    function se(e, t) {
        this.min = void 0 !== e ? e : new b(1 / 0,1 / 0,1 / 0),
        this.max = void 0 !== t ? t : new b(-1 / 0,-1 / 0,-1 / 0)
    }
    function ce(e, t, n, i, r) {
        var a, o;
        for (a = 0,
        o = e.length - 3; a <= o; a += 3) {
            oe.fromArray(e, a);
            var s = r.x * Math.abs(oe.x) + r.y * Math.abs(oe.y) + r.z * Math.abs(oe.z)
              , c = t.dot(oe)
              , h = n.dot(oe)
              , l = i.dot(oe);
            if (Math.max(-Math.max(c, h, l), Math.min(c, h, l)) > s)
                return !1
        }
        return !0
    }
    Object.assign(se.prototype, {
        isBox3: !0,
        set: function(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        },
        setFromArray: function(e) {
            for (var t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = e.length; s < c; s += 3) {
                var h = e[s]
                  , l = e[s + 1]
                  , u = e[s + 2];
                h < t && (t = h),
                l < n && (n = l),
                u < i && (i = u),
                h > r && (r = h),
                l > a && (a = l),
                u > o && (o = u)
            }
            return this.min.set(t, n, i),
            this.max.set(r, a, o),
            this
        },
        setFromBufferAttribute: function(e) {
            for (var t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = e.count; s < c; s++) {
                var h = e.getX(s)
                  , l = e.getY(s)
                  , u = e.getZ(s);
                h < t && (t = h),
                l < n && (n = l),
                u < i && (i = u),
                h > r && (r = h),
                l > a && (a = l),
                u > o && (o = u)
            }
            return this.min.set(t, n, i),
            this.max.set(r, a, o),
            this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, n = e.length; t < n; t++)
                this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function(e, t) {
            var n = Z.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n),
            this.max.copy(e).add(n),
            this
        },
        setFromObject: function(e) {
            return this.makeEmpty(),
            this.expandByObject(e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"),
            e = new b),
            this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"),
            e = new b),
            this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        },
        expandByVector: function(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        },
        expandByObject: function(e) {
            e.updateWorldMatrix(!1, !1);
            var t = e.geometry;
            void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(),
            J.copy(t.boundingBox),
            J.applyMatrix4(e.matrixWorld),
            this.union(J));
            for (var n = e.children, i = 0, r = n.length; i < r; i++)
                this.expandByObject(n[i]);
            return this
        },
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"),
            t = new b),
            t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        },
        intersectsSphere: function(e) {
            return this.clampPoint(e.center, Z),
            Z.distanceToSquared(e.center) <= e.radius * e.radius
        },
        intersectsPlane: function(e) {
            var t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
            n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
            n = e.normal.x * this.min.x),
            e.normal.y > 0 ? (t += e.normal.y * this.min.y,
            n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
            n += e.normal.y * this.min.y),
            e.normal.z > 0 ? (t += e.normal.z * this.min.z,
            n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
            n += e.normal.z * this.min.z),
            t <= -e.constant && n >= -e.constant
        },
        intersectsTriangle: function(e) {
            if (this.isEmpty())
                return !1;
            this.getCenter(ie),
            re.subVectors(this.max, ie),
            K.subVectors(e.a, ie),
            Q.subVectors(e.b, ie),
            $.subVectors(e.c, ie),
            ee.subVectors(Q, K),
            te.subVectors($, Q),
            ne.subVectors(K, $);
            var t = [0, -ee.z, ee.y, 0, -te.z, te.y, 0, -ne.z, ne.y, ee.z, 0, -ee.x, te.z, 0, -te.x, ne.z, 0, -ne.x, -ee.y, ee.x, 0, -te.y, te.x, 0, -ne.y, ne.x, 0];
            return !!ce(t, K, Q, $, re) && (!!ce(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], K, Q, $, re) && (ae.crossVectors(ee, te),
            ce(t = [ae.x, ae.y, ae.z], K, Q, $, re)))
        },
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"),
            t = new b),
            t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function(e) {
            return Z.copy(e).clamp(this.min, this.max).sub(e).length()
        },
        getBoundingSphere: function(e) {
            return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"),
            this.getCenter(e.center),
            e.radius = .5 * this.getSize(Z).length(),
            e
        },
        intersect: function(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
        },
        union: function(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        },
        applyMatrix4: function(e) {
            return this.isEmpty() || (Y[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
            Y[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
            Y[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
            Y[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
            Y[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
            Y[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
            Y[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
            Y[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
            this.setFromPoints(Y)),
            this
        },
        translate: function(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    });
    var he = new se;
    function le(e, t) {
        this.center = void 0 !== e ? e : new b,
        this.radius = void 0 !== t ? t : -1
    }
    Object.assign(le.prototype, {
        set: function(e, t) {
            return this.center.copy(e),
            this.radius = t,
            this
        },
        setFromPoints: function(e, t) {
            var n = this.center;
            void 0 !== t ? n.copy(t) : he.setFromPoints(e).getCenter(n);
            for (var i = 0, r = 0, a = e.length; r < a; r++)
                i = Math.max(i, n.distanceToSquared(e[r]));
            return this.radius = Math.sqrt(i),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.center.copy(e.center),
            this.radius = e.radius,
            this
        },
        isEmpty: function() {
            return this.radius < 0
        },
        makeEmpty: function() {
            return this.center.set(0, 0, 0),
            this.radius = -1,
            this
        },
        containsPoint: function(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        intersectsBox: function(e) {
            return e.intersectsSphere(this)
        },
        intersectsPlane: function(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(e, t) {
            var n = this.center.distanceToSquared(e);
            return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            t = new b),
            t.copy(e),
            n > this.radius * this.radius && (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
            t
        },
        getBoundingBox: function(e) {
            return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
            e = new se),
            this.isEmpty() ? (e.makeEmpty(),
            e) : (e.set(this.center, this.center),
            e.expandByScalar(this.radius),
            e)
        },
        applyMatrix4: function(e) {
            return this.center.applyMatrix4(e),
            this.radius = this.radius * e.getMaxScaleOnAxis(),
            this
        },
        translate: function(e) {
            return this.center.add(e),
            this
        },
        equals: function(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    });
    var ue = new b
      , pe = new b
      , de = new b
      , fe = new b
      , me = new b
      , ve = new b
      , ge = new b;
    function ye(e, t) {
        this.origin = void 0 !== e ? e : new b,
        this.direction = void 0 !== t ? t : new b(0,0,-1)
    }
    Object.assign(ye.prototype, {
        set: function(e, t) {
            return this.origin.copy(e),
            this.direction.copy(t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.origin.copy(e.origin),
            this.direction.copy(e.direction),
            this
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"),
            t = new b),
            t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        lookAt: function(e) {
            return this.direction.copy(e).sub(this.origin).normalize(),
            this
        },
        recast: function(e) {
            return this.origin.copy(this.at(e, ue)),
            this
        },
        closestPointToPoint: function(e, t) {
            void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
            t = new b),
            t.subVectors(e, this.origin);
            var n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
        },
        distanceToPoint: function(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        },
        distanceSqToPoint: function(e) {
            var t = ue.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (ue.copy(this.direction).multiplyScalar(t).add(this.origin),
            ue.distanceToSquared(e))
        },
        distanceSqToSegment: function(e, t, n, i) {
            pe.copy(e).add(t).multiplyScalar(.5),
            de.copy(t).sub(e).normalize(),
            fe.copy(this.origin).sub(pe);
            var r, a, o, s, c = .5 * e.distanceTo(t), h = -this.direction.dot(de), l = fe.dot(this.direction), u = -fe.dot(de), p = fe.lengthSq(), d = Math.abs(1 - h * h);
            if (d > 0)
                if (a = h * l - u,
                s = c * d,
                (r = h * u - l) >= 0)
                    if (a >= -s)
                        if (a <= s) {
                            var f = 1 / d;
                            o = (r *= f) * (r + h * (a *= f) + 2 * l) + a * (h * r + a + 2 * u) + p
                        } else
                            a = c,
                            o = -(r = Math.max(0, -(h * a + l))) * r + a * (a + 2 * u) + p;
                    else
                        a = -c,
                        o = -(r = Math.max(0, -(h * a + l))) * r + a * (a + 2 * u) + p;
                else
                    a <= -s ? o = -(r = Math.max(0, -(-h * c + l))) * r + (a = r > 0 ? -c : Math.min(Math.max(-c, -u), c)) * (a + 2 * u) + p : a <= s ? (r = 0,
                    o = (a = Math.min(Math.max(-c, -u), c)) * (a + 2 * u) + p) : o = -(r = Math.max(0, -(h * c + l))) * r + (a = r > 0 ? c : Math.min(Math.max(-c, -u), c)) * (a + 2 * u) + p;
            else
                a = h > 0 ? -c : c,
                o = -(r = Math.max(0, -(h * a + l))) * r + a * (a + 2 * u) + p;
            return n && n.copy(this.direction).multiplyScalar(r).add(this.origin),
            i && i.copy(de).multiplyScalar(a).add(pe),
            o
        },
        intersectSphere: function(e, t) {
            ue.subVectors(e.center, this.origin);
            var n = ue.dot(this.direction)
              , i = ue.dot(ue) - n * n
              , r = e.radius * e.radius;
            if (i > r)
                return null;
            var a = Math.sqrt(r - i)
              , o = n - a
              , s = n + a;
            return o < 0 && s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t)
        },
        intersectsSphere: function(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        },
        distanceToPlane: function(e) {
            var t = e.normal.dot(this.direction);
            if (0 === t)
                return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            var n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null
        },
        intersectPlane: function(e, t) {
            var n = this.distanceToPlane(e);
            return null === n ? null : this.at(n, t)
        },
        intersectsPlane: function(e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
        },
        intersectBox: function(e, t) {
            var n, i, r, a, o, s, c = 1 / this.direction.x, h = 1 / this.direction.y, l = 1 / this.direction.z, u = this.origin;
            return c >= 0 ? (n = (e.min.x - u.x) * c,
            i = (e.max.x - u.x) * c) : (n = (e.max.x - u.x) * c,
            i = (e.min.x - u.x) * c),
            h >= 0 ? (r = (e.min.y - u.y) * h,
            a = (e.max.y - u.y) * h) : (r = (e.max.y - u.y) * h,
            a = (e.min.y - u.y) * h),
            n > a || r > i ? null : ((r > n || n != n) && (n = r),
            (a < i || i != i) && (i = a),
            l >= 0 ? (o = (e.min.z - u.z) * l,
            s = (e.max.z - u.z) * l) : (o = (e.max.z - u.z) * l,
            s = (e.min.z - u.z) * l),
            n > s || o > i ? null : ((o > n || n != n) && (n = o),
            (s < i || i != i) && (i = s),
            i < 0 ? null : this.at(n >= 0 ? n : i, t)))
        },
        intersectsBox: function(e) {
            return null !== this.intersectBox(e, ue)
        },
        intersectTriangle: function(e, t, n, i, r) {
            me.subVectors(t, e),
            ve.subVectors(n, e),
            ge.crossVectors(me, ve);
            var a, o = this.direction.dot(ge);
            if (o > 0) {
                if (i)
                    return null;
                a = 1
            } else {
                if (!(o < 0))
                    return null;
                a = -1,
                o = -o
            }
            fe.subVectors(this.origin, e);
            var s = a * this.direction.dot(ve.crossVectors(fe, ve));
            if (s < 0)
                return null;
            var c = a * this.direction.dot(me.cross(fe));
            if (c < 0)
                return null;
            if (s + c > o)
                return null;
            var h = -a * fe.dot(ge);
            return h < 0 ? null : this.at(h / o, r)
        },
        applyMatrix4: function(e) {
            return this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
        },
        equals: function(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    });
    var xe = new b
      , be = new b
      , _e = new l;
    function we(e, t) {
        this.normal = void 0 !== e ? e : new b(1,0,0),
        this.constant = void 0 !== t ? t : 0
    }
    Object.assign(we.prototype, {
        isPlane: !0,
        set: function(e, t) {
            return this.normal.copy(e),
            this.constant = t,
            this
        },
        setComponents: function(e, t, n, i) {
            return this.normal.set(e, t, n),
            this.constant = i,
            this
        },
        setFromNormalAndCoplanarPoint: function(e, t) {
            return this.normal.copy(e),
            this.constant = -t.dot(this.normal),
            this
        },
        setFromCoplanarPoints: function(e, t, n) {
            var i = xe.subVectors(n, t).cross(be.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.normal.copy(e.normal),
            this.constant = e.constant,
            this
        },
        normalize: function() {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e),
            this.constant *= e,
            this
        },
        negate: function() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        },
        distanceToPoint: function(e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function(e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"),
            t = new b),
            t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        },
        intersectLine: function(e, t) {
            void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"),
            t = new b);
            var n = e.delta(xe)
              , i = this.normal.dot(n);
            if (0 === i)
                return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
            var r = -(e.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? void 0 : t.copy(n).multiplyScalar(r).add(e.start)
        },
        intersectsLine: function(e) {
            var t = this.distanceToPoint(e.start)
              , n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0
        },
        intersectsBox: function(e) {
            return e.intersectsPlane(this)
        },
        intersectsSphere: function(e) {
            return e.intersectsPlane(this)
        },
        coplanarPoint: function(e) {
            return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
            e = new b),
            e.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function(e, t) {
            var n = t || _e.getNormalMatrix(e)
              , i = this.coplanarPoint(xe).applyMatrix4(e)
              , r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(r),
            this
        },
        translate: function(e) {
            return this.constant -= e.dot(this.normal),
            this
        },
        equals: function(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    });
    var Me = new b
      , Se = new b
      , Te = new b
      , Ee = new b
      , Ae = new b
      , Le = new b
      , Re = new b
      , Pe = new b
      , Ce = new b
      , Oe = new b;
    function Ie(e, t, n) {
        this.a = void 0 !== e ? e : new b,
        this.b = void 0 !== t ? t : new b,
        this.c = void 0 !== n ? n : new b
    }
    Object.assign(Ie, {
        getNormal: function(e, t, n, i) {
            void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"),
            i = new b),
            i.subVectors(n, t),
            Me.subVectors(e, t),
            i.cross(Me);
            var r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
        },
        getBarycoord: function(e, t, n, i, r) {
            Me.subVectors(i, t),
            Se.subVectors(n, t),
            Te.subVectors(e, t);
            var a = Me.dot(Me)
              , o = Me.dot(Se)
              , s = Me.dot(Te)
              , c = Se.dot(Se)
              , h = Se.dot(Te)
              , l = a * c - o * o;
            if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
            r = new b),
            0 === l)
                return r.set(-2, -1, -1);
            var u = 1 / l
              , p = (c * s - o * h) * u
              , d = (a * h - o * s) * u;
            return r.set(1 - p - d, d, p)
        },
        containsPoint: function(e, t, n, i) {
            return Ie.getBarycoord(e, t, n, i, Ee),
            Ee.x >= 0 && Ee.y >= 0 && Ee.x + Ee.y <= 1
        },
        getUV: function(e, t, n, i, r, a, o, s) {
            return this.getBarycoord(e, t, n, i, Ee),
            s.set(0, 0),
            s.addScaledVector(r, Ee.x),
            s.addScaledVector(a, Ee.y),
            s.addScaledVector(o, Ee.z),
            s
        },
        isFrontFacing: function(e, t, n, i) {
            return Me.subVectors(n, t),
            Se.subVectors(e, t),
            Me.cross(Se).dot(i) < 0
        }
    }),
    Object.assign(Ie.prototype, {
        set: function(e, t, n) {
            return this.a.copy(e),
            this.b.copy(t),
            this.c.copy(n),
            this
        },
        setFromPointsAndIndices: function(e, t, n, i) {
            return this.a.copy(e[t]),
            this.b.copy(e[n]),
            this.c.copy(e[i]),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.a.copy(e.a),
            this.b.copy(e.b),
            this.c.copy(e.c),
            this
        },
        getArea: function() {
            return Me.subVectors(this.c, this.b),
            Se.subVectors(this.a, this.b),
            .5 * Me.cross(Se).length()
        },
        getMidpoint: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
            e = new b),
            e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(e) {
            return Ie.getNormal(this.a, this.b, this.c, e)
        },
        getPlane: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"),
            e = new we),
            e.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(e, t) {
            return Ie.getBarycoord(e, this.a, this.b, this.c, t)
        },
        getUV: function(e, t, n, i, r) {
            return Ie.getUV(e, this.a, this.b, this.c, t, n, i, r)
        },
        containsPoint: function(e) {
            return Ie.containsPoint(e, this.a, this.b, this.c)
        },
        isFrontFacing: function(e) {
            return Ie.isFrontFacing(this.a, this.b, this.c, e)
        },
        intersectsBox: function(e) {
            return e.intersectsTriangle(this)
        },
        closestPointToPoint: function(e, t) {
            void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
            t = new b);
            var n, i, r = this.a, a = this.b, o = this.c;
            Ae.subVectors(a, r),
            Le.subVectors(o, r),
            Pe.subVectors(e, r);
            var s = Ae.dot(Pe)
              , c = Le.dot(Pe);
            if (s <= 0 && c <= 0)
                return t.copy(r);
            Ce.subVectors(e, a);
            var h = Ae.dot(Ce)
              , l = Le.dot(Ce);
            if (h >= 0 && l <= h)
                return t.copy(a);
            var u = s * l - h * c;
            if (u <= 0 && s >= 0 && h <= 0)
                return n = s / (s - h),
                t.copy(r).addScaledVector(Ae, n);
            Oe.subVectors(e, o);
            var p = Ae.dot(Oe)
              , d = Le.dot(Oe);
            if (d >= 0 && p <= d)
                return t.copy(o);
            var f = p * c - s * d;
            if (f <= 0 && c >= 0 && d <= 0)
                return i = c / (c - d),
                t.copy(r).addScaledVector(Le, i);
            var m = h * d - p * l;
            if (m <= 0 && l - h >= 0 && p - d >= 0)
                return Re.subVectors(o, a),
                i = (l - h) / (l - h + (p - d)),
                t.copy(a).addScaledVector(Re, i);
            var v = 1 / (m + f + u);
            return n = f * v,
            i = u * v,
            t.copy(r).addScaledVector(Ae, n).addScaledVector(Le, i)
        },
        equals: function(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    });
    var De = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }
      , Ne = {
        h: 0,
        s: 0,
        l: 0
    }
      , Ue = {
        h: 0,
        s: 0,
        l: 0
    };
    function ze(e, t, n) {
        return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
    }
    function Be(e, t, n) {
        return n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
    }
    function Fe(e) {
        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
    }
    function He(e) {
        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
    }
    function ke(e, t, n, i, r, a) {
        this.a = e,
        this.b = t,
        this.c = n,
        this.normal = i && i.isVector3 ? i : new b,
        this.vertexNormals = Array.isArray(i) ? i : [],
        this.color = r && r.isColor ? r : new ze,
        this.vertexColors = Array.isArray(r) ? r : [],
        this.materialIndex = void 0 !== a ? a : 0
    }
    Object.assign(ze.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e),
            this
        },
        setScalar: function(e) {
            return this.r = e,
            this.g = e,
            this.b = e,
            this
        },
        setHex: function(e) {
            return e = Math.floor(e),
            this.r = (e >> 16 & 255) / 255,
            this.g = (e >> 8 & 255) / 255,
            this.b = (255 & e) / 255,
            this
        },
        setRGB: function(e, t, n) {
            return this.r = e,
            this.g = t,
            this.b = n,
            this
        },
        setHSL: function(e, t, n) {
            if (e = c.euclideanModulo(e, 1),
            t = c.clamp(t, 0, 1),
            n = c.clamp(n, 0, 1),
            0 === t)
                this.r = this.g = this.b = n;
            else {
                var i = n <= .5 ? n * (1 + t) : n + t - n * t
                  , r = 2 * n - i;
                this.r = Be(r, i, e + 1 / 3),
                this.g = Be(r, i, e),
                this.b = Be(r, i, e - 1 / 3)
            }
            return this
        },
        setStyle: function(e) {
            function t(t) {
                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            var n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                var i, r = n[1], a = n[2];
                switch (r) {
                case "rgb":
                case "rgba":
                    if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
                        return this.r = Math.min(255, parseInt(i[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(i[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(i[3], 10)) / 255,
                        t(i[5]),
                        this;
                    if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
                        return this.r = Math.min(100, parseInt(i[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(i[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(i[3], 10)) / 100,
                        t(i[5]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                        var o = parseFloat(i[1]) / 360
                          , s = parseInt(i[2], 10) / 100
                          , c = parseInt(i[3], 10) / 100;
                        return t(i[5]),
                        this.setHSL(o, s, c)
                    }
                }
            } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                var h = n[1]
                  , l = h.length;
                if (3 === l)
                    return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255,
                    this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255,
                    this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255,
                    this;
                if (6 === l)
                    return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255,
                    this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255,
                    this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255,
                    this
            }
            return e && e.length > 0 ? this.setColorName(e) : this
        },
        setColorName: function(e) {
            var t = De[e];
            return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e),
            this
        },
        clone: function() {
            return new this.constructor(this.r,this.g,this.b)
        },
        copy: function(e) {
            return this.r = e.r,
            this.g = e.g,
            this.b = e.b,
            this
        },
        copyGammaToLinear: function(e, t) {
            return void 0 === t && (t = 2),
            this.r = Math.pow(e.r, t),
            this.g = Math.pow(e.g, t),
            this.b = Math.pow(e.b, t),
            this
        },
        copyLinearToGamma: function(e, t) {
            void 0 === t && (t = 2);
            var n = t > 0 ? 1 / t : 1;
            return this.r = Math.pow(e.r, n),
            this.g = Math.pow(e.g, n),
            this.b = Math.pow(e.b, n),
            this
        },
        convertGammaToLinear: function(e) {
            return this.copyGammaToLinear(this, e),
            this
        },
        convertLinearToGamma: function(e) {
            return this.copyLinearToGamma(this, e),
            this
        },
        copySRGBToLinear: function(e) {
            return this.r = Fe(e.r),
            this.g = Fe(e.g),
            this.b = Fe(e.b),
            this
        },
        copyLinearToSRGB: function(e) {
            return this.r = He(e.r),
            this.g = He(e.g),
            this.b = He(e.b),
            this
        },
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this),
            this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this),
            this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(e) {
            void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"),
            e = {
                h: 0,
                s: 0,
                l: 0
            });
            var t, n, i = this.r, r = this.g, a = this.b, o = Math.max(i, r, a), s = Math.min(i, r, a), c = (s + o) / 2;
            if (s === o)
                t = 0,
                n = 0;
            else {
                var h = o - s;
                switch (n = c <= .5 ? h / (o + s) : h / (2 - o - s),
                o) {
                case i:
                    t = (r - a) / h + (r < a ? 6 : 0);
                    break;
                case r:
                    t = (a - i) / h + 2;
                    break;
                case a:
                    t = (i - r) / h + 4
                }
                t /= 6
            }
            return e.h = t,
            e.s = n,
            e.l = c,
            e
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function(e, t, n) {
            return this.getHSL(Ne),
            Ne.h += e,
            Ne.s += t,
            Ne.l += n,
            this.setHSL(Ne.h, Ne.s, Ne.l),
            this
        },
        add: function(e) {
            return this.r += e.r,
            this.g += e.g,
            this.b += e.b,
            this
        },
        addColors: function(e, t) {
            return this.r = e.r + t.r,
            this.g = e.g + t.g,
            this.b = e.b + t.b,
            this
        },
        addScalar: function(e) {
            return this.r += e,
            this.g += e,
            this.b += e,
            this
        },
        sub: function(e) {
            return this.r = Math.max(0, this.r - e.r),
            this.g = Math.max(0, this.g - e.g),
            this.b = Math.max(0, this.b - e.b),
            this
        },
        multiply: function(e) {
            return this.r *= e.r,
            this.g *= e.g,
            this.b *= e.b,
            this
        },
        multiplyScalar: function(e) {
            return this.r *= e,
            this.g *= e,
            this.b *= e,
            this
        },
        lerp: function(e, t) {
            return this.r += (e.r - this.r) * t,
            this.g += (e.g - this.g) * t,
            this.b += (e.b - this.b) * t,
            this
        },
        lerpHSL: function(e, t) {
            this.getHSL(Ne),
            e.getHSL(Ue);
            var n = c.lerp(Ne.h, Ue.h, t)
              , i = c.lerp(Ne.s, Ue.s, t)
              , r = c.lerp(Ne.l, Ue.l, t);
            return this.setHSL(n, i, r),
            this
        },
        equals: function(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.r = e[t],
            this.g = e[t + 1],
            this.b = e[t + 2],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.r,
            e[t + 1] = this.g,
            e[t + 2] = this.b,
            e
        },
        toJSON: function() {
            return this.getHex()
        }
    }),
    ze.NAMES = De,
    Object.assign(ke.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.a = e.a,
            this.b = e.b,
            this.c = e.c,
            this.normal.copy(e.normal),
            this.color.copy(e.color),
            this.materialIndex = e.materialIndex;
            for (var t = 0, n = e.vertexNormals.length; t < n; t++)
                this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0,
            n = e.vertexColors.length; t < n; t++)
                this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    });
    var Ge = 0;
    function Ve() {
        Object.defineProperty(this, "id", {
            value: Ge++
        }),
        this.uuid = c.generateUUID(),
        this.name = "",
        this.type = "Material",
        this.fog = !0,
        this.blending = 1,
        this.side = 0,
        this.flatShading = !1,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = 204,
        this.blendDst = 205,
        this.blendEquation = 100,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = 3,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = 519,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = 7680,
        this.stencilZFail = 7680,
        this.stencilZPass = 7680,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0
    }
    function je(e) {
        Ve.call(this),
        this.type = "MeshBasicMaterial",
        this.color = new ze(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.setValues(e)
    }
    Ve.prototype = Object.assign(Object.create(r.prototype), {
        constructor: Ve,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(e) {
            if (void 0 !== e)
                for (var t in e) {
                    var n = e[t];
                    if (void 0 !== n)
                        if ("shading" !== t) {
                            var i = this[t];
                            void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                        } else
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                            this.flatShading = 1 === n;
                    else
                        console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                }
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            t && (e = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            function i(e) {
                var t = [];
                for (var n in e) {
                    var i = e[n];
                    delete i.metadata,
                    t.push(i)
                }
                return t
            }
            if (n.uuid = this.uuid,
            n.type = this.type,
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
            this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
            n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid),
            this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
            n.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
            n.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
            n.normalMapType = this.normalMapType,
            n.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
            n.displacementScale = this.displacementScale,
            n.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
            n.reflectivity = this.reflectivity,
            n.refractionRatio = this.refractionRatio,
            void 0 !== this.combine && (n.combine = this.combine),
            void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)),
            this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.size && (n.size = this.size),
            void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (n.blending = this.blending),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            0 !== this.side && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            n.depthFunc = this.depthFunc,
            n.depthTest = this.depthTest,
            n.depthWrite = this.depthWrite,
            n.stencilWrite = this.stencilWrite,
            n.stencilWriteMask = this.stencilWriteMask,
            n.stencilFunc = this.stencilFunc,
            n.stencilRef = this.stencilRef,
            n.stencilFuncMask = this.stencilFuncMask,
            n.stencilFail = this.stencilFail,
            n.stencilZFail = this.stencilZFail,
            n.stencilZPass = this.stencilZPass,
            this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (n.morphTargets = !0),
            !0 === this.morphNormals && (n.morphNormals = !0),
            !0 === this.skinning && (n.skinning = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
            t) {
                var r = i(e.textures)
                  , a = i(e.images);
                r.length > 0 && (n.textures = r),
                a.length > 0 && (n.images = a)
            }
            return n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.name = e.name,
            this.fog = e.fog,
            this.blending = e.blending,
            this.side = e.side,
            this.flatShading = e.flatShading,
            this.vertexColors = e.vertexColors,
            this.opacity = e.opacity,
            this.transparent = e.transparent,
            this.blendSrc = e.blendSrc,
            this.blendDst = e.blendDst,
            this.blendEquation = e.blendEquation,
            this.blendSrcAlpha = e.blendSrcAlpha,
            this.blendDstAlpha = e.blendDstAlpha,
            this.blendEquationAlpha = e.blendEquationAlpha,
            this.depthFunc = e.depthFunc,
            this.depthTest = e.depthTest,
            this.depthWrite = e.depthWrite,
            this.stencilWriteMask = e.stencilWriteMask,
            this.stencilFunc = e.stencilFunc,
            this.stencilRef = e.stencilRef,
            this.stencilFuncMask = e.stencilFuncMask,
            this.stencilFail = e.stencilFail,
            this.stencilZFail = e.stencilZFail,
            this.stencilZPass = e.stencilZPass,
            this.stencilWrite = e.stencilWrite;
            var t = e.clippingPlanes
              , n = null;
            if (null !== t) {
                var i = t.length;
                n = new Array(i);
                for (var r = 0; r !== i; ++r)
                    n[r] = t[r].clone()
            }
            return this.clippingPlanes = n,
            this.clipIntersection = e.clipIntersection,
            this.clipShadows = e.clipShadows,
            this.shadowSide = e.shadowSide,
            this.colorWrite = e.colorWrite,
            this.precision = e.precision,
            this.polygonOffset = e.polygonOffset,
            this.polygonOffsetFactor = e.polygonOffsetFactor,
            this.polygonOffsetUnits = e.polygonOffsetUnits,
            this.dithering = e.dithering,
            this.alphaTest = e.alphaTest,
            this.premultipliedAlpha = e.premultipliedAlpha,
            this.visible = e.visible,
            this.toneMapped = e.toneMapped,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(Ve.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    je.prototype = Object.create(Ve.prototype),
    je.prototype.constructor = je,
    je.prototype.isMeshBasicMaterial = !0,
    je.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this
    }
    ;
    var We = new b;
    function qe(e, t, n) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.normalized = !0 === n,
        this.usage = 35044,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function Xe(e, t, n) {
        qe.call(this, new Int8Array(e), t, n)
    }
    function Ye(e, t, n) {
        qe.call(this, new Uint8Array(e), t, n)
    }
    function Ze(e, t, n) {
        qe.call(this, new Uint8ClampedArray(e), t, n)
    }
    function Je(e, t, n) {
        qe.call(this, new Int16Array(e), t, n)
    }
    function Ke(e, t, n) {
        qe.call(this, new Uint16Array(e), t, n)
    }
    function Qe(e, t, n) {
        qe.call(this, new Int32Array(e), t, n)
    }
    function $e(e, t, n) {
        qe.call(this, new Uint32Array(e), t, n)
    }
    function et(e, t, n) {
        qe.call(this, new Float32Array(e), t, n)
    }
    function tt(e, t, n) {
        qe.call(this, new Float64Array(e), t, n)
    }
    function nt() {
        this.vertices = [],
        this.normals = [],
        this.colors = [],
        this.uvs = [],
        this.uvs2 = [],
        this.groups = [],
        this.morphTargets = {},
        this.skinWeights = [],
        this.skinIndices = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.verticesNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    function it(e) {
        if (0 === e.length)
            return -1 / 0;
        let t = e[0];
        for (let n = 1, i = e.length; n < i; ++n)
            e[n] > t && (t = e[n]);
        return t
    }
    Object.defineProperty(qe.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(qe.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setUsage: function(e) {
            return this.usage = e,
            this
        },
        copy: function(e) {
            return this.name = e.name,
            this.array = new e.array.constructor(e.array),
            this.itemSize = e.itemSize,
            this.count = e.count,
            this.normalized = e.normalized,
            this.usage = e.usage,
            this
        },
        copyAt: function(e, t, n) {
            e *= this.itemSize,
            n *= t.itemSize;
            for (var i = 0, r = this.itemSize; i < r; i++)
                this.array[e + i] = t.array[n + i];
            return this
        },
        copyArray: function(e) {
            return this.array.set(e),
            this
        },
        copyColorsArray: function(e) {
            for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                var a = e[i];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
                a = new ze),
                t[n++] = a.r,
                t[n++] = a.g,
                t[n++] = a.b
            }
            return this
        },
        copyVector2sArray: function(e) {
            for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                var a = e[i];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i),
                a = new h),
                t[n++] = a.x,
                t[n++] = a.y
            }
            return this
        },
        copyVector3sArray: function(e) {
            for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                var a = e[i];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
                a = new b),
                t[n++] = a.x,
                t[n++] = a.y,
                t[n++] = a.z
            }
            return this
        },
        copyVector4sArray: function(e) {
            for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                var a = e[i];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                a = new f),
                t[n++] = a.x,
                t[n++] = a.y,
                t[n++] = a.z,
                t[n++] = a.w
            }
            return this
        },
        applyMatrix3: function(e) {
            for (var t = 0, n = this.count; t < n; t++)
                We.x = this.getX(t),
                We.y = this.getY(t),
                We.z = this.getZ(t),
                We.applyMatrix3(e),
                this.setXYZ(t, We.x, We.y, We.z);
            return this
        },
        applyMatrix4: function(e) {
            for (var t = 0, n = this.count; t < n; t++)
                We.x = this.getX(t),
                We.y = this.getY(t),
                We.z = this.getZ(t),
                We.applyMatrix4(e),
                this.setXYZ(t, We.x, We.y, We.z);
            return this
        },
        applyNormalMatrix: function(e) {
            for (var t = 0, n = this.count; t < n; t++)
                We.x = this.getX(t),
                We.y = this.getY(t),
                We.z = this.getZ(t),
                We.applyNormalMatrix(e),
                this.setXYZ(t, We.x, We.y, We.z);
            return this
        },
        transformDirection: function(e) {
            for (var t = 0, n = this.count; t < n; t++)
                We.x = this.getX(t),
                We.y = this.getY(t),
                We.z = this.getZ(t),
                We.transformDirection(e),
                this.setXYZ(t, We.x, We.y, We.z);
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0),
            this.array.set(e, t),
            this
        },
        getX: function(e) {
            return this.array[e * this.itemSize]
        },
        setX: function(e, t) {
            return this.array[e * this.itemSize] = t,
            this
        },
        getY: function(e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function(e, t) {
            return this.array[e * this.itemSize + 1] = t,
            this
        },
        getZ: function(e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function(e, t) {
            return this.array[e * this.itemSize + 2] = t,
            this
        },
        getW: function(e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function(e, t) {
            return this.array[e * this.itemSize + 3] = t,
            this
        },
        setXY: function(e, t, n) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = n,
            this
        },
        setXYZ: function(e, t, n, i) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = n,
            this.array[e + 2] = i,
            this
        },
        setXYZW: function(e, t, n, i, r) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = n,
            this.array[e + 2] = i,
            this.array[e + 3] = r,
            this
        },
        onUpload: function(e) {
            return this.onUploadCallback = e,
            this
        },
        clone: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        },
        toJSON: function() {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }),
    Xe.prototype = Object.create(qe.prototype),
    Xe.prototype.constructor = Xe,
    Ye.prototype = Object.create(qe.prototype),
    Ye.prototype.constructor = Ye,
    Ze.prototype = Object.create(qe.prototype),
    Ze.prototype.constructor = Ze,
    Je.prototype = Object.create(qe.prototype),
    Je.prototype.constructor = Je,
    Ke.prototype = Object.create(qe.prototype),
    Ke.prototype.constructor = Ke,
    Qe.prototype = Object.create(qe.prototype),
    Qe.prototype.constructor = Qe,
    $e.prototype = Object.create(qe.prototype),
    $e.prototype.constructor = $e,
    et.prototype = Object.create(qe.prototype),
    et.prototype.constructor = et,
    tt.prototype = Object.create(qe.prototype),
    tt.prototype.constructor = tt,
    Object.assign(nt.prototype, {
        computeGroups: function(e) {
            for (var t, n = [], i = void 0, r = e.faces, a = 0; a < r.length; a++) {
                var o = r[a];
                o.materialIndex !== i && (i = o.materialIndex,
                void 0 !== t && (t.count = 3 * a - t.start,
                n.push(t)),
                t = {
                    start: 3 * a,
                    materialIndex: i
                })
            }
            void 0 !== t && (t.count = 3 * a - t.start,
            n.push(t)),
            this.groups = n
        },
        fromGeometry: function(e) {
            var t, n = e.faces, i = e.vertices, r = e.faceVertexUvs, a = r[0] && r[0].length > 0, o = r[1] && r[1].length > 0, s = e.morphTargets, c = s.length;
            if (c > 0) {
                t = [];
                for (var l = 0; l < c; l++)
                    t[l] = {
                        name: s[l].name,
                        data: []
                    };
                this.morphTargets.position = t
            }
            var u, p = e.morphNormals, d = p.length;
            if (d > 0) {
                u = [];
                for (l = 0; l < d; l++)
                    u[l] = {
                        name: p[l].name,
                        data: []
                    };
                this.morphTargets.normal = u
            }
            var f = e.skinIndices
              , m = e.skinWeights
              , v = f.length === i.length
              , g = m.length === i.length;
            i.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
            for (l = 0; l < n.length; l++) {
                var y = n[l];
                this.vertices.push(i[y.a], i[y.b], i[y.c]);
                var x = y.vertexNormals;
                if (3 === x.length)
                    this.normals.push(x[0], x[1], x[2]);
                else {
                    var b = y.normal;
                    this.normals.push(b, b, b)
                }
                var _, w = y.vertexColors;
                if (3 === w.length)
                    this.colors.push(w[0], w[1], w[2]);
                else {
                    var M = y.color;
                    this.colors.push(M, M, M)
                }
                if (!0 === a)
                    void 0 !== (_ = r[0][l]) ? this.uvs.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l),
                    this.uvs.push(new h, new h, new h));
                if (!0 === o)
                    void 0 !== (_ = r[1][l]) ? this.uvs2.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l),
                    this.uvs2.push(new h, new h, new h));
                for (var S = 0; S < c; S++) {
                    var T = s[S].vertices;
                    t[S].data.push(T[y.a], T[y.b], T[y.c])
                }
                for (S = 0; S < d; S++) {
                    var E = p[S].vertexNormals[l];
                    u[S].data.push(E.a, E.b, E.c)
                }
                v && this.skinIndices.push(f[y.a], f[y.b], f[y.c]),
                g && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
            }
            return this.computeGroups(e),
            this.verticesNeedUpdate = e.verticesNeedUpdate,
            this.normalsNeedUpdate = e.normalsNeedUpdate,
            this.colorsNeedUpdate = e.colorsNeedUpdate,
            this.uvsNeedUpdate = e.uvsNeedUpdate,
            this.groupsNeedUpdate = e.groupsNeedUpdate,
            null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            this
        }
    });
    var rt = 1
      , at = new L
      , ot = new q
      , st = new b
      , ct = new se
      , ht = new se
      , lt = new b;
    function ut() {
        Object.defineProperty(this, "id", {
            value: rt += 2
        }),
        this.uuid = c.generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    ut.prototype = Object.assign(Object.create(r.prototype), {
        constructor: ut,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(e) {
            Array.isArray(e) ? this.index = new (it(e) > 65535 ? $e : Ke)(e,1) : this.index = e
        },
        getAttribute: function(e) {
            return this.attributes[e]
        },
        setAttribute: function(e, t) {
            return this.attributes[e] = t,
            this
        },
        deleteAttribute: function(e) {
            return delete this.attributes[e],
            this
        },
        addGroup: function(e, t, n) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: void 0 !== n ? n : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(e, t) {
            this.drawRange.start = e,
            this.drawRange.count = t
        },
        applyMatrix4: function(e) {
            var t = this.attributes.position;
            void 0 !== t && (t.applyMatrix4(e),
            t.needsUpdate = !0);
            var n = this.attributes.normal;
            if (void 0 !== n) {
                var i = (new l).getNormalMatrix(e);
                n.applyNormalMatrix(i),
                n.needsUpdate = !0
            }
            var r = this.attributes.tangent;
            return void 0 !== r && (r.transformDirection(e),
            r.needsUpdate = !0),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        },
        rotateX: function(e) {
            return at.makeRotationX(e),
            this.applyMatrix4(at),
            this
        },
        rotateY: function(e) {
            return at.makeRotationY(e),
            this.applyMatrix4(at),
            this
        },
        rotateZ: function(e) {
            return at.makeRotationZ(e),
            this.applyMatrix4(at),
            this
        },
        translate: function(e, t, n) {
            return at.makeTranslation(e, t, n),
            this.applyMatrix4(at),
            this
        },
        scale: function(e, t, n) {
            return at.makeScale(e, t, n),
            this.applyMatrix4(at),
            this
        },
        lookAt: function(e) {
            return ot.lookAt(e),
            ot.updateMatrix(),
            this.applyMatrix4(ot.matrix),
            this
        },
        center: function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(st).negate(),
            this.translate(st.x, st.y, st.z),
            this
        },
        setFromObject: function(e) {
            var t = e.geometry;
            if (e.isPoints || e.isLine) {
                var n = new et(3 * t.vertices.length,3)
                  , i = new et(3 * t.colors.length,3);
                if (this.setAttribute("position", n.copyVector3sArray(t.vertices)),
                this.setAttribute("color", i.copyColorsArray(t.colors)),
                t.lineDistances && t.lineDistances.length === t.vertices.length) {
                    var r = new et(t.lineDistances.length,1);
                    this.setAttribute("lineDistance", r.copyArray(t.lineDistances))
                }
                null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
            } else
                e.isMesh && t && t.isGeometry && this.fromGeometry(t);
            return this
        },
        setFromPoints: function(e) {
            for (var t = [], n = 0, i = e.length; n < i; n++) {
                var r = e[n];
                t.push(r.x, r.y, r.z || 0)
            }
            return this.setAttribute("position", new et(t,3)),
            this
        },
        updateFromObject: function(e) {
            var t, n = e.geometry;
            if (e.isMesh) {
                var i = n.__directGeometry;
                if (!0 === n.elementsNeedUpdate && (i = void 0,
                n.elementsNeedUpdate = !1),
                void 0 === i)
                    return this.fromGeometry(n);
                i.verticesNeedUpdate = n.verticesNeedUpdate,
                i.normalsNeedUpdate = n.normalsNeedUpdate,
                i.colorsNeedUpdate = n.colorsNeedUpdate,
                i.uvsNeedUpdate = n.uvsNeedUpdate,
                i.groupsNeedUpdate = n.groupsNeedUpdate,
                n.verticesNeedUpdate = !1,
                n.normalsNeedUpdate = !1,
                n.colorsNeedUpdate = !1,
                n.uvsNeedUpdate = !1,
                n.groupsNeedUpdate = !1,
                n = i
            }
            return !0 === n.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(n.vertices),
            t.needsUpdate = !0),
            n.verticesNeedUpdate = !1),
            !0 === n.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(n.normals),
            t.needsUpdate = !0),
            n.normalsNeedUpdate = !1),
            !0 === n.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(n.colors),
            t.needsUpdate = !0),
            n.colorsNeedUpdate = !1),
            n.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(n.uvs),
            t.needsUpdate = !0),
            n.uvsNeedUpdate = !1),
            n.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(n.lineDistances),
            t.needsUpdate = !0),
            n.lineDistancesNeedUpdate = !1),
            n.groupsNeedUpdate && (n.computeGroups(e.geometry),
            this.groups = n.groups,
            n.groupsNeedUpdate = !1),
            this
        },
        fromGeometry: function(e) {
            return e.__directGeometry = (new nt).fromGeometry(e),
            this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function(e) {
            var t = new Float32Array(3 * e.vertices.length);
            if (this.setAttribute("position", new qe(t,3).copyVector3sArray(e.vertices)),
            e.normals.length > 0) {
                var n = new Float32Array(3 * e.normals.length);
                this.setAttribute("normal", new qe(n,3).copyVector3sArray(e.normals))
            }
            if (e.colors.length > 0) {
                var i = new Float32Array(3 * e.colors.length);
                this.setAttribute("color", new qe(i,3).copyColorsArray(e.colors))
            }
            if (e.uvs.length > 0) {
                var r = new Float32Array(2 * e.uvs.length);
                this.setAttribute("uv", new qe(r,2).copyVector2sArray(e.uvs))
            }
            if (e.uvs2.length > 0) {
                var a = new Float32Array(2 * e.uvs2.length);
                this.setAttribute("uv2", new qe(a,2).copyVector2sArray(e.uvs2))
            }
            for (var o in this.groups = e.groups,
            e.morphTargets) {
                for (var s = [], c = e.morphTargets[o], h = 0, l = c.length; h < l; h++) {
                    var u = c[h]
                      , p = new et(3 * u.data.length,3);
                    p.name = u.name,
                    s.push(p.copyVector3sArray(u.data))
                }
                this.morphAttributes[o] = s
            }
            if (e.skinIndices.length > 0) {
                var d = new et(4 * e.skinIndices.length,4);
                this.setAttribute("skinIndex", d.copyVector4sArray(e.skinIndices))
            }
            if (e.skinWeights.length > 0) {
                var f = new et(4 * e.skinWeights.length,4);
                this.setAttribute("skinWeight", f.copyVector4sArray(e.skinWeights))
            }
            return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new se);
            var e = this.attributes.position
              , t = this.morphAttributes.position;
            if (void 0 !== e) {
                if (this.boundingBox.setFromBufferAttribute(e),
                t)
                    for (var n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        ct.setFromBufferAttribute(r),
                        this.morphTargetsRelative ? (lt.addVectors(this.boundingBox.min, ct.min),
                        this.boundingBox.expandByPoint(lt),
                        lt.addVectors(this.boundingBox.max, ct.max),
                        this.boundingBox.expandByPoint(lt)) : (this.boundingBox.expandByPoint(ct.min),
                        this.boundingBox.expandByPoint(ct.max))
                    }
            } else
                this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new le);
            var e = this.attributes.position
              , t = this.morphAttributes.position;
            if (e) {
                var n = this.boundingSphere.center;
                if (ct.setFromBufferAttribute(e),
                t)
                    for (var i = 0, r = t.length; i < r; i++) {
                        var a = t[i];
                        ht.setFromBufferAttribute(a),
                        this.morphTargetsRelative ? (lt.addVectors(ct.min, ht.min),
                        ct.expandByPoint(lt),
                        lt.addVectors(ct.max, ht.max),
                        ct.expandByPoint(lt)) : (ct.expandByPoint(ht.min),
                        ct.expandByPoint(ht.max))
                    }
                ct.getCenter(n);
                var o = 0;
                for (i = 0,
                r = e.count; i < r; i++)
                    lt.fromBufferAttribute(e, i),
                    o = Math.max(o, n.distanceToSquared(lt));
                if (t)
                    for (i = 0,
                    r = t.length; i < r; i++) {
                        a = t[i];
                        for (var s = this.morphTargetsRelative, c = 0, h = a.count; c < h; c++)
                            lt.fromBufferAttribute(a, c),
                            s && (st.fromBufferAttribute(e, c),
                            lt.add(st)),
                            o = Math.max(o, n.distanceToSquared(lt))
                    }
                this.boundingSphere.radius = Math.sqrt(o),
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        },
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var e = this.index
              , t = this.attributes;
            if (t.position) {
                var n = t.position.array;
                if (void 0 === t.normal)
                    this.setAttribute("normal", new qe(new Float32Array(n.length),3));
                else
                    for (var i = t.normal.array, r = 0, a = i.length; r < a; r++)
                        i[r] = 0;
                var o, s, c, h = t.normal.array, l = new b, u = new b, p = new b, d = new b, f = new b;
                if (e) {
                    var m = e.array;
                    for (r = 0,
                    a = e.count; r < a; r += 3)
                        o = 3 * m[r + 0],
                        s = 3 * m[r + 1],
                        c = 3 * m[r + 2],
                        l.fromArray(n, o),
                        u.fromArray(n, s),
                        p.fromArray(n, c),
                        d.subVectors(p, u),
                        f.subVectors(l, u),
                        d.cross(f),
                        h[o] += d.x,
                        h[o + 1] += d.y,
                        h[o + 2] += d.z,
                        h[s] += d.x,
                        h[s + 1] += d.y,
                        h[s + 2] += d.z,
                        h[c] += d.x,
                        h[c + 1] += d.y,
                        h[c + 2] += d.z
                } else
                    for (r = 0,
                    a = n.length; r < a; r += 9)
                        l.fromArray(n, r),
                        u.fromArray(n, r + 3),
                        p.fromArray(n, r + 6),
                        d.subVectors(p, u),
                        f.subVectors(l, u),
                        d.cross(f),
                        h[r] = d.x,
                        h[r + 1] = d.y,
                        h[r + 2] = d.z,
                        h[r + 3] = d.x,
                        h[r + 4] = d.y,
                        h[r + 5] = d.z,
                        h[r + 6] = d.x,
                        h[r + 7] = d.y,
                        h[r + 8] = d.z;
                this.normalizeNormals(),
                t.normal.needsUpdate = !0
            }
        },
        merge: function(e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0,
                console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var n = this.attributes;
                for (var i in n)
                    if (void 0 !== e.attributes[i])
                        for (var r = n[i].array, a = e.attributes[i], o = a.array, s = a.itemSize * t, c = Math.min(o.length, r.length - s), h = 0, l = s; h < c; h++,
                        l++)
                            r[l] = o[h];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
        },
        normalizeNormals: function() {
            for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++)
                lt.x = e.getX(t),
                lt.y = e.getY(t),
                lt.z = e.getZ(t),
                lt.normalize(),
                e.setXYZ(t, lt.x, lt.y, lt.z)
        },
        toNonIndexed: function() {
            function e(e, t) {
                for (var n = e.array, i = e.itemSize, r = e.normalized, a = new n.constructor(t.length * i), o = 0, s = 0, c = 0, h = t.length; c < h; c++) {
                    o = t[c] * i;
                    for (var l = 0; l < i; l++)
                        a[s++] = n[o++]
                }
                return new qe(a,i,r)
            }
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                this;
            var t = new ut
              , n = this.index.array
              , i = this.attributes;
            for (var r in i) {
                var a = e(i[r], n);
                t.setAttribute(r, a)
            }
            var o = this.morphAttributes;
            for (r in o) {
                for (var s = [], c = o[r], h = 0, l = c.length; h < l; h++) {
                    a = e(c[h], n);
                    s.push(a)
                }
                t.morphAttributes[r] = s
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            for (var u = this.groups, p = (h = 0,
            u.length); h < p; h++) {
                var d = u[h];
                t.addGroup(d.start, d.count, d.materialIndex)
            }
            return t
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 && (e.userData = this.userData),
            void 0 !== this.parameters) {
                var t = this.parameters;
                for (var n in t)
                    void 0 !== t[n] && (e[n] = t[n]);
                return e
            }
            e.data = {
                attributes: {}
            };
            var i = this.index;
            null !== i && (e.data.index = {
                type: i.array.constructor.name,
                array: Array.prototype.slice.call(i.array)
            });
            var r = this.attributes;
            for (var n in r) {
                var a = (p = r[n]).toJSON();
                "" !== p.name && (a.name = p.name),
                e.data.attributes[n] = a
            }
            var o = {}
              , s = !1;
            for (var n in this.morphAttributes) {
                for (var c = this.morphAttributes[n], h = [], l = 0, u = c.length; l < u; l++) {
                    var p;
                    a = (p = c[l]).toJSON();
                    "" !== p.name && (a.name = p.name),
                    h.push(a)
                }
                h.length > 0 && (o[n] = h,
                s = !0)
            }
            s && (e.data.morphAttributes = o,
            e.data.morphTargetsRelative = this.morphTargetsRelative);
            var d = this.groups;
            d.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(d)));
            var f = this.boundingSphere;
            return null !== f && (e.data.boundingSphere = {
                center: f.center.toArray(),
                radius: f.radius
            }),
            e
        },
        clone: function() {
            return (new ut).copy(this)
        },
        copy: function(e) {
            var t, n, i;
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = e.name;
            var r = e.index;
            null !== r && this.setIndex(r.clone());
            var a = e.attributes;
            for (t in a) {
                var o = a[t];
                this.setAttribute(t, o.clone())
            }
            var s = e.morphAttributes;
            for (t in s) {
                var c = []
                  , h = s[t];
                for (n = 0,
                i = h.length; n < i; n++)
                    c.push(h[n].clone());
                this.morphAttributes[t] = c
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            var l = e.groups;
            for (n = 0,
            i = l.length; n < i; n++) {
                var u = l[n];
                this.addGroup(u.start, u.count, u.materialIndex)
            }
            var p = e.boundingBox;
            null !== p && (this.boundingBox = p.clone());
            var d = e.boundingSphere;
            return null !== d && (this.boundingSphere = d.clone()),
            this.drawRange.start = e.drawRange.start,
            this.drawRange.count = e.drawRange.count,
            this.userData = e.userData,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var pt = new L
      , dt = new ye
      , ft = new le
      , mt = new b
      , vt = new b
      , gt = new b
      , yt = new b
      , xt = new b
      , bt = new b
      , _t = new b
      , wt = new b
      , Mt = new b
      , St = new h
      , Tt = new h
      , Et = new h
      , At = new b
      , Lt = new b;
    function Rt(e, t) {
        q.call(this),
        this.type = "Mesh",
        this.geometry = void 0 !== e ? e : new ut,
        this.material = void 0 !== t ? t : new je,
        this.updateMorphTargets()
    }
    function Pt(e, t, n, i, r, a, o, s) {
        if (null === (1 === t.side ? i.intersectTriangle(o, a, r, !0, s) : i.intersectTriangle(r, a, o, 2 !== t.side, s)))
            return null;
        Lt.copy(s),
        Lt.applyMatrix4(e.matrixWorld);
        var c = n.ray.origin.distanceTo(Lt);
        return c < n.near || c > n.far ? null : {
            distance: c,
            point: Lt.clone(),
            object: e
        }
    }
    function Ct(e, t, n, i, r, a, o, s, c, l, u, p) {
        mt.fromBufferAttribute(r, l),
        vt.fromBufferAttribute(r, u),
        gt.fromBufferAttribute(r, p);
        var d = e.morphTargetInfluences;
        if (t.morphTargets && a && d) {
            _t.set(0, 0, 0),
            wt.set(0, 0, 0),
            Mt.set(0, 0, 0);
            for (var f = 0, m = a.length; f < m; f++) {
                var v = d[f]
                  , g = a[f];
                0 !== v && (yt.fromBufferAttribute(g, l),
                xt.fromBufferAttribute(g, u),
                bt.fromBufferAttribute(g, p),
                o ? (_t.addScaledVector(yt, v),
                wt.addScaledVector(xt, v),
                Mt.addScaledVector(bt, v)) : (_t.addScaledVector(yt.sub(mt), v),
                wt.addScaledVector(xt.sub(vt), v),
                Mt.addScaledVector(bt.sub(gt), v)))
            }
            mt.add(_t),
            vt.add(wt),
            gt.add(Mt)
        }
        e.isSkinnedMesh && (e.boneTransform(l, mt),
        e.boneTransform(u, vt),
        e.boneTransform(p, gt));
        var y = Pt(e, t, n, i, mt, vt, gt, At);
        if (y) {
            s && (St.fromBufferAttribute(s, l),
            Tt.fromBufferAttribute(s, u),
            Et.fromBufferAttribute(s, p),
            y.uv = Ie.getUV(At, mt, vt, gt, St, Tt, Et, new h)),
            c && (St.fromBufferAttribute(c, l),
            Tt.fromBufferAttribute(c, u),
            Et.fromBufferAttribute(c, p),
            y.uv2 = Ie.getUV(At, mt, vt, gt, St, Tt, Et, new h));
            var x = new ke(l,u,p);
            Ie.getNormal(mt, vt, gt, x.normal),
            y.face = x
        }
        return y
    }
    Rt.prototype = Object.assign(Object.create(q.prototype), {
        constructor: Rt,
        isMesh: !0,
        copy: function(e) {
            return q.prototype.copy.call(this, e),
            void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
            this
        },
        updateMorphTargets: function() {
            var e, t, n, i = this.geometry;
            if (i.isBufferGeometry) {
                var r = i.morphAttributes
                  , a = Object.keys(r);
                if (a.length > 0) {
                    var o = r[a[0]];
                    if (void 0 !== o)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        e = 0,
                        t = o.length; e < t; e++)
                            n = o[e].name || String(e),
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                }
            } else {
                var s = i.morphTargets;
                void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        raycast: function(e, t) {
            var n, i = this.geometry, r = this.material, a = this.matrixWorld;
            if (void 0 !== r && (null === i.boundingSphere && i.computeBoundingSphere(),
            ft.copy(i.boundingSphere),
            ft.applyMatrix4(a),
            !1 !== e.ray.intersectsSphere(ft) && (pt.getInverse(a),
            dt.copy(e.ray).applyMatrix4(pt),
            null === i.boundingBox || !1 !== dt.intersectsBox(i.boundingBox))))
                if (i.isBufferGeometry) {
                    var o, s, c, l, u, p, d, f, m, v = i.index, g = i.attributes.position, y = i.morphAttributes.position, x = i.morphTargetsRelative, b = i.attributes.uv, _ = i.attributes.uv2, w = i.groups, M = i.drawRange;
                    if (null !== v)
                        if (Array.isArray(r))
                            for (l = 0,
                            p = w.length; l < p; l++)
                                for (m = r[(f = w[l]).materialIndex],
                                u = Math.max(f.start, M.start),
                                d = Math.min(f.start + f.count, M.start + M.count); u < d; u += 3)
                                    o = v.getX(u),
                                    s = v.getX(u + 1),
                                    c = v.getX(u + 2),
                                    (n = Ct(this, m, e, dt, g, y, x, b, _, o, s, c)) && (n.faceIndex = Math.floor(u / 3),
                                    n.face.materialIndex = f.materialIndex,
                                    t.push(n));
                        else
                            for (l = Math.max(0, M.start),
                            p = Math.min(v.count, M.start + M.count); l < p; l += 3)
                                o = v.getX(l),
                                s = v.getX(l + 1),
                                c = v.getX(l + 2),
                                (n = Ct(this, r, e, dt, g, y, x, b, _, o, s, c)) && (n.faceIndex = Math.floor(l / 3),
                                t.push(n));
                    else if (void 0 !== g)
                        if (Array.isArray(r))
                            for (l = 0,
                            p = w.length; l < p; l++)
                                for (m = r[(f = w[l]).materialIndex],
                                u = Math.max(f.start, M.start),
                                d = Math.min(f.start + f.count, M.start + M.count); u < d; u += 3)
                                    (n = Ct(this, m, e, dt, g, y, x, b, _, o = u, s = u + 1, c = u + 2)) && (n.faceIndex = Math.floor(u / 3),
                                    n.face.materialIndex = f.materialIndex,
                                    t.push(n));
                        else
                            for (l = Math.max(0, M.start),
                            p = Math.min(g.count, M.start + M.count); l < p; l += 3)
                                (n = Ct(this, r, e, dt, g, y, x, b, _, o = l, s = l + 1, c = l + 2)) && (n.faceIndex = Math.floor(l / 3),
                                t.push(n))
                } else if (i.isGeometry) {
                    var S, T, E, A, L = Array.isArray(r), R = i.vertices, P = i.faces, C = i.faceVertexUvs[0];
                    C.length > 0 && (A = C);
                    for (var O = 0, I = P.length; O < I; O++) {
                        var D = P[O]
                          , N = L ? r[D.materialIndex] : r;
                        if (void 0 !== N && (S = R[D.a],
                        T = R[D.b],
                        E = R[D.c],
                        n = Pt(this, N, e, dt, S, T, E, At))) {
                            if (A && A[O]) {
                                var U = A[O];
                                St.copy(U[0]),
                                Tt.copy(U[1]),
                                Et.copy(U[2]),
                                n.uv = Ie.getUV(At, S, T, E, St, Tt, Et, new h)
                            }
                            n.face = D,
                            n.faceIndex = O,
                            t.push(n)
                        }
                    }
                }
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    });
    var Ot = 0
      , It = new L
      , Dt = new q
      , Nt = new b;
    function Ut() {
        Object.defineProperty(this, "id", {
            value: Ot += 2
        }),
        this.uuid = c.generateUUID(),
        this.name = "",
        this.type = "Geometry",
        this.vertices = [],
        this.colors = [],
        this.faces = [],
        this.faceVertexUvs = [[]],
        this.morphTargets = [],
        this.morphNormals = [],
        this.skinWeights = [],
        this.skinIndices = [],
        this.lineDistances = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.elementsNeedUpdate = !1,
        this.verticesNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.lineDistancesNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    Ut.prototype = Object.assign(Object.create(r.prototype), {
        constructor: Ut,
        isGeometry: !0,
        applyMatrix4: function(e) {
            for (var t = (new l).getNormalMatrix(e), n = 0, i = this.vertices.length; n < i; n++) {
                this.vertices[n].applyMatrix4(e)
            }
            for (n = 0,
            i = this.faces.length; n < i; n++) {
                var r = this.faces[n];
                r.normal.applyMatrix3(t).normalize();
                for (var a = 0, o = r.vertexNormals.length; a < o; a++)
                    r.vertexNormals[a].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this.verticesNeedUpdate = !0,
            this.normalsNeedUpdate = !0,
            this
        },
        rotateX: function(e) {
            return It.makeRotationX(e),
            this.applyMatrix4(It),
            this
        },
        rotateY: function(e) {
            return It.makeRotationY(e),
            this.applyMatrix4(It),
            this
        },
        rotateZ: function(e) {
            return It.makeRotationZ(e),
            this.applyMatrix4(It),
            this
        },
        translate: function(e, t, n) {
            return It.makeTranslation(e, t, n),
            this.applyMatrix4(It),
            this
        },
        scale: function(e, t, n) {
            return It.makeScale(e, t, n),
            this.applyMatrix4(It),
            this
        },
        lookAt: function(e) {
            return Dt.lookAt(e),
            Dt.updateMatrix(),
            this.applyMatrix4(Dt.matrix),
            this
        },
        fromBufferGeometry: function(e) {
            var t = this
              , n = null !== e.index ? e.index.array : void 0
              , i = e.attributes;
            if (void 0 === i.position)
                return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),
                this;
            var r = i.position.array
              , a = void 0 !== i.normal ? i.normal.array : void 0
              , o = void 0 !== i.color ? i.color.array : void 0
              , s = void 0 !== i.uv ? i.uv.array : void 0
              , c = void 0 !== i.uv2 ? i.uv2.array : void 0;
            void 0 !== c && (this.faceVertexUvs[1] = []);
            for (var l = 0; l < r.length; l += 3)
                t.vertices.push((new b).fromArray(r, l)),
                void 0 !== o && t.colors.push((new ze).fromArray(o, l));
            function u(e, n, i, r) {
                var l = void 0 === o ? [] : [t.colors[e].clone(), t.colors[n].clone(), t.colors[i].clone()]
                  , u = new ke(e,n,i,void 0 === a ? [] : [(new b).fromArray(a, 3 * e), (new b).fromArray(a, 3 * n), (new b).fromArray(a, 3 * i)],l,r);
                t.faces.push(u),
                void 0 !== s && t.faceVertexUvs[0].push([(new h).fromArray(s, 2 * e), (new h).fromArray(s, 2 * n), (new h).fromArray(s, 2 * i)]),
                void 0 !== c && t.faceVertexUvs[1].push([(new h).fromArray(c, 2 * e), (new h).fromArray(c, 2 * n), (new h).fromArray(c, 2 * i)])
            }
            var p = e.groups;
            if (p.length > 0)
                for (l = 0; l < p.length; l++)
                    for (var d = p[l], f = d.start, m = f, v = f + d.count; m < v; m += 3)
                        void 0 !== n ? u(n[m], n[m + 1], n[m + 2], d.materialIndex) : u(m, m + 1, m + 2, d.materialIndex);
            else if (void 0 !== n)
                for (l = 0; l < n.length; l += 3)
                    u(n[l], n[l + 1], n[l + 2]);
            else
                for (l = 0; l < r.length / 3; l += 3)
                    u(l, l + 1, l + 2);
            return this.computeFaceNormals(),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            this
        },
        center: function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(Nt).negate(),
            this.translate(Nt.x, Nt.y, Nt.z),
            this
        },
        normalize: function() {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center
              , t = this.boundingSphere.radius
              , n = 0 === t ? 1 : 1 / t
              , i = new L;
            return i.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1),
            this.applyMatrix4(i),
            this
        },
        computeFaceNormals: function() {
            for (var e = new b, t = new b, n = 0, i = this.faces.length; n < i; n++) {
                var r = this.faces[n]
                  , a = this.vertices[r.a]
                  , o = this.vertices[r.b]
                  , s = this.vertices[r.c];
                e.subVectors(s, o),
                t.subVectors(a, o),
                e.cross(t),
                e.normalize(),
                r.normal.copy(e)
            }
        },
        computeVertexNormals: function(e) {
            var t, n, i, r, a, o;
            for (void 0 === e && (e = !0),
            o = new Array(this.vertices.length),
            t = 0,
            n = this.vertices.length; t < n; t++)
                o[t] = new b;
            if (e) {
                var s, c, h, l = new b, u = new b;
                for (i = 0,
                r = this.faces.length; i < r; i++)
                    a = this.faces[i],
                    s = this.vertices[a.a],
                    c = this.vertices[a.b],
                    h = this.vertices[a.c],
                    l.subVectors(h, c),
                    u.subVectors(s, c),
                    l.cross(u),
                    o[a.a].add(l),
                    o[a.b].add(l),
                    o[a.c].add(l)
            } else
                for (this.computeFaceNormals(),
                i = 0,
                r = this.faces.length; i < r; i++)
                    o[(a = this.faces[i]).a].add(a.normal),
                    o[a.b].add(a.normal),
                    o[a.c].add(a.normal);
            for (t = 0,
            n = this.vertices.length; t < n; t++)
                o[t].normalize();
            for (i = 0,
            r = this.faces.length; i < r; i++) {
                var p = (a = this.faces[i]).vertexNormals;
                3 === p.length ? (p[0].copy(o[a.a]),
                p[1].copy(o[a.b]),
                p[2].copy(o[a.c])) : (p[0] = o[a.a].clone(),
                p[1] = o[a.b].clone(),
                p[2] = o[a.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var e, t, n;
            for (this.computeFaceNormals(),
            e = 0,
            t = this.faces.length; e < t; e++) {
                var i = (n = this.faces[e]).vertexNormals;
                3 === i.length ? (i[0].copy(n.normal),
                i[1].copy(n.normal),
                i[2].copy(n.normal)) : (i[0] = n.normal.clone(),
                i[1] = n.normal.clone(),
                i[2] = n.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var e, t, n, i, r;
            for (n = 0,
            i = this.faces.length; n < i; n++)
                for ((r = this.faces[n]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(),
                r.__originalVertexNormals || (r.__originalVertexNormals = []),
                e = 0,
                t = r.vertexNormals.length; e < t; e++)
                    r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : r.__originalVertexNormals[e] = r.vertexNormals[e].clone();
            var a = new Ut;
            for (a.faces = this.faces,
            e = 0,
            t = this.morphTargets.length; e < t; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {},
                    this.morphNormals[e].faceNormals = [],
                    this.morphNormals[e].vertexNormals = [];
                    var o = this.morphNormals[e].faceNormals
                      , s = this.morphNormals[e].vertexNormals;
                    for (n = 0,
                    i = this.faces.length; n < i; n++)
                        c = new b,
                        h = {
                            a: new b,
                            b: new b,
                            c: new b
                        },
                        o.push(c),
                        s.push(h)
                }
                var c, h, l = this.morphNormals[e];
                for (a.vertices = this.morphTargets[e].vertices,
                a.computeFaceNormals(),
                a.computeVertexNormals(),
                n = 0,
                i = this.faces.length; n < i; n++)
                    r = this.faces[n],
                    c = l.faceNormals[n],
                    h = l.vertexNormals[n],
                    c.copy(r.normal),
                    h.a.copy(r.vertexNormals[0]),
                    h.b.copy(r.vertexNormals[1]),
                    h.c.copy(r.vertexNormals[2])
            }
            for (n = 0,
            i = this.faces.length; n < i; n++)
                (r = this.faces[n]).normal = r.__originalFaceNormal,
                r.vertexNormals = r.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new se),
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new le),
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(e, t, n) {
            if (e && e.isGeometry) {
                var i, r = this.vertices.length, a = this.vertices, o = e.vertices, s = this.faces, c = e.faces, h = this.colors, u = e.colors;
                void 0 === n && (n = 0),
                void 0 !== t && (i = (new l).getNormalMatrix(t));
                for (var p = 0, d = o.length; p < d; p++) {
                    var f = o[p].clone();
                    void 0 !== t && f.applyMatrix4(t),
                    a.push(f)
                }
                for (p = 0,
                d = u.length; p < d; p++)
                    h.push(u[p].clone());
                for (p = 0,
                d = c.length; p < d; p++) {
                    var m, v, g, y = c[p], x = y.vertexNormals, b = y.vertexColors;
                    (m = new ke(y.a + r,y.b + r,y.c + r)).normal.copy(y.normal),
                    void 0 !== i && m.normal.applyMatrix3(i).normalize();
                    for (var _ = 0, w = x.length; _ < w; _++)
                        v = x[_].clone(),
                        void 0 !== i && v.applyMatrix3(i).normalize(),
                        m.vertexNormals.push(v);
                    m.color.copy(y.color);
                    for (_ = 0,
                    w = b.length; _ < w; _++)
                        g = b[_],
                        m.vertexColors.push(g.clone());
                    m.materialIndex = y.materialIndex + n,
                    s.push(m)
                }
                for (p = 0,
                d = e.faceVertexUvs.length; p < d; p++) {
                    var M = e.faceVertexUvs[p];
                    void 0 === this.faceVertexUvs[p] && (this.faceVertexUvs[p] = []);
                    for (_ = 0,
                    w = M.length; _ < w; _++) {
                        for (var S = M[_], T = [], E = 0, A = S.length; E < A; E++)
                            T.push(S[E].clone());
                        this.faceVertexUvs[p].push(T)
                    }
                }
            } else
                console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
        },
        mergeMesh: function(e) {
            e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(),
            this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
        },
        mergeVertices: function() {
            var e, t, n, i, r, a, o, s, c = {}, h = [], l = [], u = Math.pow(10, 4);
            for (n = 0,
            i = this.vertices.length; n < i; n++)
                e = this.vertices[n],
                void 0 === c[t = Math.round(e.x * u) + "_" + Math.round(e.y * u) + "_" + Math.round(e.z * u)] ? (c[t] = n,
                h.push(this.vertices[n]),
                l[n] = h.length - 1) : l[n] = l[c[t]];
            var p = [];
            for (n = 0,
            i = this.faces.length; n < i; n++) {
                (r = this.faces[n]).a = l[r.a],
                r.b = l[r.b],
                r.c = l[r.c],
                a = [r.a, r.b, r.c];
                for (var d = 0; d < 3; d++)
                    if (a[d] === a[(d + 1) % 3]) {
                        p.push(n);
                        break
                    }
            }
            for (n = p.length - 1; n >= 0; n--) {
                var f = p[n];
                for (this.faces.splice(f, 1),
                o = 0,
                s = this.faceVertexUvs.length; o < s; o++)
                    this.faceVertexUvs[o].splice(f, 1)
            }
            var m = this.vertices.length - h.length;
            return this.vertices = h,
            m
        },
        setFromPoints: function(e) {
            this.vertices = [];
            for (var t = 0, n = e.length; t < n; t++) {
                var i = e[t];
                this.vertices.push(new b(i.x,i.y,i.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var e = this.faces, t = e.length, n = 0; n < t; n++)
                e[n]._id = n;
            e.sort((function(e, t) {
                return e.materialIndex - t.materialIndex
            }
            ));
            var i, r, a = this.faceVertexUvs[0], o = this.faceVertexUvs[1];
            a && a.length === t && (i = []),
            o && o.length === t && (r = []);
            for (n = 0; n < t; n++) {
                var s = e[n]._id;
                i && i.push(a[s]),
                r && r.push(o[s])
            }
            i && (this.faceVertexUvs[0] = i),
            r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            "" !== this.name && (e.name = this.name),
            void 0 !== this.parameters) {
                var t = this.parameters;
                for (var n in t)
                    void 0 !== t[n] && (e[n] = t[n]);
                return e
            }
            for (var i = [], r = 0; r < this.vertices.length; r++) {
                var a = this.vertices[r];
                i.push(a.x, a.y, a.z)
            }
            var o = []
              , s = []
              , c = {}
              , h = []
              , l = {}
              , u = []
              , p = {};
            for (r = 0; r < this.faces.length; r++) {
                var d = this.faces[r]
                  , f = void 0 !== this.faceVertexUvs[0][r]
                  , m = d.normal.length() > 0
                  , v = d.vertexNormals.length > 0
                  , g = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b
                  , y = d.vertexColors.length > 0
                  , x = 0;
                if (x = M(x, 0, 0),
                x = M(x, 1, !0),
                x = M(x, 2, !1),
                x = M(x, 3, f),
                x = M(x, 4, m),
                x = M(x, 5, v),
                x = M(x, 6, g),
                x = M(x, 7, y),
                o.push(x),
                o.push(d.a, d.b, d.c),
                o.push(d.materialIndex),
                f) {
                    var b = this.faceVertexUvs[0][r];
                    o.push(E(b[0]), E(b[1]), E(b[2]))
                }
                if (m && o.push(S(d.normal)),
                v) {
                    var _ = d.vertexNormals;
                    o.push(S(_[0]), S(_[1]), S(_[2]))
                }
                if (g && o.push(T(d.color)),
                y) {
                    var w = d.vertexColors;
                    o.push(T(w[0]), T(w[1]), T(w[2]))
                }
            }
            function M(e, t, n) {
                return n ? e | 1 << t : e & ~(1 << t)
            }
            function S(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== c[t] || (c[t] = s.length / 3,
                s.push(e.x, e.y, e.z)),
                c[t]
            }
            function T(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== l[t] || (l[t] = h.length,
                h.push(e.getHex())),
                l[t]
            }
            function E(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== p[t] || (p[t] = u.length / 2,
                u.push(e.x, e.y)),
                p[t]
            }
            return e.data = {},
            e.data.vertices = i,
            e.data.normals = s,
            h.length > 0 && (e.data.colors = h),
            u.length > 0 && (e.data.uvs = [u]),
            e.data.faces = o,
            e
        },
        clone: function() {
            return (new Ut).copy(this)
        },
        copy: function(e) {
            var t, n, i, r, a, o;
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = e.name;
            var s = e.vertices;
            for (t = 0,
            n = s.length; t < n; t++)
                this.vertices.push(s[t].clone());
            var c = e.colors;
            for (t = 0,
            n = c.length; t < n; t++)
                this.colors.push(c[t].clone());
            var h = e.faces;
            for (t = 0,
            n = h.length; t < n; t++)
                this.faces.push(h[t].clone());
            for (t = 0,
            n = e.faceVertexUvs.length; t < n; t++) {
                var l = e.faceVertexUvs[t];
                for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []),
                i = 0,
                r = l.length; i < r; i++) {
                    var u = l[i]
                      , p = [];
                    for (a = 0,
                    o = u.length; a < o; a++) {
                        var d = u[a];
                        p.push(d.clone())
                    }
                    this.faceVertexUvs[t].push(p)
                }
            }
            var f = e.morphTargets;
            for (t = 0,
            n = f.length; t < n; t++) {
                var m = {};
                if (m.name = f[t].name,
                void 0 !== f[t].vertices)
                    for (m.vertices = [],
                    i = 0,
                    r = f[t].vertices.length; i < r; i++)
                        m.vertices.push(f[t].vertices[i].clone());
                if (void 0 !== f[t].normals)
                    for (m.normals = [],
                    i = 0,
                    r = f[t].normals.length; i < r; i++)
                        m.normals.push(f[t].normals[i].clone());
                this.morphTargets.push(m)
            }
            var v = e.morphNormals;
            for (t = 0,
            n = v.length; t < n; t++) {
                var g = {};
                if (void 0 !== v[t].vertexNormals)
                    for (g.vertexNormals = [],
                    i = 0,
                    r = v[t].vertexNormals.length; i < r; i++) {
                        var y = v[t].vertexNormals[i]
                          , x = {};
                        x.a = y.a.clone(),
                        x.b = y.b.clone(),
                        x.c = y.c.clone(),
                        g.vertexNormals.push(x)
                    }
                if (void 0 !== v[t].faceNormals)
                    for (g.faceNormals = [],
                    i = 0,
                    r = v[t].faceNormals.length; i < r; i++)
                        g.faceNormals.push(v[t].faceNormals[i].clone());
                this.morphNormals.push(g)
            }
            var b = e.skinWeights;
            for (t = 0,
            n = b.length; t < n; t++)
                this.skinWeights.push(b[t].clone());
            var _ = e.skinIndices;
            for (t = 0,
            n = _.length; t < n; t++)
                this.skinIndices.push(_[t].clone());
            var w = e.lineDistances;
            for (t = 0,
            n = w.length; t < n; t++)
                this.lineDistances.push(w[t]);
            var M = e.boundingBox;
            null !== M && (this.boundingBox = M.clone());
            var S = e.boundingSphere;
            return null !== S && (this.boundingSphere = S.clone()),
            this.elementsNeedUpdate = e.elementsNeedUpdate,
            this.verticesNeedUpdate = e.verticesNeedUpdate,
            this.uvsNeedUpdate = e.uvsNeedUpdate,
            this.normalsNeedUpdate = e.normalsNeedUpdate,
            this.colorsNeedUpdate = e.colorsNeedUpdate,
            this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate,
            this.groupsNeedUpdate = e.groupsNeedUpdate,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    class zt extends ut {
        constructor(e, t, n, i, r, a) {
            super(),
            this.type = "BoxBufferGeometry",
            this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: a
            };
            const o = this;
            e = e || 1,
            t = t || 1,
            n = n || 1,
            i = Math.floor(i) || 1,
            r = Math.floor(r) || 1,
            a = Math.floor(a) || 1;
            const s = []
              , c = []
              , h = []
              , l = [];
            let u = 0
              , p = 0;
            function d(e, t, n, i, r, a, d, f, m, v, g) {
                const y = a / m
                  , x = d / v
                  , _ = a / 2
                  , w = d / 2
                  , M = f / 2
                  , S = m + 1
                  , T = v + 1;
                let E = 0
                  , A = 0;
                const L = new b;
                for (let a = 0; a < T; a++) {
                    const o = a * x - w;
                    for (let s = 0; s < S; s++) {
                        const u = s * y - _;
                        L[e] = u * i,
                        L[t] = o * r,
                        L[n] = M,
                        c.push(L.x, L.y, L.z),
                        L[e] = 0,
                        L[t] = 0,
                        L[n] = f > 0 ? 1 : -1,
                        h.push(L.x, L.y, L.z),
                        l.push(s / m),
                        l.push(1 - a / v),
                        E += 1
                    }
                }
                for (let e = 0; e < v; e++)
                    for (let t = 0; t < m; t++) {
                        const n = u + t + S * e
                          , i = u + t + S * (e + 1)
                          , r = u + (t + 1) + S * (e + 1)
                          , a = u + (t + 1) + S * e;
                        s.push(n, i, a),
                        s.push(i, r, a),
                        A += 6
                    }
                o.addGroup(p, A, g),
                p += A,
                u += E
            }
            d("z", "y", "x", -1, -1, n, t, e, a, r, 0),
            d("z", "y", "x", 1, -1, n, t, -e, a, r, 1),
            d("x", "z", "y", 1, 1, e, n, t, i, a, 2),
            d("x", "z", "y", 1, -1, e, n, -t, i, a, 3),
            d("x", "y", "z", 1, -1, e, t, n, i, r, 4),
            d("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
            this.setIndex(s),
            this.setAttribute("position", new et(c,3)),
            this.setAttribute("normal", new et(h,3)),
            this.setAttribute("uv", new et(l,2))
        }
    }
    function Bt(e) {
        var t = {};
        for (var n in e)
            for (var i in t[n] = {},
            e[n]) {
                var r = e[n][i];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
            }
        return t
    }
    function Ft(e) {
        for (var t = {}, n = 0; n < e.length; n++) {
            var i = Bt(e[n]);
            for (var r in i)
                t[r] = i[r]
        }
        return t
    }
    var Ht = {
        clone: Bt,
        merge: Ft
    };
    function kt(e) {
        Ve.call(this),
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        this.setValues(e))
    }
    function Gt() {
        q.call(this),
        this.type = "Camera",
        this.matrixWorldInverse = new L,
        this.projectionMatrix = new L,
        this.projectionMatrixInverse = new L
    }
    function Vt(e, t, n, i) {
        Gt.call(this),
        this.type = "PerspectiveCamera",
        this.fov = void 0 !== e ? e : 50,
        this.zoom = 1,
        this.near = void 0 !== n ? n : .1,
        this.far = void 0 !== i ? i : 2e3,
        this.focus = 10,
        this.aspect = void 0 !== t ? t : 1,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    kt.prototype = Object.create(Ve.prototype),
    kt.prototype.constructor = kt,
    kt.prototype.isShaderMaterial = !0,
    kt.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Bt(e.uniforms),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this.extensions = Object.assign({}, e.extensions),
        this
    }
    ,
    kt.prototype.toJSON = function(e) {
        var t = Ve.prototype.toJSON.call(this, e);
        for (var n in t.uniforms = {},
        this.uniforms) {
            var i = this.uniforms[n].value;
            i && i.isTexture ? t.uniforms[n] = {
                type: "t",
                value: i.toJSON(e).uuid
            } : i && i.isColor ? t.uniforms[n] = {
                type: "c",
                value: i.getHex()
            } : i && i.isVector2 ? t.uniforms[n] = {
                type: "v2",
                value: i.toArray()
            } : i && i.isVector3 ? t.uniforms[n] = {
                type: "v3",
                value: i.toArray()
            } : i && i.isVector4 ? t.uniforms[n] = {
                type: "v4",
                value: i.toArray()
            } : i && i.isMatrix3 ? t.uniforms[n] = {
                type: "m3",
                value: i.toArray()
            } : i && i.isMatrix4 ? t.uniforms[n] = {
                type: "m4",
                value: i.toArray()
            } : t.uniforms[n] = {
                value: i
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
        var r = {};
        for (var a in this.extensions)
            !0 === this.extensions[a] && (r[a] = !0);
        return Object.keys(r).length > 0 && (t.extensions = r),
        t
    }
    ,
    Gt.prototype = Object.assign(Object.create(q.prototype), {
        constructor: Gt,
        isCamera: !0,
        copy: function(e, t) {
            return q.prototype.copy.call(this, e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
            e = new b),
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        updateMatrixWorld: function(e) {
            q.prototype.updateMatrixWorld.call(this, e),
            this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        updateWorldMatrix: function(e, t) {
            q.prototype.updateWorldMatrix.call(this, e, t),
            this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    Vt.prototype = Object.assign(Object.create(Gt.prototype), {
        constructor: Vt,
        isPerspectiveCamera: !0,
        copy: function(e, t) {
            return Gt.prototype.copy.call(this, e, t),
            this.fov = e.fov,
            this.zoom = e.zoom,
            this.near = e.near,
            this.far = e.far,
            this.focus = e.focus,
            this.aspect = e.aspect,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this.filmGauge = e.filmGauge,
            this.filmOffset = e.filmOffset,
            this
        },
        setFocalLength: function(e) {
            var t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * c.RAD2DEG * Math.atan(t),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var e = Math.tan(.5 * c.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function() {
            return 2 * c.RAD2DEG * Math.atan(Math.tan(.5 * c.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(e, t, n, i, r, a) {
            this.aspect = e / t,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = n,
            this.view.offsetY = i,
            this.view.width = r,
            this.view.height = a,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = this.near
              , t = e * Math.tan(.5 * c.DEG2RAD * this.fov) / this.zoom
              , n = 2 * t
              , i = this.aspect * n
              , r = -.5 * i
              , a = this.view;
            if (null !== this.view && this.view.enabled) {
                var o = a.fullWidth
                  , s = a.fullHeight;
                r += a.offsetX * i / o,
                t -= a.offsetY * n / s,
                i *= a.width / o,
                n *= a.height / s
            }
            var h = this.filmOffset;
            0 !== h && (r += e * h / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            var t = q.prototype.toJSON.call(this, e);
            return t.object.fov = this.fov,
            t.object.zoom = this.zoom,
            t.object.near = this.near,
            t.object.far = this.far,
            t.object.focus = this.focus,
            t.object.aspect = this.aspect,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t.object.filmGauge = this.filmGauge,
            t.object.filmOffset = this.filmOffset,
            t
        }
    });
    function jt(e, t, n) {
        if (q.call(this),
        this.type = "CubeCamera",
        !0 === n.isWebGLCubeRenderTarget) {
            this.renderTarget = n;
            var i = new Vt(90,1,e,t);
            i.layers = this.layers,
            i.up.set(0, -1, 0),
            i.lookAt(new b(1,0,0)),
            this.add(i);
            var r = new Vt(90,1,e,t);
            r.layers = this.layers,
            r.up.set(0, -1, 0),
            r.lookAt(new b(-1,0,0)),
            this.add(r);
            var a = new Vt(90,1,e,t);
            a.layers = this.layers,
            a.up.set(0, 0, 1),
            a.lookAt(new b(0,1,0)),
            this.add(a);
            var o = new Vt(90,1,e,t);
            o.layers = this.layers,
            o.up.set(0, 0, -1),
            o.lookAt(new b(0,-1,0)),
            this.add(o);
            var s = new Vt(90,1,e,t);
            s.layers = this.layers,
            s.up.set(0, -1, 0),
            s.lookAt(new b(0,0,1)),
            this.add(s);
            var c = new Vt(90,1,e,t);
            c.layers = this.layers,
            c.up.set(0, -1, 0),
            c.lookAt(new b(0,0,-1)),
            this.add(c),
            this.update = function(e, t) {
                null === this.parent && this.updateMatrixWorld();
                var h = e.xr.enabled
                  , l = e.getRenderTarget();
                e.xr.enabled = !1;
                var u = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1,
                e.setRenderTarget(n, 0),
                e.render(t, i),
                e.setRenderTarget(n, 1),
                e.render(t, r),
                e.setRenderTarget(n, 2),
                e.render(t, a),
                e.setRenderTarget(n, 3),
                e.render(t, o),
                e.setRenderTarget(n, 4),
                e.render(t, s),
                n.texture.generateMipmaps = u,
                e.setRenderTarget(n, 5),
                e.render(t, c),
                e.setRenderTarget(l),
                e.xr.enabled = h
            }
            ,
            this.clear = function(e, t, i, r) {
                for (var a = e.getRenderTarget(), o = 0; o < 6; o++)
                    e.setRenderTarget(n, o),
                    e.clear(t, i, r);
                e.setRenderTarget(a)
            }
        } else
            console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.")
    }
    function Wt(e, t, n) {
        Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
        t = n),
        m.call(this, e, e, t)
    }
    function qt(e, t, n, i, r, a, o, s, c, h, l, u) {
        d.call(this, null, a, o, s, c, h, i, r, l, u),
        this.image = {
            data: e || null,
            width: t || 1,
            height: n || 1
        },
        this.magFilter = void 0 !== c ? c : 1003,
        this.minFilter = void 0 !== h ? h : 1003,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.needsUpdate = !0
    }
    jt.prototype = Object.create(q.prototype),
    jt.prototype.constructor = jt,
    Wt.prototype = Object.create(m.prototype),
    Wt.prototype.constructor = Wt,
    Wt.prototype.isWebGLCubeRenderTarget = !0,
    Wt.prototype.fromEquirectangularTexture = function(e, t) {
        this.texture.type = t.type,
        this.texture.format = t.format,
        this.texture.encoding = t.encoding;
        var n = new X
          , i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "\tvWorldDirection = transformDirection( position, modelMatrix );", "\t#include <begin_vertex>", "\t#include <project_vertex>", "}"].join("\n"),
            fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#include <common>", "void main() {", "\tvec3 direction = normalize( vWorldDirection );", "\tvec2 sampleUV = equirectUv( direction );", "\tgl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n")
        }
          , r = new kt({
            type: "CubemapFromEquirect",
            uniforms: Bt(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: 1,
            blending: 0
        });
        r.uniforms.tEquirect.value = t;
        var a = new Rt(new zt(5,5,5),r);
        return n.add(a),
        new jt(1,10,this).update(e, n),
        a.geometry.dispose(),
        a.material.dispose(),
        this
    }
    ,
    qt.prototype = Object.create(d.prototype),
    qt.prototype.constructor = qt,
    qt.prototype.isDataTexture = !0;
    var Xt = new le
      , Yt = new b;
    function Zt(e, t, n, i, r, a) {
        this.planes = [void 0 !== e ? e : new we, void 0 !== t ? t : new we, void 0 !== n ? n : new we, void 0 !== i ? i : new we, void 0 !== r ? r : new we, void 0 !== a ? a : new we]
    }
    Object.assign(Zt.prototype, {
        set: function(e, t, n, i, r, a) {
            var o = this.planes;
            return o[0].copy(e),
            o[1].copy(t),
            o[2].copy(n),
            o[3].copy(i),
            o[4].copy(r),
            o[5].copy(a),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            for (var t = this.planes, n = 0; n < 6; n++)
                t[n].copy(e.planes[n]);
            return this
        },
        setFromProjectionMatrix: function(e) {
            var t = this.planes
              , n = e.elements
              , i = n[0]
              , r = n[1]
              , a = n[2]
              , o = n[3]
              , s = n[4]
              , c = n[5]
              , h = n[6]
              , l = n[7]
              , u = n[8]
              , p = n[9]
              , d = n[10]
              , f = n[11]
              , m = n[12]
              , v = n[13]
              , g = n[14]
              , y = n[15];
            return t[0].setComponents(o - i, l - s, f - u, y - m).normalize(),
            t[1].setComponents(o + i, l + s, f + u, y + m).normalize(),
            t[2].setComponents(o + r, l + c, f + p, y + v).normalize(),
            t[3].setComponents(o - r, l - c, f - p, y - v).normalize(),
            t[4].setComponents(o - a, l - h, f - d, y - g).normalize(),
            t[5].setComponents(o + a, l + h, f + d, y + g).normalize(),
            this
        },
        intersectsObject: function(e) {
            var t = e.geometry;
            return null === t.boundingSphere && t.computeBoundingSphere(),
            Xt.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Xt)
        },
        intersectsSprite: function(e) {
            return Xt.center.set(0, 0, 0),
            Xt.radius = .7071067811865476,
            Xt.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Xt)
        },
        intersectsSphere: function(e) {
            for (var t = this.planes, n = e.center, i = -e.radius, r = 0; r < 6; r++) {
                if (t[r].distanceToPoint(n) < i)
                    return !1
            }
            return !0
        },
        intersectsBox: function(e) {
            for (var t = this.planes, n = 0; n < 6; n++) {
                var i = t[n];
                if (Yt.x = i.normal.x > 0 ? e.max.x : e.min.x,
                Yt.y = i.normal.y > 0 ? e.max.y : e.min.y,
                Yt.z = i.normal.z > 0 ? e.max.z : e.min.z,
                i.distanceToPoint(Yt) < 0)
                    return !1
            }
            return !0
        },
        containsPoint: function(e) {
            for (var t = this.planes, n = 0; n < 6; n++)
                if (t[n].distanceToPoint(e) < 0)
                    return !1;
            return !0
        }
    });
    var Jt = {
        common: {
            diffuse: {
                value: new ze(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new l
            },
            uv2Transform: {
                value: new l
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new h(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new ze(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new ze(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new l
            }
        },
        sprite: {
            diffuse: {
                value: new ze(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new h(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new l
            }
        }
    };
    function Kt() {
        var e = null
          , t = !1
          , n = null;
        function i(r, a) {
            !1 !== t && (n(r, a),
            e.requestAnimationFrame(i))
        }
        return {
            start: function() {
                !0 !== t && null !== n && (e.requestAnimationFrame(i),
                t = !0)
            },
            stop: function() {
                t = !1
            },
            setAnimationLoop: function(e) {
                n = e
            },
            setContext: function(t) {
                e = t
            }
        }
    }
    function Qt(e, t) {
        var n = t.isWebGL2
          , i = new WeakMap;
        return {
            get: function(e) {
                return e.isInterleavedBufferAttribute && (e = e.data),
                i.get(e)
            },
            remove: function(t) {
                t.isInterleavedBufferAttribute && (t = t.data);
                var n = i.get(t);
                n && (e.deleteBuffer(n.buffer),
                i.delete(t))
            },
            update: function(t, r) {
                t.isInterleavedBufferAttribute && (t = t.data);
                var a = i.get(t);
                void 0 === a ? i.set(t, function(t, n) {
                    var i = t.array
                      , r = t.usage
                      , a = e.createBuffer();
                    e.bindBuffer(n, a),
                    e.bufferData(n, i, r),
                    t.onUploadCallback();
                    var o = 5126;
                    return i instanceof Float32Array ? o = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? o = 5123 : i instanceof Int16Array ? o = 5122 : i instanceof Uint32Array ? o = 5125 : i instanceof Int32Array ? o = 5124 : i instanceof Int8Array ? o = 5120 : i instanceof Uint8Array && (o = 5121),
                    {
                        buffer: a,
                        type: o,
                        bytesPerElement: i.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }(t, r)) : a.version < t.version && (!function(t, i, r) {
                    var a = i.array
                      , o = i.updateRange;
                    e.bindBuffer(r, t),
                    -1 === o.count ? e.bufferSubData(r, 0, a) : (n ? e.bufferSubData(r, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : e.bufferSubData(r, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)),
                    o.count = -1)
                }(a.buffer, t, r),
                a.version = t.version)
            }
        }
    }
    function $t(e, t, n, i) {
        Ut.call(this),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: i
        },
        this.fromBufferGeometry(new en(e,t,n,i)),
        this.mergeVertices()
    }
    function en(e, t, n, i) {
        ut.call(this),
        this.type = "PlaneBufferGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: i
        };
        var r, a, o = (e = e || 1) / 2, s = (t = t || 1) / 2, c = Math.floor(n) || 1, h = Math.floor(i) || 1, l = c + 1, u = h + 1, p = e / c, d = t / h, f = [], m = [], v = [], g = [];
        for (a = 0; a < u; a++) {
            var y = a * d - s;
            for (r = 0; r < l; r++) {
                var x = r * p - o;
                m.push(x, -y, 0),
                v.push(0, 0, 1),
                g.push(r / c),
                g.push(1 - a / h)
            }
        }
        for (a = 0; a < h; a++)
            for (r = 0; r < c; r++) {
                var b = r + l * a
                  , _ = r + l * (a + 1)
                  , w = r + 1 + l * (a + 1)
                  , M = r + 1 + l * a;
                f.push(b, _, M),
                f.push(_, w, M)
            }
        this.setIndex(f),
        this.setAttribute("position", new et(m,3)),
        this.setAttribute("normal", new et(v,3)),
        this.setAttribute("uv", new et(g,2))
    }
    $t.prototype = Object.create(Ut.prototype),
    $t.prototype.constructor = $t,
    en.prototype = Object.create(ut.prototype),
    en.prototype.constructor = en;
    var tn = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
        uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
    }
      , nn = {
        basic: {
            uniforms: Ft([Jt.common, Jt.specularmap, Jt.envmap, Jt.aomap, Jt.lightmap, Jt.fog]),
            vertexShader: tn.meshbasic_vert,
            fragmentShader: tn.meshbasic_frag
        },
        lambert: {
            uniforms: Ft([Jt.common, Jt.specularmap, Jt.envmap, Jt.aomap, Jt.lightmap, Jt.emissivemap, Jt.fog, Jt.lights, {
                emissive: {
                    value: new ze(0)
                }
            }]),
            vertexShader: tn.meshlambert_vert,
            fragmentShader: tn.meshlambert_frag
        },
        phong: {
            uniforms: Ft([Jt.common, Jt.specularmap, Jt.envmap, Jt.aomap, Jt.lightmap, Jt.emissivemap, Jt.bumpmap, Jt.normalmap, Jt.displacementmap, Jt.fog, Jt.lights, {
                emissive: {
                    value: new ze(0)
                },
                specular: {
                    value: new ze(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: tn.meshphong_vert,
            fragmentShader: tn.meshphong_frag
        },
        standard: {
            uniforms: Ft([Jt.common, Jt.envmap, Jt.aomap, Jt.lightmap, Jt.emissivemap, Jt.bumpmap, Jt.normalmap, Jt.displacementmap, Jt.roughnessmap, Jt.metalnessmap, Jt.fog, Jt.lights, {
                emissive: {
                    value: new ze(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: tn.meshphysical_vert,
            fragmentShader: tn.meshphysical_frag
        },
        toon: {
            uniforms: Ft([Jt.common, Jt.specularmap, Jt.aomap, Jt.lightmap, Jt.emissivemap, Jt.bumpmap, Jt.normalmap, Jt.displacementmap, Jt.gradientmap, Jt.fog, Jt.lights, {
                emissive: {
                    value: new ze(0)
                },
                specular: {
                    value: new ze(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: tn.meshtoon_vert,
            fragmentShader: tn.meshtoon_frag
        },
        matcap: {
            uniforms: Ft([Jt.common, Jt.bumpmap, Jt.normalmap, Jt.displacementmap, Jt.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: tn.meshmatcap_vert,
            fragmentShader: tn.meshmatcap_frag
        },
        points: {
            uniforms: Ft([Jt.points, Jt.fog]),
            vertexShader: tn.points_vert,
            fragmentShader: tn.points_frag
        },
        dashed: {
            uniforms: Ft([Jt.common, Jt.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: tn.linedashed_vert,
            fragmentShader: tn.linedashed_frag
        },
        depth: {
            uniforms: Ft([Jt.common, Jt.displacementmap]),
            vertexShader: tn.depth_vert,
            fragmentShader: tn.depth_frag
        },
        normal: {
            uniforms: Ft([Jt.common, Jt.bumpmap, Jt.normalmap, Jt.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: tn.normal_vert,
            fragmentShader: tn.normal_frag
        },
        sprite: {
            uniforms: Ft([Jt.sprite, Jt.fog]),
            vertexShader: tn.sprite_vert,
            fragmentShader: tn.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new l
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: tn.background_vert,
            fragmentShader: tn.background_frag
        },
        cube: {
            uniforms: Ft([Jt.envmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: tn.cube_vert,
            fragmentShader: tn.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: tn.equirect_vert,
            fragmentShader: tn.equirect_frag
        },
        distanceRGBA: {
            uniforms: Ft([Jt.common, Jt.displacementmap, {
                referencePosition: {
                    value: new b
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: tn.distanceRGBA_vert,
            fragmentShader: tn.distanceRGBA_frag
        },
        shadow: {
            uniforms: Ft([Jt.lights, Jt.fog, {
                color: {
                    value: new ze(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: tn.shadow_vert,
            fragmentShader: tn.shadow_frag
        }
    };
    function rn(e, t, n, i) {
        var r, a, o = new ze(0), s = 0, c = null, h = 0, l = null;
        function u(e, n) {
            t.buffers.color.setClear(e.r, e.g, e.b, n, i)
        }
        return {
            getClearColor: function() {
                return o
            },
            setClearColor: function(e, t) {
                o.set(e),
                u(o, s = void 0 !== t ? t : 1)
            },
            getClearAlpha: function() {
                return s
            },
            setClearAlpha: function(e) {
                u(o, s = e)
            },
            render: function(t, i, p, d) {
                var f = i.background
                  , m = e.xr
                  , v = m.getSession && m.getSession();
                if (v && "additive" === v.environmentBlendMode && (f = null),
                null === f ? u(o, s) : f && f.isColor && (u(f, 1),
                d = !0),
                (e.autoClear || d) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                f && (f.isCubeTexture || f.isWebGLCubeRenderTarget || 306 === f.mapping)) {
                    void 0 === a && ((a = new Rt(new zt(1,1,1),new kt({
                        type: "BackgroundCubeMaterial",
                        uniforms: Bt(nn.cube.uniforms),
                        vertexShader: nn.cube.vertexShader,
                        fragmentShader: nn.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.deleteAttribute("normal"),
                    a.geometry.deleteAttribute("uv"),
                    a.onBeforeRender = function(e, t, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }
                    ,
                    Object.defineProperty(a.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }),
                    n.update(a));
                    var g = f.isWebGLCubeRenderTarget ? f.texture : f;
                    a.material.uniforms.envMap.value = g,
                    a.material.uniforms.flipEnvMap.value = g.isCubeTexture ? -1 : 1,
                    c === f && h === g.version && l === e.toneMapping || (a.material.needsUpdate = !0,
                    c = f,
                    h = g.version,
                    l = e.toneMapping),
                    t.unshift(a, a.geometry, a.material, 0, 0, null)
                } else
                    f && f.isTexture && (void 0 === r && ((r = new Rt(new en(2,2),new kt({
                        type: "BackgroundMaterial",
                        uniforms: Bt(nn.background.uniforms),
                        vertexShader: nn.background.vertexShader,
                        fragmentShader: nn.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.deleteAttribute("normal"),
                    Object.defineProperty(r.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    n.update(r)),
                    r.material.uniforms.t2D.value = f,
                    !0 === f.matrixAutoUpdate && f.updateMatrix(),
                    r.material.uniforms.uvTransform.value.copy(f.matrix),
                    c === f && h === f.version && l === e.toneMapping || (r.material.needsUpdate = !0,
                    c = f,
                    h = f.version,
                    l = e.toneMapping),
                    t.unshift(r, r.geometry, r.material, 0, 0, null))
            }
        }
    }
    function an(e, t, n, i) {
        var r, a = i.isWebGL2;
        this.setMode = function(e) {
            r = e
        }
        ,
        this.render = function(t, i) {
            e.drawArrays(r, t, i),
            n.update(i, r)
        }
        ,
        this.renderInstances = function(i, o, s, c) {
            if (0 !== c) {
                var h, l;
                if (a)
                    h = e,
                    l = "drawArraysInstanced";
                else if (l = "drawArraysInstancedANGLE",
                null === (h = t.get("ANGLE_instanced_arrays")))
                    return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                h[l](r, o, s, c),
                n.update(s, r, c)
            }
        }
    }
    function on(e, t, n) {
        var i;
        function r(t) {
            if ("highp" === t) {
                if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0)
                    return "highp";
                t = "mediump"
            }
            return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
        }
        var a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext
          , o = void 0 !== n.precision ? n.precision : "highp"
          , s = r(o);
        s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."),
        o = s);
        var c = !0 === n.logarithmicDepthBuffer
          , h = e.getParameter(34930)
          , l = e.getParameter(35660)
          , u = e.getParameter(3379)
          , p = e.getParameter(34076)
          , d = e.getParameter(34921)
          , f = e.getParameter(36347)
          , m = e.getParameter(36348)
          , v = e.getParameter(36349)
          , g = l > 0
          , y = a || !!t.get("OES_texture_float");
        return {
            isWebGL2: a,
            getMaxAnisotropy: function() {
                if (void 0 !== i)
                    return i;
                var n = t.get("EXT_texture_filter_anisotropic");
                return i = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: r,
            precision: o,
            logarithmicDepthBuffer: c,
            maxTextures: h,
            maxVertexTextures: l,
            maxTextureSize: u,
            maxCubemapSize: p,
            maxAttributes: d,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: v,
            vertexTextures: g,
            floatFragmentTextures: y,
            floatVertexTextures: g && y,
            maxSamples: a ? e.getParameter(36183) : 0
        }
    }
    function sn() {
        var e = this
          , t = null
          , n = 0
          , i = !1
          , r = !1
          , a = new we
          , o = new l
          , s = {
            value: null,
            needsUpdate: !1
        };
        function c() {
            s.value !== t && (s.value = t,
            s.needsUpdate = n > 0),
            e.numPlanes = n,
            e.numIntersection = 0
        }
        function h(t, n, i, r) {
            var c = null !== t ? t.length : 0
              , h = null;
            if (0 !== c) {
                if (h = s.value,
                !0 !== r || null === h) {
                    var l = i + 4 * c
                      , u = n.matrixWorldInverse;
                    o.getNormalMatrix(u),
                    (null === h || h.length < l) && (h = new Float32Array(l));
                    for (var p = 0, d = i; p !== c; ++p,
                    d += 4)
                        a.copy(t[p]).applyMatrix4(u, o),
                        a.normal.toArray(h, d),
                        h[d + 3] = a.constant
                }
                s.value = h,
                s.needsUpdate = !0
            }
            return e.numPlanes = c,
            e.numIntersection = 0,
            h
        }
        this.uniform = s,
        this.numPlanes = 0,
        this.numIntersection = 0,
        this.init = function(e, r, a) {
            var o = 0 !== e.length || r || 0 !== n || i;
            return i = r,
            t = h(e, a, 0),
            n = e.length,
            o
        }
        ,
        this.beginShadows = function() {
            r = !0,
            h(null)
        }
        ,
        this.endShadows = function() {
            r = !1,
            c()
        }
        ,
        this.setState = function(e, a, o, l, u, p) {
            if (!i || null === e || 0 === e.length || r && !o)
                r ? h(null) : c();
            else {
                var d = r ? 0 : n
                  , f = 4 * d
                  , m = u.clippingState || null;
                s.value = m,
                m = h(e, l, f, p);
                for (var v = 0; v !== f; ++v)
                    m[v] = t[v];
                u.clippingState = m,
                this.numIntersection = a ? this.numPlanes : 0,
                this.numPlanes += d
            }
        }
    }
    function cn(e) {
        var t = {};
        return {
            get: function(n) {
                if (void 0 !== t[n])
                    return t[n];
                var i;
                switch (n) {
                case "WEBGL_depth_texture":
                    i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = e.getExtension(n)
                }
                return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."),
                t[n] = i,
                i
            }
        }
    }
    function hn(e, t, n) {
        var i = new WeakMap
          , r = new WeakMap;
        function a(e) {
            var o = e.target
              , s = i.get(o);
            for (var c in null !== s.index && t.remove(s.index),
            s.attributes)
                t.remove(s.attributes[c]);
            o.removeEventListener("dispose", a),
            i.delete(o);
            var h = r.get(s);
            h && (t.remove(h),
            r.delete(s)),
            n.memory.geometries--
        }
        function o(e) {
            var n = []
              , i = e.index
              , a = e.attributes.position
              , o = 0;
            if (null !== i) {
                var s = i.array;
                o = i.version;
                for (var c = 0, h = s.length; c < h; c += 3) {
                    var l = s[c + 0]
                      , u = s[c + 1]
                      , p = s[c + 2];
                    n.push(l, u, u, p, p, l)
                }
            } else {
                s = a.array;
                o = a.version;
                for (c = 0,
                h = s.length / 3 - 1; c < h; c += 3) {
                    l = c + 0,
                    u = c + 1,
                    p = c + 2;
                    n.push(l, u, u, p, p, l)
                }
            }
            var d = new (it(n) > 65535 ? $e : Ke)(n,1);
            d.version = o,
            t.update(d, 34963);
            var f = r.get(e);
            f && t.remove(f),
            r.set(e, d)
        }
        return {
            get: function(e, t) {
                var r = i.get(t);
                return r || (t.addEventListener("dispose", a),
                t.isBufferGeometry ? r = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new ut).setFromObject(e)),
                r = t._bufferGeometry),
                i.set(t, r),
                n.memory.geometries++,
                r)
            },
            update: function(e) {
                var n = e.index
                  , i = e.attributes;
                for (var r in null !== n && t.update(n, 34963),
                i)
                    t.update(i[r], 34962);
                var a = e.morphAttributes;
                for (var r in a)
                    for (var o = a[r], s = 0, c = o.length; s < c; s++)
                        t.update(o[s], 34962)
            },
            getWireframeAttribute: function(e) {
                var t = r.get(e);
                if (t) {
                    var n = e.index;
                    null !== n && t.version < n.version && o(e)
                } else
                    o(e);
                return r.get(e)
            }
        }
    }
    function ln(e, t, n, i) {
        var r, a, o, s = i.isWebGL2;
        this.setMode = function(e) {
            r = e
        }
        ,
        this.setIndex = function(e) {
            a = e.type,
            o = e.bytesPerElement
        }
        ,
        this.render = function(t, i) {
            e.drawElements(r, i, a, t * o),
            n.update(i, r)
        }
        ,
        this.renderInstances = function(i, c, h, l) {
            if (0 !== l) {
                var u, p;
                if (s)
                    u = e,
                    p = "drawElementsInstanced";
                else if (p = "drawElementsInstancedANGLE",
                null === (u = t.get("ANGLE_instanced_arrays")))
                    return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                u[p](r, h, a, c * o, l),
                n.update(h, r, l)
            }
        }
    }
    function un(e) {
        var t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: t,
            programs: null,
            autoReset: !0,
            reset: function() {
                t.frame++,
                t.calls = 0,
                t.triangles = 0,
                t.points = 0,
                t.lines = 0
            },
            update: function(e, n, i) {
                switch (i = i || 1,
                t.calls++,
                n) {
                case 4:
                    t.triangles += i * (e / 3);
                    break;
                case 1:
                    t.lines += i * (e / 2);
                    break;
                case 3:
                    t.lines += i * (e - 1);
                    break;
                case 2:
                    t.lines += i * e;
                    break;
                case 0:
                    t.points += i * e;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                }
            }
        }
    }
    function pn(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }
    function dn(e) {
        var t = {}
          , n = new Float32Array(8);
        return {
            update: function(i, r, a, o) {
                var s = i.morphTargetInfluences
                  , c = void 0 === s ? 0 : s.length
                  , h = t[r.id];
                if (void 0 === h) {
                    h = [];
                    for (var l = 0; l < c; l++)
                        h[l] = [l, 0];
                    t[r.id] = h
                }
                var u = a.morphTargets && r.morphAttributes.position
                  , p = a.morphNormals && r.morphAttributes.normal;
                for (l = 0; l < c; l++) {
                    0 !== (f = h[l])[1] && (u && r.deleteAttribute("morphTarget" + l),
                    p && r.deleteAttribute("morphNormal" + l))
                }
                for (l = 0; l < c; l++) {
                    (f = h[l])[0] = l,
                    f[1] = s[l]
                }
                h.sort(pn);
                var d = 0;
                for (l = 0; l < 8; l++) {
                    var f;
                    if (f = h[l]) {
                        var m = f[0]
                          , v = f[1];
                        if (v) {
                            u && r.setAttribute("morphTarget" + l, u[m]),
                            p && r.setAttribute("morphNormal" + l, p[m]),
                            n[l] = v,
                            d += v;
                            continue
                        }
                    }
                    n[l] = 0
                }
                var g = r.morphTargetsRelative ? 1 : 1 - d;
                o.getUniforms().setValue(e, "morphTargetBaseInfluence", g),
                o.getUniforms().setValue(e, "morphTargetInfluences", n)
            }
        }
    }
    function fn(e, t, n, i) {
        var r = new WeakMap;
        return {
            update: function(e) {
                var a = i.render.frame
                  , o = e.geometry
                  , s = t.get(e, o);
                return r.get(s) !== a && (o.isGeometry && s.updateFromObject(e),
                t.update(s),
                r.set(s, a)),
                e.isInstancedMesh && n.update(e.instanceMatrix, 34962),
                s
            },
            dispose: function() {
                r = new WeakMap
            }
        }
    }
    function mn(e, t, n, i, r, a, o, s, c, h) {
        e = void 0 !== e ? e : [],
        t = void 0 !== t ? t : 301,
        o = void 0 !== o ? o : 1022,
        d.call(this, e, t, n, i, r, a, o, s, c, h),
        this.flipY = !1
    }
    function vn(e, t, n, i) {
        d.call(this, null),
        this.image = {
            data: e || null,
            width: t || 1,
            height: n || 1,
            depth: i || 1
        },
        this.magFilter = 1003,
        this.minFilter = 1003,
        this.wrapR = 1001,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.needsUpdate = !0
    }
    function gn(e, t, n, i) {
        d.call(this, null),
        this.image = {
            data: e || null,
            width: t || 1,
            height: n || 1,
            depth: i || 1
        },
        this.magFilter = 1003,
        this.minFilter = 1003,
        this.wrapR = 1001,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.needsUpdate = !0
    }
    nn.physical = {
        uniforms: Ft([nn.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new h(1,1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new ze(0)
            },
            transparency: {
                value: 0
            }
        }]),
        vertexShader: tn.meshphysical_vert,
        fragmentShader: tn.meshphysical_frag
    },
    mn.prototype = Object.create(d.prototype),
    mn.prototype.constructor = mn,
    mn.prototype.isCubeTexture = !0,
    Object.defineProperty(mn.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(e) {
            this.image = e
        }
    }),
    vn.prototype = Object.create(d.prototype),
    vn.prototype.constructor = vn,
    vn.prototype.isDataTexture2DArray = !0,
    gn.prototype = Object.create(d.prototype),
    gn.prototype.constructor = gn,
    gn.prototype.isDataTexture3D = !0;
    var yn = new d
      , xn = new vn
      , bn = new gn
      , _n = new mn
      , wn = []
      , Mn = []
      , Sn = new Float32Array(16)
      , Tn = new Float32Array(9)
      , En = new Float32Array(4);
    function An(e, t, n) {
        var i = e[0];
        if (i <= 0 || i > 0)
            return e;
        var r = t * n
          , a = wn[r];
        if (void 0 === a && (a = new Float32Array(r),
        wn[r] = a),
        0 !== t) {
            i.toArray(a, 0);
            for (var o = 1, s = 0; o !== t; ++o)
                s += n,
                e[o].toArray(a, s)
        }
        return a
    }
    function Ln(e, t) {
        if (e.length !== t.length)
            return !1;
        for (var n = 0, i = e.length; n < i; n++)
            if (e[n] !== t[n])
                return !1;
        return !0
    }
    function Rn(e, t) {
        for (var n = 0, i = t.length; n < i; n++)
            e[n] = t[n]
    }
    function Pn(e, t) {
        var n = Mn[t];
        void 0 === n && (n = new Int32Array(t),
        Mn[t] = n);
        for (var i = 0; i !== t; ++i)
            n[i] = e.allocateTextureUnit();
        return n
    }
    function Cn(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t),
        n[0] = t)
    }
    function On(e, t) {
        var n = this.cache;
        if (void 0 !== t.x)
            n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
            n[0] = t.x,
            n[1] = t.y);
        else {
            if (Ln(n, t))
                return;
            e.uniform2fv(this.addr, t),
            Rn(n, t)
        }
    }
    function In(e, t) {
        var n = this.cache;
        if (void 0 !== t.x)
            n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
            n[0] = t.x,
            n[1] = t.y,
            n[2] = t.z);
        else if (void 0 !== t.r)
            n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
            n[0] = t.r,
            n[1] = t.g,
            n[2] = t.b);
        else {
            if (Ln(n, t))
                return;
            e.uniform3fv(this.addr, t),
            Rn(n, t)
        }
    }
    function Dn(e, t) {
        var n = this.cache;
        if (void 0 !== t.x)
            n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            n[0] = t.x,
            n[1] = t.y,
            n[2] = t.z,
            n[3] = t.w);
        else {
            if (Ln(n, t))
                return;
            e.uniform4fv(this.addr, t),
            Rn(n, t)
        }
    }
    function Nn(e, t) {
        var n = this.cache
          , i = t.elements;
        if (void 0 === i) {
            if (Ln(n, t))
                return;
            e.uniformMatrix2fv(this.addr, !1, t),
            Rn(n, t)
        } else {
            if (Ln(n, i))
                return;
            En.set(i),
            e.uniformMatrix2fv(this.addr, !1, En),
            Rn(n, i)
        }
    }
    function Un(e, t) {
        var n = this.cache
          , i = t.elements;
        if (void 0 === i) {
            if (Ln(n, t))
                return;
            e.uniformMatrix3fv(this.addr, !1, t),
            Rn(n, t)
        } else {
            if (Ln(n, i))
                return;
            Tn.set(i),
            e.uniformMatrix3fv(this.addr, !1, Tn),
            Rn(n, i)
        }
    }
    function zn(e, t) {
        var n = this.cache
          , i = t.elements;
        if (void 0 === i) {
            if (Ln(n, t))
                return;
            e.uniformMatrix4fv(this.addr, !1, t),
            Rn(n, t)
        } else {
            if (Ln(n, i))
                return;
            Sn.set(i),
            e.uniformMatrix4fv(this.addr, !1, Sn),
            Rn(n, i)
        }
    }
    function Bn(e, t, n) {
        var i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r),
        i[0] = r),
        n.safeSetTexture2D(t || yn, r)
    }
    function Fn(e, t, n) {
        var i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r),
        i[0] = r),
        n.setTexture2DArray(t || xn, r)
    }
    function Hn(e, t, n) {
        var i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r),
        i[0] = r),
        n.setTexture3D(t || bn, r)
    }
    function kn(e, t, n) {
        var i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r),
        i[0] = r),
        n.safeSetTextureCube(t || _n, r)
    }
    function Gn(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t),
        n[0] = t)
    }
    function Vn(e, t) {
        var n = this.cache;
        Ln(n, t) || (e.uniform2iv(this.addr, t),
        Rn(n, t))
    }
    function jn(e, t) {
        var n = this.cache;
        Ln(n, t) || (e.uniform3iv(this.addr, t),
        Rn(n, t))
    }
    function Wn(e, t) {
        var n = this.cache;
        Ln(n, t) || (e.uniform4iv(this.addr, t),
        Rn(n, t))
    }
    function qn(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t),
        n[0] = t)
    }
    function Xn(e, t) {
        e.uniform1fv(this.addr, t)
    }
    function Yn(e, t) {
        e.uniform1iv(this.addr, t)
    }
    function Zn(e, t) {
        e.uniform2iv(this.addr, t)
    }
    function Jn(e, t) {
        e.uniform3iv(this.addr, t)
    }
    function Kn(e, t) {
        e.uniform4iv(this.addr, t)
    }
    function Qn(e, t) {
        var n = An(t, this.size, 2);
        e.uniform2fv(this.addr, n)
    }
    function $n(e, t) {
        var n = An(t, this.size, 3);
        e.uniform3fv(this.addr, n)
    }
    function ei(e, t) {
        var n = An(t, this.size, 4);
        e.uniform4fv(this.addr, n)
    }
    function ti(e, t) {
        var n = An(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n)
    }
    function ni(e, t) {
        var n = An(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n)
    }
    function ii(e, t) {
        var n = An(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n)
    }
    function ri(e, t, n) {
        var i = t.length
          , r = Pn(n, i);
        e.uniform1iv(this.addr, r);
        for (var a = 0; a !== i; ++a)
            n.safeSetTexture2D(t[a] || yn, r[a])
    }
    function ai(e, t, n) {
        var i = t.length
          , r = Pn(n, i);
        e.uniform1iv(this.addr, r);
        for (var a = 0; a !== i; ++a)
            n.safeSetTextureCube(t[a] || _n, r[a])
    }
    function oi(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return Cn;
            case 35664:
                return On;
            case 35665:
                return In;
            case 35666:
                return Dn;
            case 35674:
                return Nn;
            case 35675:
                return Un;
            case 35676:
                return zn;
            case 5124:
            case 35670:
                return Gn;
            case 35667:
            case 35671:
                return Vn;
            case 35668:
            case 35672:
                return jn;
            case 35669:
            case 35673:
                return Wn;
            case 5125:
                return qn;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Bn;
            case 35679:
            case 36299:
            case 36307:
                return Hn;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return kn;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return Fn
            }
        }(t.type)
    }
    function si(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.size = t.size,
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return Xn;
            case 35664:
                return Qn;
            case 35665:
                return $n;
            case 35666:
                return ei;
            case 35674:
                return ti;
            case 35675:
                return ni;
            case 35676:
                return ii;
            case 5124:
            case 35670:
                return Yn;
            case 35667:
            case 35671:
                return Zn;
            case 35668:
            case 35672:
                return Jn;
            case 35669:
            case 35673:
                return Kn;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return ri;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return ai
            }
        }(t.type)
    }
    function ci(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    si.prototype.updateCache = function(e) {
        var t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)),
        Rn(t, e)
    }
    ,
    ci.prototype.setValue = function(e, t, n) {
        for (var i = this.seq, r = 0, a = i.length; r !== a; ++r) {
            var o = i[r];
            o.setValue(e, t[o.id], n)
        }
    }
    ;
    var hi = /([\w\d_]+)(\])?(\[|\.)?/g;
    function li(e, t) {
        e.seq.push(t),
        e.map[t.id] = t
    }
    function ui(e, t, n) {
        var i = e.name
          , r = i.length;
        for (hi.lastIndex = 0; ; ) {
            var a = hi.exec(i)
              , o = hi.lastIndex
              , s = a[1]
              , c = "]" === a[2]
              , h = a[3];
            if (c && (s |= 0),
            void 0 === h || "[" === h && o + 2 === r) {
                li(n, void 0 === h ? new oi(s,e,t) : new si(s,e,t));
                break
            }
            var l = n.map[s];
            void 0 === l && li(n, l = new ci(s)),
            n = l
        }
    }
    function pi(e, t) {
        this.seq = [],
        this.map = {};
        for (var n = e.getProgramParameter(t, 35718), i = 0; i < n; ++i) {
            var r = e.getActiveUniform(t, i);
            ui(r, e.getUniformLocation(t, r.name), this)
        }
    }
    function di(e, t, n) {
        var i = e.createShader(t);
        return e.shaderSource(i, n),
        e.compileShader(i),
        i
    }
    pi.prototype.setValue = function(e, t, n, i) {
        var r = this.map[t];
        void 0 !== r && r.setValue(e, n, i)
    }
    ,
    pi.prototype.setOptional = function(e, t, n) {
        var i = t[n];
        void 0 !== i && this.setValue(e, n, i)
    }
    ,
    pi.upload = function(e, t, n, i) {
        for (var r = 0, a = t.length; r !== a; ++r) {
            var o = t[r]
              , s = n[o.id];
            !1 !== s.needsUpdate && o.setValue(e, s.value, i)
        }
    }
    ,
    pi.seqWithValue = function(e, t) {
        for (var n = [], i = 0, r = e.length; i !== r; ++i) {
            var a = e[i];
            a.id in t && n.push(a)
        }
        return n
    }
    ;
    var fi = 0;
    function mi(e) {
        switch (e) {
        case 3e3:
            return ["Linear", "( value )"];
        case 3001:
            return ["sRGB", "( value )"];
        case 3002:
            return ["RGBE", "( value )"];
        case 3004:
            return ["RGBM", "( value, 7.0 )"];
        case 3005:
            return ["RGBM", "( value, 16.0 )"];
        case 3006:
            return ["RGBD", "( value, 256.0 )"];
        case 3007:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case 3003:
            return ["LogLuv", "( value )"];
        default:
            throw new Error("unsupported encoding: " + e)
        }
    }
    function vi(e, t, n) {
        var i = e.getShaderParameter(t, 35713)
          , r = e.getShaderInfoLog(t).trim();
        return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function(e) {
            for (var t = e.split("\n"), n = 0; n < t.length; n++)
                t[n] = n + 1 + ": " + t[n];
            return t.join("\n")
        }(e.getShaderSource(t))
    }
    function gi(e, t) {
        var n = mi(t);
        return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }
    function yi(e, t) {
        var n;
        switch (t) {
        case 1:
            n = "Linear";
            break;
        case 2:
            n = "Reinhard";
            break;
        case 3:
            n = "Uncharted2";
            break;
        case 4:
            n = "OptimizedCineon";
            break;
        case 5:
            n = "ACESFilmic";
            break;
        default:
            throw new Error("unsupported toneMapping: " + t)
        }
        return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }
    function xi(e) {
        return "" !== e
    }
    function bi(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
    }
    function _i(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }
    var wi = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function Mi(e) {
        return e.replace(wi, Si)
    }
    function Si(e, t) {
        var n = tn[t];
        if (void 0 === n)
            throw new Error("Can not resolve #include <" + t + ">");
        return Mi(n)
    }
    var Ti = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
      , Ei = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
    function Ai(e) {
        return e.replace(Ei, Ri).replace(Ti, Li)
    }
    function Li(e, t, n, i) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
        Ri(e, t, n, i)
    }
    function Ri(e, t, n, i) {
        for (var r = "", a = parseInt(t); a < parseInt(n); a++)
            r += i.replace(/\[ i \]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
        return r
    }
    function Pi(e) {
        var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
        return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
        t
    }
    function Ci(e, t, n) {
        var i, r, a, o, s, c = e.getContext(), h = n.defines, l = n.vertexShader, u = n.fragmentShader, p = function(e) {
            var t = "SHADOWMAP_TYPE_BASIC";
            return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
            t
        }(n), d = function(e) {
            var t = "ENVMAP_TYPE_CUBE";
            if (e.envMap)
                switch (e.envMapMode) {
                case 301:
                case 302:
                    t = "ENVMAP_TYPE_CUBE";
                    break;
                case 306:
                case 307:
                    t = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case 303:
                case 304:
                    t = "ENVMAP_TYPE_EQUIREC";
                    break;
                case 305:
                    t = "ENVMAP_TYPE_SPHERE"
                }
            return t
        }(n), f = function(e) {
            var t = "ENVMAP_MODE_REFLECTION";
            if (e.envMap)
                switch (e.envMapMode) {
                case 302:
                case 304:
                    t = "ENVMAP_MODE_REFRACTION"
                }
            return t
        }(n), m = function(e) {
            var t = "ENVMAP_BLENDING_NONE";
            if (e.envMap)
                switch (e.combine) {
                case 0:
                    t = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    t = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    t = "ENVMAP_BLENDING_ADD"
                }
            return t
        }(n), v = e.gammaFactor > 0 ? e.gammaFactor : 1, g = n.isWebGL2 ? "" : function(e) {
            return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(xi).join("\n")
        }(n), y = function(e) {
            var t = [];
            for (var n in e) {
                var i = e[n];
                !1 !== i && t.push("#define " + n + " " + i)
            }
            return t.join("\n")
        }(h), x = c.createProgram();
        if (n.isRawShaderMaterial ? ((i = [y].filter(xi).join("\n")).length > 0 && (i += "\n"),
        (r = [g, y].filter(xi).join("\n")).length > 0 && (r += "\n")) : (i = [Pi(n), "#define SHADER_NAME " + n.shaderName, y, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + v, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(xi).join("\n"),
        r = [g, Pi(n), "#define SHADER_NAME " + n.shaderName, y, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + f : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? tn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? yi("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.outputEncoding || n.mapEncoding || n.matcapEncoding || n.envMapEncoding || n.emissiveMapEncoding || n.lightMapEncoding ? tn.encodings_pars_fragment : "", n.mapEncoding ? gi("mapTexelToLinear", n.mapEncoding) : "", n.matcapEncoding ? gi("matcapTexelToLinear", n.matcapEncoding) : "", n.envMapEncoding ? gi("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? gi("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMapEncoding ? gi("lightMapTexelToLinear", n.lightMapEncoding) : "", n.outputEncoding ? (a = "linearToOutputTexel",
        o = n.outputEncoding,
        s = mi(o),
        "vec4 " + a + "( vec4 value ) { return LinearTo" + s[0] + s[1] + "; }") : "", n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(xi).join("\n")),
        l = _i(l = bi(l = Mi(l), n), n),
        u = _i(u = bi(u = Mi(u), n), n),
        l = Ai(l),
        u = Ai(u),
        n.isWebGL2 && !n.isRawShaderMaterial) {
            var b = !1
              , _ = /^\s*#version\s+300\s+es\s*\n/;
            n.isShaderMaterial && null !== l.match(_) && null !== u.match(_) && (b = !0,
            l = l.replace(_, ""),
            u = u.replace(_, "")),
            i = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + i,
            r = ["#version 300 es\n", "#define varying in", b ? "" : "out highp vec4 pc_fragColor;", b ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + r
        }
        var w, M, S = r + u, T = di(c, 35633, i + l), E = di(c, 35632, S);
        if (c.attachShader(x, T),
        c.attachShader(x, E),
        void 0 !== n.index0AttributeName ? c.bindAttribLocation(x, 0, n.index0AttributeName) : !0 === n.morphTargets && c.bindAttribLocation(x, 0, "position"),
        c.linkProgram(x),
        e.debug.checkShaderErrors) {
            var A = c.getProgramInfoLog(x).trim()
              , L = c.getShaderInfoLog(T).trim()
              , R = c.getShaderInfoLog(E).trim()
              , P = !0
              , C = !0;
            if (!1 === c.getProgramParameter(x, 35714)) {
                P = !1;
                var O = vi(c, T, "vertex")
                  , I = vi(c, E, "fragment");
                console.error("THREE.WebGLProgram: shader error: ", c.getError(), "35715", c.getProgramParameter(x, 35715), "gl.getProgramInfoLog", A, O, I)
            } else
                "" !== A ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", A) : "" !== L && "" !== R || (C = !1);
            C && (this.diagnostics = {
                runnable: P,
                programLog: A,
                vertexShader: {
                    log: L,
                    prefix: i
                },
                fragmentShader: {
                    log: R,
                    prefix: r
                }
            })
        }
        return c.deleteShader(T),
        c.deleteShader(E),
        this.getUniforms = function() {
            return void 0 === w && (w = new pi(c,x)),
            w
        }
        ,
        this.getAttributes = function() {
            return void 0 === M && (M = function(e, t) {
                for (var n = {}, i = e.getProgramParameter(t, 35721), r = 0; r < i; r++) {
                    var a = e.getActiveAttrib(t, r).name;
                    n[a] = e.getAttribLocation(t, a)
                }
                return n
            }(c, x)),
            M
        }
        ,
        this.destroy = function() {
            c.deleteProgram(x),
            this.program = void 0
        }
        ,
        this.name = n.shaderName,
        this.id = fi++,
        this.cacheKey = t,
        this.usedTimes = 1,
        this.program = x,
        this.vertexShader = T,
        this.fragmentShader = E,
        this
    }
    function Oi(e, t, n) {
        var i = []
          , r = n.isWebGL2
          , a = n.logarithmicDepthBuffer
          , o = n.floatVertexTextures
          , s = n.precision
          , c = n.maxVertexUniforms
          , h = n.vertexTextures
          , l = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        }
          , u = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];
        function p(e) {
            var t;
            return e ? e.isTexture ? t = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
            t = e.texture.encoding) : t = 3e3,
            t
        }
        this.getParameters = function(i, u, d, f, m, v, g) {
            var y = f.fog
              , x = i.isMeshStandardMaterial ? f.environment : null
              , b = i.envMap || x
              , _ = l[i.type]
              , w = g.isSkinnedMesh ? function(e) {
                var t = e.skeleton.bones;
                if (o)
                    return 1024;
                var n = c
                  , i = Math.floor((n - 20) / 4)
                  , r = Math.min(i, t.length);
                return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."),
                0) : r
            }(g) : 0;
            null !== i.precision && (s = n.getMaxPrecision(i.precision)) !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", s, "instead.");
            var M = function(e, t) {
                var n;
                if (t) {
                    var i = nn[t];
                    n = {
                        name: e.type,
                        uniforms: Ht.clone(i.uniforms),
                        vertexShader: i.vertexShader,
                        fragmentShader: i.fragmentShader
                    }
                } else
                    n = {
                        name: e.type,
                        uniforms: e.uniforms,
                        vertexShader: e.vertexShader,
                        fragmentShader: e.fragmentShader
                    };
                return n
            }(i, _);
            i.onBeforeCompile(M, e);
            var S = e.getRenderTarget();
            return {
                isWebGL2: r,
                shaderID: _,
                shaderName: M.name,
                uniforms: M.uniforms,
                vertexShader: M.vertexShader,
                fragmentShader: M.fragmentShader,
                defines: i.defines,
                isRawShaderMaterial: i.isRawShaderMaterial,
                isShaderMaterial: i.isShaderMaterial,
                precision: s,
                instancing: !0 === g.isInstancedMesh,
                supportsVertexTextures: h,
                outputEncoding: null !== S ? p(S.texture) : e.outputEncoding,
                map: !!i.map,
                mapEncoding: p(i.map),
                matcap: !!i.matcap,
                matcapEncoding: p(i.matcap),
                envMap: !!b,
                envMapMode: b && b.mapping,
                envMapEncoding: p(b),
                envMapCubeUV: !!b && (306 === b.mapping || 307 === b.mapping),
                lightMap: !!i.lightMap,
                lightMapEncoding: p(i.lightMap),
                aoMap: !!i.aoMap,
                emissiveMap: !!i.emissiveMap,
                emissiveMapEncoding: p(i.emissiveMap),
                bumpMap: !!i.bumpMap,
                normalMap: !!i.normalMap,
                objectSpaceNormalMap: 1 === i.normalMapType,
                tangentSpaceNormalMap: 0 === i.normalMapType,
                clearcoatMap: !!i.clearcoatMap,
                clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
                clearcoatNormalMap: !!i.clearcoatNormalMap,
                displacementMap: !!i.displacementMap,
                roughnessMap: !!i.roughnessMap,
                metalnessMap: !!i.metalnessMap,
                specularMap: !!i.specularMap,
                alphaMap: !!i.alphaMap,
                gradientMap: !!i.gradientMap,
                sheen: !!i.sheen,
                combine: i.combine,
                vertexTangents: i.normalMap && i.vertexTangents,
                vertexColors: i.vertexColors,
                vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap),
                uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || !i.displacementMap),
                fog: !!y,
                useFog: i.fog,
                fogExp2: y && y.isFogExp2,
                flatShading: i.flatShading,
                sizeAttenuation: i.sizeAttenuation,
                logarithmicDepthBuffer: a,
                skinning: i.skinning && w > 0,
                maxBones: w,
                useVertexTexture: o,
                morphTargets: i.morphTargets,
                morphNormals: i.morphNormals,
                maxMorphTargets: e.maxMorphTargets,
                maxMorphNormals: e.maxMorphNormals,
                numDirLights: u.directional.length,
                numPointLights: u.point.length,
                numSpotLights: u.spot.length,
                numRectAreaLights: u.rectArea.length,
                numHemiLights: u.hemi.length,
                numDirLightShadows: u.directionalShadowMap.length,
                numPointLightShadows: u.pointShadowMap.length,
                numSpotLightShadows: u.spotShadowMap.length,
                numClippingPlanes: m,
                numClipIntersection: v,
                dithering: i.dithering,
                shadowMapEnabled: e.shadowMap.enabled && d.length > 0,
                shadowMapType: e.shadowMap.type,
                toneMapping: i.toneMapped ? e.toneMapping : 0,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: i.premultipliedAlpha,
                alphaTest: i.alphaTest,
                doubleSided: 2 === i.side,
                flipSided: 1 === i.side,
                depthPacking: void 0 !== i.depthPacking && i.depthPacking,
                index0AttributeName: i.index0AttributeName,
                extensionDerivatives: i.extensions && i.extensions.derivatives,
                extensionFragDepth: i.extensions && i.extensions.fragDepth,
                extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
                extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: r || null !== t.get("EXT_frag_depth"),
                rendererExtensionDrawBuffers: r || null !== t.get("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod: r || null !== t.get("EXT_shader_texture_lod"),
                onBeforeCompile: i.onBeforeCompile
            }
        }
        ,
        this.getProgramCacheKey = function(t) {
            var n = [];
            if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader),
            n.push(t.vertexShader)),
            void 0 !== t.defines)
                for (var i in t.defines)
                    n.push(i),
                    n.push(t.defines[i]);
            if (void 0 === t.isRawShaderMaterial) {
                for (var r = 0; r < u.length; r++)
                    n.push(t[u[r]]);
                n.push(e.outputEncoding),
                n.push(e.gammaFactor)
            }
            return n.push(t.onBeforeCompile.toString()),
            n.join()
        }
        ,
        this.acquireProgram = function(t, n) {
            for (var r, a = 0, o = i.length; a < o; a++) {
                var s = i[a];
                if (s.cacheKey === n) {
                    ++(r = s).usedTimes;
                    break
                }
            }
            return void 0 === r && (r = new Ci(e,n,t),
            i.push(r)),
            r
        }
        ,
        this.releaseProgram = function(e) {
            if (0 == --e.usedTimes) {
                var t = i.indexOf(e);
                i[t] = i[i.length - 1],
                i.pop(),
                e.destroy()
            }
        }
        ,
        this.programs = i
    }
    function Ii() {
        var e = new WeakMap;
        return {
            get: function(t) {
                var n = e.get(t);
                return void 0 === n && (n = {},
                e.set(t, n)),
                n
            },
            remove: function(t) {
                e.delete(t)
            },
            update: function(t, n, i) {
                e.get(t)[n] = i
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }
    function Di(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }
    function Ni(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }
    function Ui() {
        var e = []
          , t = 0
          , n = []
          , i = []
          , r = {
            id: -1
        };
        function a(n, i, a, o, s, c) {
            var h = e[t];
            return void 0 === h ? (h = {
                id: n.id,
                object: n,
                geometry: i,
                material: a,
                program: a.program || r,
                groupOrder: o,
                renderOrder: n.renderOrder,
                z: s,
                group: c
            },
            e[t] = h) : (h.id = n.id,
            h.object = n,
            h.geometry = i,
            h.material = a,
            h.program = a.program || r,
            h.groupOrder = o,
            h.renderOrder = n.renderOrder,
            h.z = s,
            h.group = c),
            t++,
            h
        }
        return {
            opaque: n,
            transparent: i,
            init: function() {
                t = 0,
                n.length = 0,
                i.length = 0
            },
            push: function(e, t, r, o, s, c) {
                var h = a(e, t, r, o, s, c);
                (!0 === r.transparent ? i : n).push(h)
            },
            unshift: function(e, t, r, o, s, c) {
                var h = a(e, t, r, o, s, c);
                (!0 === r.transparent ? i : n).unshift(h)
            },
            finish: function() {
                for (var n = t, i = e.length; n < i; n++) {
                    var r = e[n];
                    if (null === r.id)
                        break;
                    r.id = null,
                    r.object = null,
                    r.geometry = null,
                    r.material = null,
                    r.program = null,
                    r.group = null
                }
            },
            sort: function(e, t) {
                n.length > 1 && n.sort(e || Di),
                i.length > 1 && i.sort(t || Ni)
            }
        }
    }
    function zi() {
        var e = new WeakMap;
        function t(n) {
            var i = n.target;
            i.removeEventListener("dispose", t),
            e.delete(i)
        }
        return {
            get: function(n, i) {
                var r, a = e.get(n);
                return void 0 === a ? (r = new Ui,
                e.set(n, new WeakMap),
                e.get(n).set(i, r),
                n.addEventListener("dispose", t)) : void 0 === (r = a.get(i)) && (r = new Ui,
                a.set(i, r)),
                r
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }
    function Bi() {
        var e = {};
        return {
            get: function(t) {
                if (void 0 !== e[t.id])
                    return e[t.id];
                var n;
                switch (t.type) {
                case "DirectionalLight":
                    n = {
                        direction: new b,
                        color: new ze
                    };
                    break;
                case "SpotLight":
                    n = {
                        position: new b,
                        direction: new b,
                        color: new ze,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    n = {
                        position: new b,
                        color: new ze,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    n = {
                        direction: new b,
                        skyColor: new ze,
                        groundColor: new ze
                    };
                    break;
                case "RectAreaLight":
                    n = {
                        color: new ze,
                        position: new b,
                        halfWidth: new b,
                        halfHeight: new b
                    }
                }
                return e[t.id] = n,
                n
            }
        }
    }
    var Fi = 0;
    function Hi(e, t) {
        return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
    }
    function ki() {
        for (var e, t = new Bi, n = (e = {},
        {
            get: function(t) {
                if (void 0 !== e[t.id])
                    return e[t.id];
                var n;
                switch (t.type) {
                case "DirectionalLight":
                case "SpotLight":
                    n = {
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new h
                    };
                    break;
                case "PointLight":
                    n = {
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new h,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    }
                }
                return e[t.id] = n,
                n
            }
        }), i = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        }, r = 0; r < 9; r++)
            i.probe.push(new b);
        var a = new b
          , o = new L
          , s = new L;
        return {
            setup: function(e, r, c) {
                for (var h = 0, l = 0, u = 0, p = 0; p < 9; p++)
                    i.probe[p].set(0, 0, 0);
                var d = 0
                  , f = 0
                  , m = 0
                  , v = 0
                  , g = 0
                  , y = 0
                  , x = 0
                  , b = 0
                  , _ = c.matrixWorldInverse;
                e.sort(Hi),
                p = 0;
                for (var w = e.length; p < w; p++) {
                    var M = e[p]
                      , S = M.color
                      , T = M.intensity
                      , E = M.distance
                      , A = M.shadow && M.shadow.map ? M.shadow.map.texture : null;
                    if (M.isAmbientLight)
                        h += S.r * T,
                        l += S.g * T,
                        u += S.b * T;
                    else if (M.isLightProbe)
                        for (var L = 0; L < 9; L++)
                            i.probe[L].addScaledVector(M.sh.coefficients[L], T);
                    else if (M.isDirectionalLight) {
                        if ((C = t.get(M)).color.copy(M.color).multiplyScalar(M.intensity),
                        C.direction.setFromMatrixPosition(M.matrixWorld),
                        a.setFromMatrixPosition(M.target.matrixWorld),
                        C.direction.sub(a),
                        C.direction.transformDirection(_),
                        M.castShadow) {
                            var R = M.shadow;
                            (P = n.get(M)).shadowBias = R.bias,
                            P.shadowRadius = R.radius,
                            P.shadowMapSize = R.mapSize,
                            i.directionalShadow[d] = P,
                            i.directionalShadowMap[d] = A,
                            i.directionalShadowMatrix[d] = M.shadow.matrix,
                            y++
                        }
                        i.directional[d] = C,
                        d++
                    } else if (M.isSpotLight) {
                        if ((C = t.get(M)).position.setFromMatrixPosition(M.matrixWorld),
                        C.position.applyMatrix4(_),
                        C.color.copy(S).multiplyScalar(T),
                        C.distance = E,
                        C.direction.setFromMatrixPosition(M.matrixWorld),
                        a.setFromMatrixPosition(M.target.matrixWorld),
                        C.direction.sub(a),
                        C.direction.transformDirection(_),
                        C.coneCos = Math.cos(M.angle),
                        C.penumbraCos = Math.cos(M.angle * (1 - M.penumbra)),
                        C.decay = M.decay,
                        M.castShadow) {
                            R = M.shadow;
                            (P = n.get(M)).shadowBias = R.bias,
                            P.shadowRadius = R.radius,
                            P.shadowMapSize = R.mapSize,
                            i.spotShadow[m] = P,
                            i.spotShadowMap[m] = A,
                            i.spotShadowMatrix[m] = M.shadow.matrix,
                            b++
                        }
                        i.spot[m] = C,
                        m++
                    } else if (M.isRectAreaLight) {
                        (C = t.get(M)).color.copy(S).multiplyScalar(T),
                        C.position.setFromMatrixPosition(M.matrixWorld),
                        C.position.applyMatrix4(_),
                        s.identity(),
                        o.copy(M.matrixWorld),
                        o.premultiply(_),
                        s.extractRotation(o),
                        C.halfWidth.set(.5 * M.width, 0, 0),
                        C.halfHeight.set(0, .5 * M.height, 0),
                        C.halfWidth.applyMatrix4(s),
                        C.halfHeight.applyMatrix4(s),
                        i.rectArea[v] = C,
                        v++
                    } else if (M.isPointLight) {
                        if ((C = t.get(M)).position.setFromMatrixPosition(M.matrixWorld),
                        C.position.applyMatrix4(_),
                        C.color.copy(M.color).multiplyScalar(M.intensity),
                        C.distance = M.distance,
                        C.decay = M.decay,
                        M.castShadow) {
                            var P;
                            R = M.shadow;
                            (P = n.get(M)).shadowBias = R.bias,
                            P.shadowRadius = R.radius,
                            P.shadowMapSize = R.mapSize,
                            P.shadowCameraNear = R.camera.near,
                            P.shadowCameraFar = R.camera.far,
                            i.pointShadow[f] = P,
                            i.pointShadowMap[f] = A,
                            i.pointShadowMatrix[f] = M.shadow.matrix,
                            x++
                        }
                        i.point[f] = C,
                        f++
                    } else if (M.isHemisphereLight) {
                        var C;
                        (C = t.get(M)).direction.setFromMatrixPosition(M.matrixWorld),
                        C.direction.transformDirection(_),
                        C.direction.normalize(),
                        C.skyColor.copy(M.color).multiplyScalar(T),
                        C.groundColor.copy(M.groundColor).multiplyScalar(T),
                        i.hemi[g] = C,
                        g++
                    }
                }
                i.ambient[0] = h,
                i.ambient[1] = l,
                i.ambient[2] = u;
                var O = i.hash;
                O.directionalLength === d && O.pointLength === f && O.spotLength === m && O.rectAreaLength === v && O.hemiLength === g && O.numDirectionalShadows === y && O.numPointShadows === x && O.numSpotShadows === b || (i.directional.length = d,
                i.spot.length = m,
                i.rectArea.length = v,
                i.point.length = f,
                i.hemi.length = g,
                i.directionalShadow.length = y,
                i.directionalShadowMap.length = y,
                i.pointShadow.length = x,
                i.pointShadowMap.length = x,
                i.spotShadow.length = b,
                i.spotShadowMap.length = b,
                i.directionalShadowMatrix.length = y,
                i.pointShadowMatrix.length = x,
                i.spotShadowMatrix.length = b,
                O.directionalLength = d,
                O.pointLength = f,
                O.spotLength = m,
                O.rectAreaLength = v,
                O.hemiLength = g,
                O.numDirectionalShadows = y,
                O.numPointShadows = x,
                O.numSpotShadows = b,
                i.version = Fi++)
            },
            state: i
        }
    }
    function Gi() {
        var e = new ki
          , t = []
          , n = [];
        return {
            init: function() {
                t.length = 0,
                n.length = 0
            },
            state: {
                lightsArray: t,
                shadowsArray: n,
                lights: e
            },
            setupLights: function(i) {
                e.setup(t, n, i)
            },
            pushLight: function(e) {
                t.push(e)
            },
            pushShadow: function(e) {
                n.push(e)
            }
        }
    }
    function Vi() {
        var e = new WeakMap;
        function t(n) {
            var i = n.target;
            i.removeEventListener("dispose", t),
            e.delete(i)
        }
        return {
            get: function(n, i) {
                var r;
                return !1 === e.has(n) ? (r = new Gi,
                e.set(n, new WeakMap),
                e.get(n).set(i, r),
                n.addEventListener("dispose", t)) : !1 === e.get(n).has(i) ? (r = new Gi,
                e.get(n).set(i, r)) : r = e.get(n).get(i),
                r
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }
    function ji(e) {
        Ve.call(this),
        this.type = "MeshDepthMaterial",
        this.depthPacking = 3200,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.setValues(e)
    }
    function Wi(e) {
        Ve.call(this),
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new b,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.fog = !1,
        this.setValues(e)
    }
    ji.prototype = Object.create(Ve.prototype),
    ji.prototype.constructor = ji,
    ji.prototype.isMeshDepthMaterial = !0,
    ji.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.depthPacking = e.depthPacking,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
    ,
    Wi.prototype = Object.create(Ve.prototype),
    Wi.prototype.constructor = Wi,
    Wi.prototype.isMeshDistanceMaterial = !0,
    Wi.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
    ;
    function qi(e, t, n) {
        var i = new Zt
          , r = new h
          , a = new h
          , o = new f
          , s = []
          , c = []
          , l = {}
          , u = {
            0: 1,
            1: 0,
            2: 2
        }
          , p = new kt({
            defines: {
                SAMPLE_RATE: 2 / 8,
                HALF_SAMPLE_RATE: 1 / 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new h
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
        })
          , d = p.clone();
        d.defines.HORIZONAL_PASS = 1;
        var v = new ut;
        v.setAttribute("position", new qe(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
        var g = new Rt(v,p)
          , y = this;
        function x(n, i) {
            var r = t.update(g);
            p.uniforms.shadow_pass.value = n.map.texture,
            p.uniforms.resolution.value = n.mapSize,
            p.uniforms.radius.value = n.radius,
            e.setRenderTarget(n.mapPass),
            e.clear(),
            e.renderBufferDirect(i, null, r, p, g, null),
            d.uniforms.shadow_pass.value = n.mapPass.texture,
            d.uniforms.resolution.value = n.mapSize,
            d.uniforms.radius.value = n.radius,
            e.setRenderTarget(n.map),
            e.clear(),
            e.renderBufferDirect(i, null, r, d, g, null)
        }
        function b(e, t, n) {
            var i = e << 0 | t << 1 | n << 2
              , r = s[i];
            return void 0 === r && (r = new ji({
                depthPacking: 3201,
                morphTargets: e,
                skinning: t
            }),
            s[i] = r),
            r
        }
        function _(e, t, n) {
            var i = e << 0 | t << 1 | n << 2
              , r = c[i];
            return void 0 === r && (r = new Wi({
                morphTargets: e,
                skinning: t
            }),
            c[i] = r),
            r
        }
        function w(t, n, i, r, a, o, s) {
            var c = null
              , h = b
              , p = t.customDepthMaterial;
            if (!0 === r.isPointLight && (h = _,
            p = t.customDistanceMaterial),
            void 0 === p) {
                var d = !1;
                !0 === i.morphTargets && (d = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                var f = !1;
                !0 === t.isSkinnedMesh && (!0 === i.skinning ? f = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t)),
                c = h(d, f, !0 === t.isInstancedMesh)
            } else
                c = p;
            if (e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                var m = c.uuid
                  , v = i.uuid
                  , g = l[m];
                void 0 === g && (g = {},
                l[m] = g);
                var y = g[v];
                void 0 === y && (y = c.clone(),
                g[v] = y),
                c = y
            }
            return c.visible = i.visible,
            c.wireframe = i.wireframe,
            c.side = 3 === s ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side],
            c.clipShadows = i.clipShadows,
            c.clippingPlanes = i.clippingPlanes,
            c.clipIntersection = i.clipIntersection,
            c.wireframeLinewidth = i.wireframeLinewidth,
            c.linewidth = i.linewidth,
            !0 === r.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(r.matrixWorld),
            c.nearDistance = a,
            c.farDistance = o),
            c
        }
        function M(n, r, a, o, s) {
            if (!1 !== n.visible) {
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === s) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                    var c = t.update(n)
                      , h = n.material;
                    if (Array.isArray(h))
                        for (var l = c.groups, u = 0, p = l.length; u < p; u++) {
                            var d = l[u]
                              , f = h[d.materialIndex];
                            if (f && f.visible) {
                                var m = w(n, c, f, o, a.near, a.far, s);
                                e.renderBufferDirect(a, null, c, m, n, d)
                            }
                        }
                    else if (h.visible) {
                        m = w(n, c, h, o, a.near, a.far, s);
                        e.renderBufferDirect(a, null, c, m, n, null)
                    }
                }
                for (var v = n.children, g = 0, y = v.length; g < y; g++)
                    M(v[g], r, a, o, s)
            }
        }
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = 1,
        this.render = function(t, s, c) {
            if (!1 !== y.enabled && (!1 !== y.autoUpdate || !1 !== y.needsUpdate) && 0 !== t.length) {
                var h = e.getRenderTarget()
                  , l = e.getActiveCubeFace()
                  , u = e.getActiveMipmapLevel()
                  , p = e.state;
                p.setBlending(0),
                p.buffers.color.setClear(1, 1, 1, 1),
                p.buffers.depth.setTest(!0),
                p.setScissorTest(!1);
                for (var d = 0, f = t.length; d < f; d++) {
                    var v = t[d]
                      , g = v.shadow;
                    if (void 0 !== g) {
                        r.copy(g.mapSize);
                        var b = g.getFrameExtents();
                        if (r.multiply(b),
                        a.copy(g.mapSize),
                        (r.x > n || r.y > n) && (r.x > n && (a.x = Math.floor(n / b.x),
                        r.x = a.x * b.x,
                        g.mapSize.x = a.x),
                        r.y > n && (a.y = Math.floor(n / b.y),
                        r.y = a.y * b.y,
                        g.mapSize.y = a.y)),
                        null === g.map && !g.isPointLightShadow && 3 === this.type) {
                            var _ = {
                                minFilter: 1006,
                                magFilter: 1006,
                                format: 1023
                            };
                            g.map = new m(r.x,r.y,_),
                            g.map.texture.name = v.name + ".shadowMap",
                            g.mapPass = new m(r.x,r.y,_),
                            g.camera.updateProjectionMatrix()
                        }
                        if (null === g.map) {
                            _ = {
                                minFilter: 1003,
                                magFilter: 1003,
                                format: 1023
                            };
                            g.map = new m(r.x,r.y,_),
                            g.map.texture.name = v.name + ".shadowMap",
                            g.camera.updateProjectionMatrix()
                        }
                        e.setRenderTarget(g.map),
                        e.clear();
                        for (var w = g.getViewportCount(), S = 0; S < w; S++) {
                            var T = g.getViewport(S);
                            o.set(a.x * T.x, a.y * T.y, a.x * T.z, a.y * T.w),
                            p.viewport(o),
                            g.updateMatrices(v, S),
                            i = g.getFrustum(),
                            M(s, c, g.camera, v, this.type)
                        }
                        g.isPointLightShadow || 3 !== this.type || x(g, c)
                    } else
                        console.warn("THREE.WebGLShadowMap:", v, "has no shadow.")
                }
                y.needsUpdate = !1,
                e.setRenderTarget(h, l, u)
            }
        }
    }
    function Xi(e, t, n) {
        var i = n.isWebGL2;
        var r = new function() {
            var t = !1
              , n = new f
              , i = null
              , r = new f(0,0,0,0);
            return {
                setMask: function(n) {
                    i === n || t || (e.colorMask(n, n, n, n),
                    i = n)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t, i, a, o, s) {
                    !0 === s && (t *= o,
                    i *= o,
                    a *= o),
                    n.set(t, i, a, o),
                    !1 === r.equals(n) && (e.clearColor(t, i, a, o),
                    r.copy(n))
                },
                reset: function() {
                    t = !1,
                    i = null,
                    r.set(-1, 0, 0, 0)
                }
            }
        }
          , a = new function() {
            var t = !1
              , n = null
              , i = null
              , r = null;
            return {
                setTest: function(e) {
                    e ? F(2929) : H(2929)
                },
                setMask: function(i) {
                    n === i || t || (e.depthMask(i),
                    n = i)
                },
                setFunc: function(t) {
                    if (i !== t) {
                        if (t)
                            switch (t) {
                            case 0:
                                e.depthFunc(512);
                                break;
                            case 1:
                                e.depthFunc(519);
                                break;
                            case 2:
                                e.depthFunc(513);
                                break;
                            case 3:
                                e.depthFunc(515);
                                break;
                            case 4:
                                e.depthFunc(514);
                                break;
                            case 5:
                                e.depthFunc(518);
                                break;
                            case 6:
                                e.depthFunc(516);
                                break;
                            case 7:
                                e.depthFunc(517);
                                break;
                            default:
                                e.depthFunc(515)
                            }
                        else
                            e.depthFunc(515);
                        i = t
                    }
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t) {
                    r !== t && (e.clearDepth(t),
                    r = t)
                },
                reset: function() {
                    t = !1,
                    n = null,
                    i = null,
                    r = null
                }
            }
        }
          , o = new function() {
            var t = !1
              , n = null
              , i = null
              , r = null
              , a = null
              , o = null
              , s = null
              , c = null
              , h = null;
            return {
                setTest: function(e) {
                    t || (e ? F(2960) : H(2960))
                },
                setMask: function(i) {
                    n === i || t || (e.stencilMask(i),
                    n = i)
                },
                setFunc: function(t, n, o) {
                    i === t && r === n && a === o || (e.stencilFunc(t, n, o),
                    i = t,
                    r = n,
                    a = o)
                },
                setOp: function(t, n, i) {
                    o === t && s === n && c === i || (e.stencilOp(t, n, i),
                    o = t,
                    s = n,
                    c = i)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t) {
                    h !== t && (e.clearStencil(t),
                    h = t)
                },
                reset: function() {
                    t = !1,
                    n = null,
                    i = null,
                    r = null,
                    a = null,
                    o = null,
                    s = null,
                    c = null,
                    h = null
                }
            }
        }
          , s = e.getParameter(34921)
          , c = new Uint8Array(s)
          , h = new Uint8Array(s)
          , l = new Uint8Array(s)
          , u = {}
          , p = null
          , d = null
          , m = null
          , v = null
          , g = null
          , y = null
          , x = null
          , b = null
          , _ = null
          , w = !1
          , M = null
          , S = null
          , T = null
          , E = null
          , A = null
          , L = e.getParameter(35661)
          , R = !1
          , P = 0
          , C = e.getParameter(7938);
        -1 !== C.indexOf("WebGL") ? (P = parseFloat(/^WebGL\ ([0-9])/.exec(C)[1]),
        R = P >= 1) : -1 !== C.indexOf("OpenGL ES") && (P = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(C)[1]),
        R = P >= 2);
        var O = null
          , I = {}
          , D = new f
          , N = new f;
        function U(t, n, i) {
            var r = new Uint8Array(4)
              , a = e.createTexture();
            e.bindTexture(t, a),
            e.texParameteri(t, 10241, 9728),
            e.texParameteri(t, 10240, 9728);
            for (var o = 0; o < i; o++)
                e.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return a
        }
        var z = {};
        function B(n, r) {
            (c[n] = 1,
            0 === h[n] && (e.enableVertexAttribArray(n),
            h[n] = 1),
            l[n] !== r) && ((i ? e : t.get("ANGLE_instanced_arrays"))[i ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r),
            l[n] = r)
        }
        function F(t) {
            !0 !== u[t] && (e.enable(t),
            u[t] = !0)
        }
        function H(t) {
            !1 !== u[t] && (e.disable(t),
            u[t] = !1)
        }
        z[3553] = U(3553, 3553, 1),
        z[34067] = U(34067, 34069, 6),
        r.setClear(0, 0, 0, 1),
        a.setClear(1),
        o.setClear(0),
        F(2929),
        a.setFunc(3),
        W(!1),
        q(1),
        F(2884),
        j(0);
        var k = {
            100: 32774,
            101: 32778,
            102: 32779
        };
        if (i)
            k[103] = 32775,
            k[104] = 32776;
        else {
            var G = t.get("EXT_blend_minmax");
            null !== G && (k[103] = G.MIN_EXT,
            k[104] = G.MAX_EXT)
        }
        var V = {
            200: 0,
            201: 1,
            202: 768,
            204: 770,
            210: 776,
            208: 774,
            206: 772,
            203: 769,
            205: 771,
            209: 775,
            207: 773
        };
        function j(t, n, i, r, a, o, s, c) {
            if (0 !== t) {
                if (d || (F(3042),
                d = !0),
                5 === t)
                    a = a || n,
                    o = o || i,
                    s = s || r,
                    n === v && a === x || (e.blendEquationSeparate(k[n], k[a]),
                    v = n,
                    x = a),
                    i === g && r === y && o === b && s === _ || (e.blendFuncSeparate(V[i], V[r], V[o], V[s]),
                    g = i,
                    y = r,
                    b = o,
                    _ = s),
                    m = t,
                    w = null;
                else if (t !== m || c !== w) {
                    if (100 === v && 100 === x || (e.blendEquation(32774),
                    v = 100,
                    x = 100),
                    c)
                        switch (t) {
                        case 1:
                            e.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            e.blendFunc(1, 1);
                            break;
                        case 3:
                            e.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            e.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                        }
                    else
                        switch (t) {
                        case 1:
                            e.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            e.blendFunc(770, 1);
                            break;
                        case 3:
                            e.blendFunc(0, 769);
                            break;
                        case 4:
                            e.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                        }
                    g = null,
                    y = null,
                    b = null,
                    _ = null,
                    m = t,
                    w = c
                }
            } else
                d && (H(3042),
                d = !1)
        }
        function W(t) {
            M !== t && (t ? e.frontFace(2304) : e.frontFace(2305),
            M = t)
        }
        function q(t) {
            0 !== t ? (F(2884),
            t !== S && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : H(2884),
            S = t
        }
        function X(t, n, i) {
            t ? (F(32823),
            E === n && A === i || (e.polygonOffset(n, i),
            E = n,
            A = i)) : H(32823)
        }
        function Y(t) {
            void 0 === t && (t = 33984 + L - 1),
            O !== t && (e.activeTexture(t),
            O = t)
        }
        return {
            buffers: {
                color: r,
                depth: a,
                stencil: o
            },
            initAttributes: function() {
                for (var e = 0, t = c.length; e < t; e++)
                    c[e] = 0
            },
            enableAttribute: function(e) {
                B(e, 0)
            },
            enableAttributeAndDivisor: B,
            disableUnusedAttributes: function() {
                for (var t = 0, n = h.length; t !== n; ++t)
                    h[t] !== c[t] && (e.disableVertexAttribArray(t),
                    h[t] = 0)
            },
            vertexAttribPointer: function(t, n, r, a, o, s) {
                !0 !== i || 5124 !== r && 5125 !== r ? e.vertexAttribPointer(t, n, r, a, o, s) : e.vertexAttribIPointer(t, n, r, a, o, s)
            },
            enable: F,
            disable: H,
            useProgram: function(t) {
                return p !== t && (e.useProgram(t),
                p = t,
                !0)
            },
            setBlending: j,
            setMaterial: function(e, t) {
                2 === e.side ? H(2884) : F(2884);
                var n = 1 === e.side;
                t && (n = !n),
                W(n),
                1 === e.blending && !1 === e.transparent ? j(0) : j(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
                a.setFunc(e.depthFunc),
                a.setTest(e.depthTest),
                a.setMask(e.depthWrite),
                r.setMask(e.colorWrite);
                var i = e.stencilWrite;
                o.setTest(i),
                i && (o.setMask(e.stencilWriteMask),
                o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
                X(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            },
            setFlipSided: W,
            setCullFace: q,
            setLineWidth: function(t) {
                t !== T && (R && e.lineWidth(t),
                T = t)
            },
            setPolygonOffset: X,
            setScissorTest: function(e) {
                e ? F(3089) : H(3089)
            },
            activeTexture: Y,
            bindTexture: function(t, n) {
                null === O && Y();
                var i = I[O];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                },
                I[O] = i),
                i.type === t && i.texture === n || (e.bindTexture(t, n || z[t]),
                i.type = t,
                i.texture = n)
            },
            unbindTexture: function() {
                var t = I[O];
                void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
                t.type = void 0,
                t.texture = void 0)
            },
            compressedTexImage2D: function() {
                try {
                    e.compressedTexImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage2D: function() {
                try {
                    e.texImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage3D: function() {
                try {
                    e.texImage3D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            scissor: function(t) {
                !1 === D.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                D.copy(t))
            },
            viewport: function(t) {
                !1 === N.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                N.copy(t))
            },
            reset: function() {
                for (var t = 0; t < h.length; t++)
                    1 === h[t] && (e.disableVertexAttribArray(t),
                    h[t] = 0);
                u = {},
                O = null,
                I = {},
                p = null,
                m = null,
                M = null,
                S = null,
                r.reset(),
                a.reset(),
                o.reset()
            }
        }
    }
    function Yi(e, t, n, i, r, a, o) {
        var s, h = r.isWebGL2, l = r.maxTextures, u = r.maxCubemapSize, p = r.maxTextureSize, d = r.maxSamples, f = new WeakMap, m = !1;
        try {
            m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
        } catch (e) {}
        function v(e, t) {
            return m ? new OffscreenCanvas(e,t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }
        function g(e, t, n, i) {
            var r = 1;
            if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)),
            r < 1 || !0 === t) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    var a = t ? c.floorPowerOfTwo : Math.floor
                      , o = a(r * e.width)
                      , h = a(r * e.height);
                    void 0 === s && (s = v(o, h));
                    var l = n ? v(o, h) : s;
                    return l.width = o,
                    l.height = h,
                    l.getContext("2d").drawImage(e, 0, 0, o, h),
                    console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + o + "x" + h + ")."),
                    l
                }
                return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."),
                e
            }
            return e
        }
        function y(e) {
            return c.isPowerOfTwo(e.width) && c.isPowerOfTwo(e.height)
        }
        function x(e, t) {
            return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter
        }
        function b(t, n, r, a) {
            e.generateMipmap(t),
            i.get(n).__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E
        }
        function _(n, i, r) {
            if (!1 === h)
                return i;
            if (null !== n) {
                if (void 0 !== e[n])
                    return e[n];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
            }
            var a = i;
            return 6403 === i && (5126 === r && (a = 33326),
            5131 === r && (a = 33325),
            5121 === r && (a = 33321)),
            6407 === i && (5126 === r && (a = 34837),
            5131 === r && (a = 34843),
            5121 === r && (a = 32849)),
            6408 === i && (5126 === r && (a = 34836),
            5131 === r && (a = 34842),
            5121 === r && (a = 32856)),
            33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a || t.get("EXT_color_buffer_float"),
            a
        }
        function w(e) {
            return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729
        }
        function M(t) {
            var n = t.target;
            n.removeEventListener("dispose", M),
            function(t) {
                var n = i.get(t);
                if (void 0 === n.__webglInit)
                    return;
                e.deleteTexture(n.__webglTexture),
                i.remove(t)
            }(n),
            n.isVideoTexture && f.delete(n),
            o.memory.textures--
        }
        function S(t) {
            var n = t.target;
            n.removeEventListener("dispose", S),
            function(t) {
                var n = i.get(t)
                  , r = i.get(t.texture);
                if (!t)
                    return;
                void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture);
                t.depthTexture && t.depthTexture.dispose();
                if (t.isWebGLCubeRenderTarget)
                    for (var a = 0; a < 6; a++)
                        e.deleteFramebuffer(n.__webglFramebuffer[a]),
                        n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[a]);
                else
                    e.deleteFramebuffer(n.__webglFramebuffer),
                    n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer),
                    n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                    n.__webglColorRenderbuffer && e.deleteRenderbuffer(n.__webglColorRenderbuffer),
                    n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                i.remove(t.texture),
                i.remove(t)
            }(n),
            o.memory.textures--
        }
        var T = 0;
        function E(e, t) {
            var r = i.get(e);
            if (e.isVideoTexture && function(e) {
                var t = o.render.frame;
                f.get(e) !== t && (f.set(e, t),
                e.update())
            }(e),
            e.version > 0 && r.__version !== e.version) {
                var a = e.image;
                if (void 0 === a)
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== a.complete)
                        return void I(r, e, t);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            n.activeTexture(33984 + t),
            n.bindTexture(3553, r.__webglTexture)
        }
        function A(t, r) {
            if (6 === t.image.length) {
                var o = i.get(t);
                if (t.version > 0 && o.__version !== t.version) {
                    O(o, t),
                    n.activeTexture(33984 + r),
                    n.bindTexture(34067, o.__webglTexture),
                    e.pixelStorei(37440, t.flipY);
                    for (var s = t && (t.isCompressedTexture || t.image[0].isCompressedTexture), c = t.image[0] && t.image[0].isDataTexture, l = [], p = 0; p < 6; p++)
                        l[p] = s || c ? c ? t.image[p].image : t.image[p] : g(t.image[p], !1, !0, u);
                    var d, f = l[0], m = y(f) || h, v = a.convert(t.format), w = a.convert(t.type), M = _(t.internalFormat, v, w);
                    if (C(34067, t, m),
                    s) {
                        for (p = 0; p < 6; p++) {
                            d = l[p].mipmaps;
                            for (var S = 0; S < d.length; S++) {
                                var T = d[S];
                                1023 !== t.format && 1022 !== t.format ? null !== v ? n.compressedTexImage2D(34069 + p, S, M, T.width, T.height, 0, T.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + p, S, M, T.width, T.height, 0, v, w, T.data)
                            }
                        }
                        o.__maxMipLevel = d.length - 1
                    } else {
                        d = t.mipmaps;
                        for (p = 0; p < 6; p++)
                            if (c) {
                                n.texImage2D(34069 + p, 0, M, l[p].width, l[p].height, 0, v, w, l[p].data);
                                for (S = 0; S < d.length; S++) {
                                    var E = (T = d[S]).image[p].image;
                                    n.texImage2D(34069 + p, S + 1, M, E.width, E.height, 0, v, w, E.data)
                                }
                            } else {
                                n.texImage2D(34069 + p, 0, M, v, w, l[p]);
                                for (S = 0; S < d.length; S++) {
                                    T = d[S];
                                    n.texImage2D(34069 + p, S + 1, M, v, w, T.image[p])
                                }
                            }
                        o.__maxMipLevel = d.length
                    }
                    x(t, m) && b(34067, t, f.width, f.height),
                    o.__version = t.version,
                    t.onUpdate && t.onUpdate(t)
                } else
                    n.activeTexture(33984 + r),
                    n.bindTexture(34067, o.__webglTexture)
            }
        }
        function L(e, t) {
            n.activeTexture(33984 + t),
            n.bindTexture(34067, i.get(e).__webglTexture)
        }
        var R = {
            1e3: 10497,
            1001: 33071,
            1002: 33648
        }
          , P = {
            1003: 9728,
            1004: 9984,
            1005: 9986,
            1006: 9729,
            1007: 9985,
            1008: 9987
        };
        function C(n, a, o) {
            o ? (e.texParameteri(n, 10242, R[a.wrapS]),
            e.texParameteri(n, 10243, R[a.wrapT]),
            32879 !== n && 35866 !== n || e.texParameteri(n, 32882, R[a.wrapR]),
            e.texParameteri(n, 10240, P[a.magFilter]),
            e.texParameteri(n, 10241, P[a.minFilter])) : (e.texParameteri(n, 10242, 33071),
            e.texParameteri(n, 10243, 33071),
            32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071),
            1001 === a.wrapS && 1001 === a.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
            e.texParameteri(n, 10240, w(a.magFilter)),
            e.texParameteri(n, 10241, w(a.minFilter)),
            1003 !== a.minFilter && 1006 !== a.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
            var s = t.get("EXT_texture_filter_anisotropic");
            if (s) {
                if (1015 === a.type && null === t.get("OES_texture_float_linear"))
                    return;
                if (1016 === a.type && null === (h || t.get("OES_texture_half_float_linear")))
                    return;
                (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())),
                i.get(a).__currentAnisotropy = a.anisotropy)
            }
        }
        function O(t, n) {
            void 0 === t.__webglInit && (t.__webglInit = !0,
            n.addEventListener("dispose", M),
            t.__webglTexture = e.createTexture(),
            o.memory.textures++)
        }
        function I(t, i, r) {
            var o = 3553;
            i.isDataTexture2DArray && (o = 35866),
            i.isDataTexture3D && (o = 32879),
            O(t, i),
            n.activeTexture(33984 + r),
            n.bindTexture(o, t.__webglTexture),
            e.pixelStorei(37440, i.flipY),
            e.pixelStorei(37441, i.premultiplyAlpha),
            e.pixelStorei(3317, i.unpackAlignment);
            var s = function(e) {
                return !h && (1001 !== e.wrapS || 1001 !== e.wrapT || 1003 !== e.minFilter && 1006 !== e.minFilter)
            }(i) && !1 === y(i.image)
              , c = g(i.image, s, !1, p)
              , l = y(c) || h
              , u = a.convert(i.format)
              , d = a.convert(i.type)
              , f = _(i.internalFormat, u, d);
            C(o, i, l);
            var m, v = i.mipmaps;
            if (i.isDepthTexture)
                f = 6402,
                h ? f = 1015 === i.type ? 36012 : 1014 === i.type ? 33190 : 1020 === i.type ? 35056 : 33189 : 1015 === i.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                1026 === i.format && 6402 === f && 1012 !== i.type && 1014 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                i.type = 1012,
                d = a.convert(i.type)),
                1027 === i.format && 6402 === f && (f = 34041,
                1020 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                i.type = 1020,
                d = a.convert(i.type))),
                n.texImage2D(3553, 0, f, c.width, c.height, 0, u, d, null);
            else if (i.isDataTexture)
                if (v.length > 0 && l) {
                    for (var w = 0, M = v.length; w < M; w++)
                        m = v[w],
                        n.texImage2D(3553, w, f, m.width, m.height, 0, u, d, m.data);
                    i.generateMipmaps = !1,
                    t.__maxMipLevel = v.length - 1
                } else
                    n.texImage2D(3553, 0, f, c.width, c.height, 0, u, d, c.data),
                    t.__maxMipLevel = 0;
            else if (i.isCompressedTexture) {
                for (w = 0,
                M = v.length; w < M; w++)
                    m = v[w],
                    1023 !== i.format && 1022 !== i.format ? null !== u ? n.compressedTexImage2D(3553, w, f, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, w, f, m.width, m.height, 0, u, d, m.data);
                t.__maxMipLevel = v.length - 1
            } else if (i.isDataTexture2DArray)
                n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, u, d, c.data),
                t.__maxMipLevel = 0;
            else if (i.isDataTexture3D)
                n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, u, d, c.data),
                t.__maxMipLevel = 0;
            else if (v.length > 0 && l) {
                for (w = 0,
                M = v.length; w < M; w++)
                    m = v[w],
                    n.texImage2D(3553, w, f, u, d, m);
                i.generateMipmaps = !1,
                t.__maxMipLevel = v.length - 1
            } else
                n.texImage2D(3553, 0, f, u, d, c),
                t.__maxMipLevel = 0;
            x(i, l) && b(o, i, c.width, c.height),
            t.__version = i.version,
            i.onUpdate && i.onUpdate(i)
        }
        function D(t, r, o, s) {
            var c = a.convert(r.texture.format)
              , h = a.convert(r.texture.type)
              , l = _(r.texture.internalFormat, c, h);
            n.texImage2D(s, 0, l, r.width, r.height, 0, c, h, null),
            e.bindFramebuffer(36160, t),
            e.framebufferTexture2D(36160, o, s, i.get(r.texture).__webglTexture, 0),
            e.bindFramebuffer(36160, null)
        }
        function N(t, n, i) {
            if (e.bindRenderbuffer(36161, t),
            n.depthBuffer && !n.stencilBuffer) {
                var r = 33189;
                if (i) {
                    var o = n.depthTexture;
                    o && o.isDepthTexture && (1015 === o.type ? r = 36012 : 1014 === o.type && (r = 33190));
                    var s = z(n);
                    e.renderbufferStorageMultisample(36161, s, r, n.width, n.height)
                } else
                    e.renderbufferStorage(36161, r, n.width, n.height);
                e.framebufferRenderbuffer(36160, 36096, 36161, t)
            } else if (n.depthBuffer && n.stencilBuffer) {
                if (i) {
                    s = z(n);
                    e.renderbufferStorageMultisample(36161, s, 35056, n.width, n.height)
                } else
                    e.renderbufferStorage(36161, 34041, n.width, n.height);
                e.framebufferRenderbuffer(36160, 33306, 36161, t)
            } else {
                var c = a.convert(n.texture.format)
                  , h = a.convert(n.texture.type);
                r = _(n.texture.internalFormat, c, h);
                if (i) {
                    s = z(n);
                    e.renderbufferStorageMultisample(36161, s, r, n.width, n.height)
                } else
                    e.renderbufferStorage(36161, r, n.width, n.height)
            }
            e.bindRenderbuffer(36161, null)
        }
        function U(t) {
            var n = i.get(t)
              , r = !0 === t.isWebGLCubeRenderTarget;
            if (t.depthTexture) {
                if (r)
                    throw new Error("target.depthTexture not supported in Cube render targets");
                !function(t, n) {
                    if (n && n.isWebGLCubeRenderTarget)
                        throw new Error("Depth Texture with cube render targets is not supported");
                    if (e.bindFramebuffer(36160, t),
                    !n.depthTexture || !n.depthTexture.isDepthTexture)
                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width,
                    n.depthTexture.image.height = n.height,
                    n.depthTexture.needsUpdate = !0),
                    E(n.depthTexture, 0);
                    var r = i.get(n.depthTexture).__webglTexture;
                    if (1026 === n.depthTexture.format)
                        e.framebufferTexture2D(36160, 36096, 3553, r, 0);
                    else {
                        if (1027 !== n.depthTexture.format)
                            throw new Error("Unknown depthTexture format");
                        e.framebufferTexture2D(36160, 33306, 3553, r, 0)
                    }
                }(n.__webglFramebuffer, t)
            } else if (r) {
                n.__webglDepthbuffer = [];
                for (var a = 0; a < 6; a++)
                    e.bindFramebuffer(36160, n.__webglFramebuffer[a]),
                    n.__webglDepthbuffer[a] = e.createRenderbuffer(),
                    N(n.__webglDepthbuffer[a], t, !1)
            } else
                e.bindFramebuffer(36160, n.__webglFramebuffer),
                n.__webglDepthbuffer = e.createRenderbuffer(),
                N(n.__webglDepthbuffer, t, !1);
            e.bindFramebuffer(36160, null)
        }
        function z(e) {
            return h && e.isWebGLMultisampleRenderTarget ? Math.min(d, e.samples) : 0
        }
        var B = !1
          , F = !1;
        this.allocateTextureUnit = function() {
            var e = T;
            return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l),
            T += 1,
            e
        }
        ,
        this.resetTextureUnits = function() {
            T = 0
        }
        ,
        this.setTexture2D = E,
        this.setTexture2DArray = function(e, t) {
            var r = i.get(e);
            e.version > 0 && r.__version !== e.version ? I(r, e, t) : (n.activeTexture(33984 + t),
            n.bindTexture(35866, r.__webglTexture))
        }
        ,
        this.setTexture3D = function(e, t) {
            var r = i.get(e);
            e.version > 0 && r.__version !== e.version ? I(r, e, t) : (n.activeTexture(33984 + t),
            n.bindTexture(32879, r.__webglTexture))
        }
        ,
        this.setTextureCube = A,
        this.setTextureCubeDynamic = L,
        this.setupRenderTarget = function(t) {
            var r = i.get(t)
              , s = i.get(t.texture);
            t.addEventListener("dispose", S),
            s.__webglTexture = e.createTexture(),
            o.memory.textures++;
            var c = !0 === t.isWebGLCubeRenderTarget
              , l = !0 === t.isWebGLMultisampleRenderTarget
              , u = y(t) || h;
            if (!h || 1022 !== t.texture.format || 1015 !== t.texture.type && 1016 !== t.texture.type || (t.texture.format = 1023,
            console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),
            c) {
                r.__webglFramebuffer = [];
                for (var p = 0; p < 6; p++)
                    r.__webglFramebuffer[p] = e.createFramebuffer()
            } else if (r.__webglFramebuffer = e.createFramebuffer(),
            l)
                if (h) {
                    r.__webglMultisampledFramebuffer = e.createFramebuffer(),
                    r.__webglColorRenderbuffer = e.createRenderbuffer(),
                    e.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
                    var d = a.convert(t.texture.format)
                      , f = a.convert(t.texture.type)
                      , m = _(t.texture.internalFormat, d, f)
                      , v = z(t);
                    e.renderbufferStorageMultisample(36161, v, m, t.width, t.height),
                    e.bindFramebuffer(36160, r.__webglMultisampledFramebuffer),
                    e.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer),
                    e.bindRenderbuffer(36161, null),
                    t.depthBuffer && (r.__webglDepthRenderbuffer = e.createRenderbuffer(),
                    N(r.__webglDepthRenderbuffer, t, !0)),
                    e.bindFramebuffer(36160, null)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (c) {
                n.bindTexture(34067, s.__webglTexture),
                C(34067, t.texture, u);
                for (p = 0; p < 6; p++)
                    D(r.__webglFramebuffer[p], t, 36064, 34069 + p);
                x(t.texture, u) && b(34067, t.texture, t.width, t.height),
                n.bindTexture(34067, null)
            } else
                n.bindTexture(3553, s.__webglTexture),
                C(3553, t.texture, u),
                D(r.__webglFramebuffer, t, 36064, 3553),
                x(t.texture, u) && b(3553, t.texture, t.width, t.height),
                n.bindTexture(3553, null);
            t.depthBuffer && U(t)
        }
        ,
        this.updateRenderTargetMipmap = function(e) {
            var t = e.texture;
            if (x(t, y(e) || h)) {
                var r = e.isWebGLCubeRenderTarget ? 34067 : 3553
                  , a = i.get(t).__webglTexture;
                n.bindTexture(r, a),
                b(r, t, e.width, e.height),
                n.bindTexture(r, null)
            }
        }
        ,
        this.updateMultisampleRenderTarget = function(t) {
            if (t.isWebGLMultisampleRenderTarget)
                if (h) {
                    var n = i.get(t);
                    e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
                    e.bindFramebuffer(36009, n.__webglFramebuffer);
                    var r = t.width
                      , a = t.height
                      , o = 16384;
                    t.depthBuffer && (o |= 256),
                    t.stencilBuffer && (o |= 1024),
                    e.blitFramebuffer(0, 0, r, a, 0, 0, r, a, o, 9728),
                    e.bindFramebuffer(36160, n.__webglMultisampledFramebuffer)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }
        ,
        this.safeSetTexture2D = function(e, t) {
            e && e.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
            B = !0),
            e = e.texture),
            E(e, t)
        }
        ,
        this.safeSetTextureCube = function(e, t) {
            e && e.isWebGLCubeRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
            F = !0),
            e = e.texture),
            e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? A(e, t) : L(e, t)
        }
    }
    function Zi(e, t, n) {
        var i = n.isWebGL2;
        return {
            convert: function(e) {
                var n;
                if (1009 === e)
                    return 5121;
                if (1017 === e)
                    return 32819;
                if (1018 === e)
                    return 32820;
                if (1019 === e)
                    return 33635;
                if (1010 === e)
                    return 5120;
                if (1011 === e)
                    return 5122;
                if (1012 === e)
                    return 5123;
                if (1013 === e)
                    return 5124;
                if (1014 === e)
                    return 5125;
                if (1015 === e)
                    return 5126;
                if (1016 === e)
                    return i ? 5131 : null !== (n = t.get("OES_texture_half_float")) ? n.HALF_FLOAT_OES : null;
                if (1021 === e)
                    return 6406;
                if (1022 === e)
                    return 6407;
                if (1023 === e)
                    return 6408;
                if (1024 === e)
                    return 6409;
                if (1025 === e)
                    return 6410;
                if (1026 === e)
                    return 6402;
                if (1027 === e)
                    return 34041;
                if (1028 === e)
                    return 6403;
                if (1029 === e)
                    return 36244;
                if (1030 === e)
                    return 33319;
                if (1031 === e)
                    return 33320;
                if (1032 === e)
                    return 36248;
                if (1033 === e)
                    return 36249;
                if (33776 === e || 33777 === e || 33778 === e || 33779 === e) {
                    if (null === (n = t.get("WEBGL_compressed_texture_s3tc")))
                        return null;
                    if (33776 === e)
                        return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === e)
                        return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === e)
                        return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === e)
                        return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (35840 === e || 35841 === e || 35842 === e || 35843 === e) {
                    if (null === (n = t.get("WEBGL_compressed_texture_pvrtc")))
                        return null;
                    if (35840 === e)
                        return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === e)
                        return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === e)
                        return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === e)
                        return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === e)
                    return null !== (n = t.get("WEBGL_compressed_texture_etc1")) ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((37492 === e || 37496 === e) && null !== (n = t.get("WEBGL_compressed_texture_etc"))) {
                    if (37492 === e)
                        return n.COMPRESSED_RGB8_ETC2;
                    if (37496 === e)
                        return n.COMPRESSED_RGBA8_ETC2_EAC
                }
                return 37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e || 37840 === e || 37841 === e || 37842 === e || 37843 === e || 37844 === e || 37845 === e || 37846 === e || 37847 === e || 37848 === e || 37849 === e || 37850 === e || 37851 === e || 37852 === e || 37853 === e ? null !== (n = t.get("WEBGL_compressed_texture_astc")) ? e : null : 36492 === e ? null !== (n = t.get("EXT_texture_compression_bptc")) ? e : null : 1020 === e ? i ? 34042 : null !== (n = t.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0
            }
        }
    }
    function Ji(e) {
        Vt.call(this),
        this.cameras = e || []
    }
    function Ki() {
        q.call(this),
        this.type = "Group"
    }
    function Qi() {
        this._targetRay = null,
        this._grip = null
    }
    function $i(e, t) {
        var n = this
          , i = null
          , r = 1
          , a = null
          , o = "local-floor"
          , s = null
          , c = []
          , h = new Map
          , l = new Vt;
        l.layers.enable(1),
        l.viewport = new f;
        var u = new Vt;
        u.layers.enable(2),
        u.viewport = new f;
        var p = [l, u]
          , d = new Ji;
        d.layers.enable(1),
        d.layers.enable(2);
        var m = null
          , v = null;
        function g(e) {
            var t = h.get(e.inputSource);
            t && t.dispatchEvent({
                type: e.type
            })
        }
        function y() {
            h.forEach((function(e, t) {
                e.disconnect(t)
            }
            )),
            h.clear(),
            e.setFramebuffer(null),
            e.setRenderTarget(e.getRenderTarget()),
            E.stop(),
            n.isPresenting = !1,
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        function x(e) {
            a = e,
            E.setContext(i),
            E.start(),
            n.isPresenting = !0,
            n.dispatchEvent({
                type: "sessionstart"
            })
        }
        function _(e) {
            for (var t = i.inputSources, n = 0; n < c.length; n++)
                h.set(t[n], c[n]);
            for (n = 0; n < e.removed.length; n++) {
                var r = e.removed[n];
                (a = h.get(r)) && (a.dispatchEvent({
                    type: "disconnected",
                    data: r
                }),
                h.delete(r))
            }
            for (n = 0; n < e.added.length; n++) {
                var a;
                r = e.added[n];
                (a = h.get(r)) && a.dispatchEvent({
                    type: "connected",
                    data: r
                })
            }
        }
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(e) {
            var t = c[e];
            return void 0 === t && (t = new Qi,
            c[e] = t),
            t.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(e) {
            var t = c[e];
            return void 0 === t && (t = new Qi,
            c[e] = t),
            t.getGripSpace()
        }
        ,
        this.setFramebufferScaleFactor = function(e) {
            r = e,
            !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(e) {
            o = e,
            !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return a
        }
        ,
        this.getSession = function() {
            return i
        }
        ,
        this.setSession = function(e) {
            if (null !== (i = e)) {
                i.addEventListener("select", g),
                i.addEventListener("selectstart", g),
                i.addEventListener("selectend", g),
                i.addEventListener("squeeze", g),
                i.addEventListener("squeezestart", g),
                i.addEventListener("squeezeend", g),
                i.addEventListener("end", y);
                var n = t.getContextAttributes();
                !0 !== n.xrCompatible && t.makeXRCompatible();
                var a = {
                    antialias: n.antialias,
                    alpha: n.alpha,
                    depth: n.depth,
                    stencil: n.stencil,
                    framebufferScaleFactor: r
                }
                  , s = new XRWebGLLayer(i,t,a);
                i.updateRenderState({
                    baseLayer: s
                }),
                i.requestReferenceSpace(o).then(x),
                i.addEventListener("inputsourceschange", _)
            }
        }
        ;
        var w = new b
          , M = new b;
        function S(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.getInverse(e.matrixWorld)
        }
        this.getCamera = function(e) {
            d.near = u.near = l.near = e.near,
            d.far = u.far = l.far = e.far,
            m === d.near && v === d.far || (i.updateRenderState({
                depthNear: d.near,
                depthFar: d.far
            }),
            m = d.near,
            v = d.far);
            var t = e.parent
              , n = d.cameras;
            S(d, t);
            for (var r = 0; r < n.length; r++)
                S(n[r], t);
            e.matrixWorld.copy(d.matrixWorld);
            for (var a = e.children, o = (r = 0,
            a.length); r < o; r++)
                a[r].updateMatrixWorld(!0);
            return 2 === n.length ? function(e, t, n) {
                w.setFromMatrixPosition(t.matrixWorld),
                M.setFromMatrixPosition(n.matrixWorld);
                var i = w.distanceTo(M)
                  , r = t.projectionMatrix.elements
                  , a = n.projectionMatrix.elements
                  , o = r[14] / (r[10] - 1)
                  , s = r[14] / (r[10] + 1)
                  , c = (r[9] + 1) / r[5]
                  , h = (r[9] - 1) / r[5]
                  , l = (r[8] - 1) / r[0]
                  , u = (a[8] + 1) / a[0]
                  , p = o * l
                  , d = o * u
                  , f = i / (-l + u)
                  , m = f * -l;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                e.translateX(m),
                e.translateZ(f),
                e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                e.matrixWorldInverse.getInverse(e.matrixWorld);
                var v = o + f
                  , g = s + f
                  , y = p - m
                  , x = d + (i - m)
                  , b = c * s / g * v
                  , _ = h * s / g * v;
                e.projectionMatrix.makePerspective(y, x, b, _, v, g)
            }(d, l, u) : d.projectionMatrix.copy(l.projectionMatrix),
            d
        }
        ;
        var T = null;
        var E = new Kt;
        E.setAnimationLoop((function(t, n) {
            if (null !== (s = n.getViewerPose(a))) {
                var r = s.views
                  , o = i.renderState.baseLayer;
                e.setFramebuffer(o.framebuffer);
                var h = !1;
                r.length !== d.cameras.length && (d.cameras.length = 0,
                h = !0);
                for (var l = 0; l < r.length; l++) {
                    var u = r[l]
                      , f = o.getViewport(u)
                      , m = p[l];
                    m.matrix.fromArray(u.transform.matrix),
                    m.projectionMatrix.fromArray(u.projectionMatrix),
                    m.viewport.set(f.x, f.y, f.width, f.height),
                    0 === l && d.matrix.copy(m.matrix),
                    !0 === h && d.cameras.push(m)
                }
            }
            var v = i.inputSources;
            for (l = 0; l < c.length; l++) {
                var g = c[l]
                  , y = v[l];
                g.update(y, n, a)
            }
            T && T(t, n)
        }
        )),
        this.setAnimationLoop = function(e) {
            T = e
        }
        ,
        this.dispose = function() {}
    }
    function er(e) {
        function t(t, n, i) {
            t.opacity.value = n.opacity,
            n.color && t.diffuse.value.copy(n.color),
            n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
            n.map && (t.map.value = n.map),
            n.alphaMap && (t.alphaMap.value = n.alphaMap),
            n.specularMap && (t.specularMap.value = n.specularMap);
            var r, a, o = n.envMap || i;
            o && (t.envMap.value = o,
            t.flipEnvMap.value = o.isCubeTexture ? -1 : 1,
            t.reflectivity.value = n.reflectivity,
            t.refractionRatio.value = n.refractionRatio,
            t.maxMipLevel.value = e.get(o).__maxMipLevel),
            n.lightMap && (t.lightMap.value = n.lightMap,
            t.lightMapIntensity.value = n.lightMapIntensity),
            n.aoMap && (t.aoMap.value = n.aoMap,
            t.aoMapIntensity.value = n.aoMapIntensity),
            n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap && (r = n.emissiveMap),
            void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture),
            !0 === r.matrixAutoUpdate && r.updateMatrix(),
            t.uvTransform.value.copy(r.matrix)),
            n.aoMap ? a = n.aoMap : n.lightMap && (a = n.lightMap),
            void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture),
            !0 === a.matrixAutoUpdate && a.updateMatrix(),
            t.uv2Transform.value.copy(a.matrix))
        }
        function n(e, t, n) {
            e.roughness.value = t.roughness,
            e.metalness.value = t.metalness,
            t.roughnessMap && (e.roughnessMap.value = t.roughnessMap),
            t.metalnessMap && (e.metalnessMap.value = t.metalnessMap),
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
            t.bumpMap && (e.bumpMap.value = t.bumpMap,
            e.bumpScale.value = t.bumpScale,
            1 === t.side && (e.bumpScale.value *= -1)),
            t.normalMap && (e.normalMap.value = t.normalMap,
            e.normalScale.value.copy(t.normalScale),
            1 === t.side && e.normalScale.value.negate()),
            t.displacementMap && (e.displacementMap.value = t.displacementMap,
            e.displacementScale.value = t.displacementScale,
            e.displacementBias.value = t.displacementBias),
            (t.envMap || n) && (e.envMapIntensity.value = t.envMapIntensity)
        }
        return {
            refreshFogUniforms: function(e, t) {
                e.fogColor.value.copy(t.color),
                t.isFog ? (e.fogNear.value = t.near,
                e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
            },
            refreshMaterialUniforms: function(e, i, r, a, o) {
                i.isMeshBasicMaterial ? t(e, i) : i.isMeshLambertMaterial ? (t(e, i),
                function(e, t) {
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                }(e, i)) : i.isMeshToonMaterial ? (t(e, i),
                function(e, t) {
                    e.specular.value.copy(t.specular),
                    e.shininess.value = Math.max(t.shininess, 1e-4),
                    t.gradientMap && (e.gradientMap.value = t.gradientMap);
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap,
                    e.bumpScale.value = t.bumpScale,
                    1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap,
                    e.normalScale.value.copy(t.normalScale),
                    1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap,
                    e.displacementScale.value = t.displacementScale,
                    e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isMeshPhongMaterial ? (t(e, i),
                function(e, t) {
                    e.specular.value.copy(t.specular),
                    e.shininess.value = Math.max(t.shininess, 1e-4),
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap,
                    e.bumpScale.value = t.bumpScale,
                    1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap,
                    e.normalScale.value.copy(t.normalScale),
                    1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap,
                    e.displacementScale.value = t.displacementScale,
                    e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isMeshStandardMaterial ? (t(e, i, r),
                i.isMeshPhysicalMaterial ? function(e, t, i) {
                    n(e, t, i),
                    e.reflectivity.value = t.reflectivity,
                    e.clearcoat.value = t.clearcoat,
                    e.clearcoatRoughness.value = t.clearcoatRoughness,
                    t.sheen && e.sheen.value.copy(t.sheen);
                    t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap);
                    t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap);
                    t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                    e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                    1 === t.side && e.clearcoatNormalScale.value.negate());
                    e.transparency.value = t.transparency
                }(e, i, r) : n(e, i, r)) : i.isMeshMatcapMaterial ? (t(e, i),
                function(e, t) {
                    t.matcap && (e.matcap.value = t.matcap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap,
                    e.bumpScale.value = t.bumpScale,
                    1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap,
                    e.normalScale.value.copy(t.normalScale),
                    1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap,
                    e.displacementScale.value = t.displacementScale,
                    e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isMeshDepthMaterial ? (t(e, i),
                function(e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap,
                    e.displacementScale.value = t.displacementScale,
                    e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isMeshDistanceMaterial ? (t(e, i),
                function(e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap,
                    e.displacementScale.value = t.displacementScale,
                    e.displacementBias.value = t.displacementBias);
                    e.referencePosition.value.copy(t.referencePosition),
                    e.nearDistance.value = t.nearDistance,
                    e.farDistance.value = t.farDistance
                }(e, i)) : i.isMeshNormalMaterial ? (t(e, i),
                function(e, t) {
                    t.bumpMap && (e.bumpMap.value = t.bumpMap,
                    e.bumpScale.value = t.bumpScale,
                    1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap,
                    e.normalScale.value.copy(t.normalScale),
                    1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap,
                    e.displacementScale.value = t.displacementScale,
                    e.displacementBias.value = t.displacementBias)
                }(e, i)) : i.isLineBasicMaterial ? (function(e, t) {
                    e.diffuse.value.copy(t.color),
                    e.opacity.value = t.opacity
                }(e, i),
                i.isLineDashedMaterial && function(e, t) {
                    e.dashSize.value = t.dashSize,
                    e.totalSize.value = t.dashSize + t.gapSize,
                    e.scale.value = t.scale
                }(e, i)) : i.isPointsMaterial ? function(e, t, n, i) {
                    e.diffuse.value.copy(t.color),
                    e.opacity.value = t.opacity,
                    e.size.value = t.size * n,
                    e.scale.value = .5 * i,
                    t.map && (e.map.value = t.map);
                    t.alphaMap && (e.alphaMap.value = t.alphaMap);
                    var r;
                    t.map ? r = t.map : t.alphaMap && (r = t.alphaMap);
                    void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                    e.uvTransform.value.copy(r.matrix))
                }(e, i, a, o) : i.isSpriteMaterial ? function(e, t) {
                    e.diffuse.value.copy(t.color),
                    e.opacity.value = t.opacity,
                    e.rotation.value = t.rotation,
                    t.map && (e.map.value = t.map);
                    t.alphaMap && (e.alphaMap.value = t.alphaMap);
                    var n;
                    t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
                    void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                    e.uvTransform.value.copy(n.matrix))
                }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color),
                e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
            }
        }
    }
    function tr(e) {
        var t = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
          , n = void 0 !== e.context ? e.context : null
          , i = void 0 !== e.alpha && e.alpha
          , r = void 0 === e.depth || e.depth
          , a = void 0 === e.stencil || e.stencil
          , o = void 0 !== e.antialias && e.antialias
          , s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha
          , l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer
          , u = void 0 !== e.powerPreference ? e.powerPreference : "default"
          , p = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat
          , d = null
          , m = null;
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.outputEncoding = 3e3,
        this.physicallyCorrectLights = !1,
        this.toneMapping = 0,
        this.toneMappingExposure = 1,
        this.toneMappingWhitePoint = 1,
        this.maxMorphTargets = 8,
        this.maxMorphNormals = 4;
        var v, g, y, x, _, w, M, S, T, E, A, R, P, C, O, I, D, N, U, z = this, B = !1, F = null, H = 0, k = 0, G = null, V = null, j = -1, W = {
            geometry: null,
            program: null,
            wireframe: !1
        }, q = null, Y = null, Z = new f, J = new f, K = null, Q = t.width, $ = t.height, ee = 1, te = null, ne = null, ie = new f(0,0,Q,$), re = new f(0,0,Q,$), ae = !1, oe = new Zt, se = new sn, ce = !1, he = !1, le = new L, ue = new b;
        function pe() {
            return null === G ? ee : 1
        }
        try {
            var de = {
                alpha: i,
                depth: r,
                stencil: a,
                antialias: o,
                premultipliedAlpha: s,
                preserveDrawingBuffer: l,
                powerPreference: u,
                failIfMajorPerformanceCaveat: p
            };
            if (t.addEventListener("webglcontextlost", ge, !1),
            t.addEventListener("webglcontextrestored", ye, !1),
            null === (v = n || t.getContext("webgl", de) || t.getContext("experimental-webgl", de)))
                throw null !== t.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            void 0 === v.getShaderPrecisionFormat && (v.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (e) {
            throw console.error("THREE.WebGLRenderer: " + e.message),
            e
        }
        function fe() {
            g = new cn(v),
            !1 === (y = new on(v,g,e)).isWebGL2 && (g.get("WEBGL_depth_texture"),
            g.get("OES_texture_float"),
            g.get("OES_texture_half_float"),
            g.get("OES_texture_half_float_linear"),
            g.get("OES_standard_derivatives"),
            g.get("OES_element_index_uint"),
            g.get("ANGLE_instanced_arrays")),
            g.get("OES_texture_float_linear"),
            U = new Zi(v,g,y),
            (x = new Xi(v,g,y)).scissor(J.copy(re).multiplyScalar(ee).floor()),
            x.viewport(Z.copy(ie).multiplyScalar(ee).floor()),
            _ = new un(v),
            w = new Ii,
            M = new Yi(v,g,x,w,y,U,_),
            S = new Qt(v,y),
            T = new hn(v,S,_),
            E = new fn(v,T,S,_),
            I = new dn(v),
            A = new Oi(z,g,y),
            R = new er(w),
            P = new zi,
            C = new Vi,
            O = new rn(z,x,E,s),
            D = new an(v,g,_,y),
            N = new ln(v,g,_,y),
            _.programs = A.programs,
            z.capabilities = y,
            z.extensions = g,
            z.properties = w,
            z.renderLists = P,
            z.state = x,
            z.info = _
        }
        fe();
        var me = new $i(z,v);
        this.xr = me;
        var ve = new qi(z,E,y.maxTextureSize);
        function ge(e) {
            e.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            B = !0
        }
        function ye() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            B = !1,
            fe()
        }
        function xe(e) {
            var t = e.target;
            t.removeEventListener("dispose", xe),
            function(e) {
                be(e),
                w.remove(e)
            }(t)
        }
        function be(e) {
            var t = w.get(e).program;
            e.program = void 0,
            void 0 !== t && A.releaseProgram(t)
        }
        this.shadowMap = ve,
        this.getContext = function() {
            return v
        }
        ,
        this.getContextAttributes = function() {
            return v.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            var e = g.get("WEBGL_lose_context");
            e && e.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            var e = g.get("WEBGL_lose_context");
            e && e.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return ee
        }
        ,
        this.setPixelRatio = function(e) {
            void 0 !== e && (ee = e,
            this.setSize(Q, $, !1))
        }
        ,
        this.getSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),
            e = new h),
            e.set(Q, $)
        }
        ,
        this.setSize = function(e, n, i) {
            me.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Q = e,
            $ = n,
            t.width = Math.floor(e * ee),
            t.height = Math.floor(n * ee),
            !1 !== i && (t.style.width = e + "px",
            t.style.height = n + "px"),
            this.setViewport(0, 0, e, n))
        }
        ,
        this.getDrawingBufferSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
            e = new h),
            e.set(Q * ee, $ * ee).floor()
        }
        ,
        this.setDrawingBufferSize = function(e, n, i) {
            Q = e,
            $ = n,
            ee = i,
            t.width = Math.floor(e * i),
            t.height = Math.floor(n * i),
            this.setViewport(0, 0, e, n)
        }
        ,
        this.getCurrentViewport = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),
            e = new f),
            e.copy(Z)
        }
        ,
        this.getViewport = function(e) {
            return e.copy(ie)
        }
        ,
        this.setViewport = function(e, t, n, i) {
            e.isVector4 ? ie.set(e.x, e.y, e.z, e.w) : ie.set(e, t, n, i),
            x.viewport(Z.copy(ie).multiplyScalar(ee).floor())
        }
        ,
        this.getScissor = function(e) {
            return e.copy(re)
        }
        ,
        this.setScissor = function(e, t, n, i) {
            e.isVector4 ? re.set(e.x, e.y, e.z, e.w) : re.set(e, t, n, i),
            x.scissor(J.copy(re).multiplyScalar(ee).floor())
        }
        ,
        this.getScissorTest = function() {
            return ae
        }
        ,
        this.setScissorTest = function(e) {
            x.setScissorTest(ae = e)
        }
        ,
        this.setOpaqueSort = function(e) {
            te = e
        }
        ,
        this.setTransparentSort = function(e) {
            ne = e
        }
        ,
        this.getClearColor = function() {
            return O.getClearColor()
        }
        ,
        this.setClearColor = function() {
            O.setClearColor.apply(O, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return O.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            O.setClearAlpha.apply(O, arguments)
        }
        ,
        this.clear = function(e, t, n) {
            var i = 0;
            (void 0 === e || e) && (i |= 16384),
            (void 0 === t || t) && (i |= 256),
            (void 0 === n || n) && (i |= 1024),
            v.clear(i)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", ge, !1),
            t.removeEventListener("webglcontextrestored", ye, !1),
            P.dispose(),
            C.dispose(),
            w.dispose(),
            E.dispose(),
            me.dispose(),
            Me.stop()
        }
        ,
        this.renderBufferImmediate = function(e, t) {
            x.initAttributes();
            var n = w.get(e);
            e.hasPositions && !n.position && (n.position = v.createBuffer()),
            e.hasNormals && !n.normal && (n.normal = v.createBuffer()),
            e.hasUvs && !n.uv && (n.uv = v.createBuffer()),
            e.hasColors && !n.color && (n.color = v.createBuffer());
            var i = t.getAttributes();
            e.hasPositions && (v.bindBuffer(34962, n.position),
            v.bufferData(34962, e.positionArray, 35048),
            x.enableAttribute(i.position),
            v.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
            e.hasNormals && (v.bindBuffer(34962, n.normal),
            v.bufferData(34962, e.normalArray, 35048),
            x.enableAttribute(i.normal),
            v.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
            e.hasUvs && (v.bindBuffer(34962, n.uv),
            v.bufferData(34962, e.uvArray, 35048),
            x.enableAttribute(i.uv),
            v.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
            e.hasColors && (v.bindBuffer(34962, n.color),
            v.bufferData(34962, e.colorArray, 35048),
            x.enableAttribute(i.color),
            v.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
            x.disableUnusedAttributes(),
            v.drawArrays(4, 0, e.count),
            e.count = 0
        }
        ;
        var _e = new X;
        this.renderBufferDirect = function(e, t, n, i, r, a) {
            null === t && (t = _e);
            var o = r.isMesh && r.matrixWorld.determinant() < 0
              , s = Le(e, t, i, r);
            x.setMaterial(i, o);
            var c = !1;
            W.geometry === n.id && W.program === s.id && W.wireframe === (!0 === i.wireframe) || (W.geometry = n.id,
            W.program = s.id,
            W.wireframe = !0 === i.wireframe,
            c = !0),
            (i.morphTargets || i.morphNormals) && (I.update(r, n, i, s),
            c = !0),
            !0 === r.isInstancedMesh && (c = !0);
            var h = n.index
              , l = n.attributes.position;
            if (null === h) {
                if (void 0 === l || 0 === l.count)
                    return
            } else if (0 === h.count)
                return;
            var u, p = 1;
            !0 === i.wireframe && (h = T.getWireframeAttribute(n),
            p = 2);
            var d = D;
            null !== h && (u = S.get(h),
            (d = N).setIndex(u)),
            c && (!function(e, t, n, i) {
                if (!1 === y.isWebGL2 && (e.isInstancedMesh || t.isInstancedBufferGeometry) && null === g.get("ANGLE_instanced_arrays"))
                    return;
                x.initAttributes();
                var r = t.attributes
                  , a = i.getAttributes()
                  , o = n.defaultAttributeValues;
                for (var s in a) {
                    var c = a[s];
                    if (c >= 0) {
                        var h = r[s];
                        if (void 0 !== h) {
                            var l = h.normalized
                              , u = h.itemSize;
                            if (void 0 === (w = S.get(h)))
                                continue;
                            var p = w.buffer
                              , d = w.type
                              , f = w.bytesPerElement;
                            if (h.isInterleavedBufferAttribute) {
                                var m = h.data
                                  , b = m.stride
                                  , _ = h.offset;
                                m && m.isInstancedInterleavedBuffer ? (x.enableAttributeAndDivisor(c, m.meshPerAttribute),
                                void 0 === t._maxInstanceCount && (t._maxInstanceCount = m.meshPerAttribute * m.count)) : x.enableAttribute(c),
                                v.bindBuffer(34962, p),
                                x.vertexAttribPointer(c, u, d, l, b * f, _ * f)
                            } else
                                h.isInstancedBufferAttribute ? (x.enableAttributeAndDivisor(c, h.meshPerAttribute),
                                void 0 === t._maxInstanceCount && (t._maxInstanceCount = h.meshPerAttribute * h.count)) : x.enableAttribute(c),
                                v.bindBuffer(34962, p),
                                x.vertexAttribPointer(c, u, d, l, 0, 0)
                        } else if ("instanceMatrix" === s) {
                            var w;
                            if (void 0 === (w = S.get(e.instanceMatrix)))
                                continue;
                            p = w.buffer,
                            d = w.type;
                            x.enableAttributeAndDivisor(c + 0, 1),
                            x.enableAttributeAndDivisor(c + 1, 1),
                            x.enableAttributeAndDivisor(c + 2, 1),
                            x.enableAttributeAndDivisor(c + 3, 1),
                            v.bindBuffer(34962, p),
                            v.vertexAttribPointer(c + 0, 4, d, !1, 64, 0),
                            v.vertexAttribPointer(c + 1, 4, d, !1, 64, 16),
                            v.vertexAttribPointer(c + 2, 4, d, !1, 64, 32),
                            v.vertexAttribPointer(c + 3, 4, d, !1, 64, 48)
                        } else if (void 0 !== o) {
                            var M = o[s];
                            if (void 0 !== M)
                                switch (M.length) {
                                case 2:
                                    v.vertexAttrib2fv(c, M);
                                    break;
                                case 3:
                                    v.vertexAttrib3fv(c, M);
                                    break;
                                case 4:
                                    v.vertexAttrib4fv(c, M);
                                    break;
                                default:
                                    v.vertexAttrib1fv(c, M)
                                }
                        }
                    }
                }
                x.disableUnusedAttributes()
            }(r, n, i, s),
            null !== h && v.bindBuffer(34963, u.buffer));
            var f = null !== h ? h.count : l.count
              , m = n.drawRange.start * p
              , b = n.drawRange.count * p
              , _ = null !== a ? a.start * p : 0
              , w = null !== a ? a.count * p : 1 / 0
              , M = Math.max(m, _)
              , E = Math.min(f, m + b, _ + w) - 1
              , A = Math.max(0, E - M + 1);
            if (0 !== A) {
                if (r.isMesh)
                    !0 === i.wireframe ? (x.setLineWidth(i.wireframeLinewidth * pe()),
                    d.setMode(1)) : d.setMode(4);
                else if (r.isLine) {
                    var L = i.linewidth;
                    void 0 === L && (L = 1),
                    x.setLineWidth(L * pe()),
                    r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                } else
                    r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                if (r.isInstancedMesh)
                    d.renderInstances(n, M, A, r.count);
                else if (n.isInstancedBufferGeometry) {
                    var R = Math.min(n.instanceCount, n._maxInstanceCount);
                    d.renderInstances(n, M, A, R)
                } else
                    d.render(M, A)
            }
        }
        ,
        this.compile = function(e, t) {
            (m = C.get(e, t)).init(),
            e.traverse((function(e) {
                e.isLight && (m.pushLight(e),
                e.castShadow && m.pushShadow(e))
            }
            )),
            m.setupLights(t);
            const n = {};
            e.traverse((function(t) {
                let i = t.material;
                if (i)
                    if (Array.isArray(i))
                        for (let r = 0; r < i.length; r++) {
                            let a = i[r];
                            a.uuid in n == !1 && (Ae(a, e, t),
                            n[a.uuid] = !0)
                        }
                    else
                        i.uuid in n == !1 && (Ae(i, e, t),
                        n[i.uuid] = !0)
            }
            ))
        }
        ;
        var we = null;
        var Me = new Kt;
        function Se(e, t, n, i) {
            if (!1 !== e.visible) {
                if (e.layers.test(t.layers))
                    if (e.isGroup)
                        n = e.renderOrder;
                    else if (e.isLOD)
                        !0 === e.autoUpdate && e.update(t);
                    else if (e.isLight)
                        m.pushLight(e),
                        e.castShadow && m.pushShadow(e);
                    else if (e.isSprite) {
                        if (!e.frustumCulled || oe.intersectsSprite(e)) {
                            i && ue.setFromMatrixPosition(e.matrixWorld).applyMatrix4(le);
                            var r = E.update(e);
                            (a = e.material).visible && d.push(e, r, a, n, ue.z, null)
                        }
                    } else if (e.isImmediateRenderObject)
                        i && ue.setFromMatrixPosition(e.matrixWorld).applyMatrix4(le),
                        d.push(e, null, e.material, n, ue.z, null);
                    else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== _.render.frame && (e.skeleton.update(),
                    e.skeleton.frame = _.render.frame),
                    !e.frustumCulled || oe.intersectsObject(e))) {
                        i && ue.setFromMatrixPosition(e.matrixWorld).applyMatrix4(le);
                        r = E.update(e);
                        var a = e.material;
                        if (Array.isArray(a))
                            for (var o = r.groups, s = 0, c = o.length; s < c; s++) {
                                var h = o[s]
                                  , l = a[h.materialIndex];
                                l && l.visible && d.push(e, r, l, n, ue.z, h)
                            }
                        else
                            a.visible && d.push(e, r, a, n, ue.z, null)
                    }
                var u = e.children;
                for (s = 0,
                c = u.length; s < c; s++)
                    Se(u[s], t, n, i)
            }
        }
        function Te(e, t, n, i) {
            for (var r = 0, a = e.length; r < a; r++) {
                var o = e[r]
                  , s = o.object
                  , c = o.geometry
                  , h = void 0 === i ? o.material : i
                  , l = o.group;
                if (n.isArrayCamera) {
                    Y = n;
                    for (var u = n.cameras, p = 0, d = u.length; p < d; p++) {
                        var f = u[p];
                        s.layers.test(f.layers) && (x.viewport(Z.copy(f.viewport)),
                        m.setupLights(f),
                        Ee(s, t, f, c, h, l))
                    }
                } else
                    Y = null,
                    Ee(s, t, n, c, h, l)
            }
        }
        function Ee(e, t, n, i, r, a) {
            if (e.onBeforeRender(z, t, n, i, r, a),
            m = C.get(t, Y || n),
            e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
            e.isImmediateRenderObject) {
                var o = Le(n, t, r, e);
                x.setMaterial(r),
                W.geometry = null,
                W.program = null,
                W.wireframe = !1,
                function(e, t) {
                    e.render((function(e) {
                        z.renderBufferImmediate(e, t)
                    }
                    ))
                }(e, o)
            } else
                z.renderBufferDirect(n, t, i, r, e, a);
            e.onAfterRender(z, t, n, i, r, a),
            m = C.get(t, Y || n)
        }
        function Ae(e, t, n) {
            var i = w.get(e)
              , r = m.state.lights
              , a = m.state.shadowsArray
              , o = r.state.version
              , s = A.getParameters(e, r.state, a, t, se.numPlanes, se.numIntersection, n)
              , c = A.getProgramCacheKey(s)
              , h = i.program
              , l = !0;
            if (void 0 === h)
                e.addEventListener("dispose", xe);
            else if (h.cacheKey !== c)
                be(e);
            else if (i.lightsStateVersion !== o)
                i.lightsStateVersion = o,
                l = !1;
            else {
                if (void 0 !== s.shaderID)
                    return;
                l = !1
            }
            l && (h = A.acquireProgram(s, c),
            i.program = h,
            i.uniforms = s.uniforms,
            i.outputEncoding = s.outputEncoding,
            e.program = h);
            var u = h.getAttributes();
            if (e.morphTargets) {
                e.numSupportedMorphTargets = 0;
                for (var p = 0; p < z.maxMorphTargets; p++)
                    u["morphTarget" + p] >= 0 && e.numSupportedMorphTargets++
            }
            if (e.morphNormals) {
                e.numSupportedMorphNormals = 0;
                for (p = 0; p < z.maxMorphNormals; p++)
                    u["morphNormal" + p] >= 0 && e.numSupportedMorphNormals++
            }
            var d = i.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (i.numClippingPlanes = se.numPlanes,
            i.numIntersection = se.numIntersection,
            d.clippingPlanes = se.uniform),
            i.environment = e.isMeshStandardMaterial ? t.environment : null,
            i.fog = t.fog,
            i.needsLights = function(e) {
                return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
            }(e),
            i.lightsStateVersion = o,
            i.needsLights && (d.ambientLightColor.value = r.state.ambient,
            d.lightProbe.value = r.state.probe,
            d.directionalLights.value = r.state.directional,
            d.directionalLightShadows.value = r.state.directionalShadow,
            d.spotLights.value = r.state.spot,
            d.spotLightShadows.value = r.state.spotShadow,
            d.rectAreaLights.value = r.state.rectArea,
            d.pointLights.value = r.state.point,
            d.pointLightShadows.value = r.state.pointShadow,
            d.hemisphereLights.value = r.state.hemi,
            d.directionalShadowMap.value = r.state.directionalShadowMap,
            d.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
            d.spotShadowMap.value = r.state.spotShadowMap,
            d.spotShadowMatrix.value = r.state.spotShadowMatrix,
            d.pointShadowMap.value = r.state.pointShadowMap,
            d.pointShadowMatrix.value = r.state.pointShadowMatrix);
            var f = i.program.getUniforms()
              , v = pi.seqWithValue(f.seq, d);
            i.uniformsList = v
        }
        function Le(e, t, n, i) {
            M.resetTextureUnits();
            var r = t.fog
              , a = n.isMeshStandardMaterial ? t.environment : null
              , o = null === G ? z.outputEncoding : G.texture.encoding
              , s = w.get(n)
              , h = m.state.lights;
            if (ce && (he || e !== q)) {
                var l = e === q && n.id === j;
                se.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, s, l)
            }
            n.version === s.__version ? void 0 === s.program || n.fog && s.fog !== r || s.environment !== a || s.needsLights && s.lightsStateVersion !== h.state.version ? Ae(n, t, i) : void 0 === s.numClippingPlanes || s.numClippingPlanes === se.numPlanes && s.numIntersection === se.numIntersection ? s.outputEncoding !== o && Ae(n, t, i) : Ae(n, t, i) : (Ae(n, t, i),
            s.__version = n.version);
            var u, p, d = !1, f = !1, g = !1, b = s.program, _ = b.getUniforms(), S = s.uniforms;
            if (x.useProgram(b.program) && (d = !0,
            f = !0,
            g = !0),
            n.id !== j && (j = n.id,
            f = !0),
            d || q !== e) {
                if (_.setValue(v, "projectionMatrix", e.projectionMatrix),
                y.logarithmicDepthBuffer && _.setValue(v, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                q !== e && (q = e,
                f = !0,
                g = !0),
                n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                    var T = _.map.cameraPosition;
                    void 0 !== T && T.setValue(v, ue.setFromMatrixPosition(e.matrixWorld))
                }
                (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && _.setValue(v, "isOrthographic", !0 === e.isOrthographicCamera),
                (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && _.setValue(v, "viewMatrix", e.matrixWorldInverse)
            }
            if (n.skinning) {
                _.setOptional(v, i, "bindMatrix"),
                _.setOptional(v, i, "bindMatrixInverse");
                var E = i.skeleton;
                if (E) {
                    var A = E.bones;
                    if (y.floatVertexTextures) {
                        if (void 0 === E.boneTexture) {
                            var L = Math.sqrt(4 * A.length);
                            L = c.ceilPowerOfTwo(L),
                            L = Math.max(L, 4);
                            var P = new Float32Array(L * L * 4);
                            P.set(E.boneMatrices);
                            var C = new qt(P,L,L,1023,1015);
                            E.boneMatrices = P,
                            E.boneTexture = C,
                            E.boneTextureSize = L
                        }
                        _.setValue(v, "boneTexture", E.boneTexture, M),
                        _.setValue(v, "boneTextureSize", E.boneTextureSize)
                    } else
                        _.setOptional(v, E, "boneMatrices")
                }
            }
            return (f || s.receiveShadow !== i.receiveShadow) && (s.receiveShadow = i.receiveShadow,
            _.setValue(v, "receiveShadow", i.receiveShadow)),
            f && (_.setValue(v, "toneMappingExposure", z.toneMappingExposure),
            _.setValue(v, "toneMappingWhitePoint", z.toneMappingWhitePoint),
            s.needsLights && (p = g,
            (u = S).ambientLightColor.needsUpdate = p,
            u.lightProbe.needsUpdate = p,
            u.directionalLights.needsUpdate = p,
            u.directionalLightShadows.needsUpdate = p,
            u.pointLights.needsUpdate = p,
            u.pointLightShadows.needsUpdate = p,
            u.spotLights.needsUpdate = p,
            u.spotLightShadows.needsUpdate = p,
            u.rectAreaLights.needsUpdate = p,
            u.hemisphereLights.needsUpdate = p),
            r && n.fog && R.refreshFogUniforms(S, r),
            R.refreshMaterialUniforms(S, n, a, ee, $),
            void 0 !== S.ltc_1 && (S.ltc_1.value = Jt.LTC_1),
            void 0 !== S.ltc_2 && (S.ltc_2.value = Jt.LTC_2),
            pi.upload(v, s.uniformsList, S, M)),
            n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (pi.upload(v, s.uniformsList, S, M),
            n.uniformsNeedUpdate = !1),
            n.isSpriteMaterial && _.setValue(v, "center", i.center),
            _.setValue(v, "modelViewMatrix", i.modelViewMatrix),
            _.setValue(v, "normalMatrix", i.normalMatrix),
            _.setValue(v, "modelMatrix", i.matrixWorld),
            b
        }
        Me.setAnimationLoop((function(e) {
            me.isPresenting || we && we(e)
        }
        )),
        "undefined" != typeof window && Me.setContext(window),
        this.setAnimationLoop = function(e) {
            we = e,
            me.setAnimationLoop(e),
            Me.start()
        }
        ,
        this.render = function(e, t) {
            var n, i;
            if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),
            n = arguments[2]),
            void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),
            i = arguments[3]),
            t && t.isCamera) {
                if (!B) {
                    W.geometry = null,
                    W.program = null,
                    W.wireframe = !1,
                    j = -1,
                    q = null,
                    !0 === e.autoUpdate && e.updateMatrixWorld(),
                    null === t.parent && t.updateMatrixWorld(),
                    me.enabled && me.isPresenting && (t = me.getCamera(t)),
                    e.onBeforeRender(z, e, t, n || G),
                    (m = C.get(e, t)).init(),
                    le.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                    oe.setFromProjectionMatrix(le),
                    he = this.localClippingEnabled,
                    ce = se.init(this.clippingPlanes, he, t),
                    (d = P.get(e, t)).init(),
                    Se(e, t, 0, z.sortObjects),
                    d.finish(),
                    !0 === z.sortObjects && d.sort(te, ne),
                    ce && se.beginShadows();
                    var r = m.state.shadowsArray;
                    ve.render(r, e, t),
                    m.setupLights(t),
                    ce && se.endShadows(),
                    this.info.autoReset && this.info.reset(),
                    void 0 !== n && this.setRenderTarget(n),
                    O.render(d, e, t, i);
                    var a = d.opaque
                      , o = d.transparent;
                    if (e.overrideMaterial) {
                        var s = e.overrideMaterial;
                        a.length && Te(a, e, t, s),
                        o.length && Te(o, e, t, s)
                    } else
                        a.length && Te(a, e, t),
                        o.length && Te(o, e, t);
                    e.onAfterRender(z, e, t),
                    null !== G && (M.updateRenderTargetMipmap(G),
                    M.updateMultisampleRenderTarget(G)),
                    x.buffers.depth.setTest(!0),
                    x.buffers.depth.setMask(!0),
                    x.buffers.color.setMask(!0),
                    x.setPolygonOffset(!1),
                    d = null,
                    m = null
                }
            } else
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }
        ,
        this.setFramebuffer = function(e) {
            F !== e && null === G && v.bindFramebuffer(36160, e),
            F = e
        }
        ,
        this.getActiveCubeFace = function() {
            return H
        }
        ,
        this.getActiveMipmapLevel = function() {
            return k
        }
        ,
        this.getRenderTarget = function() {
            return G
        }
        ,
        this.setRenderTarget = function(e, t, n) {
            G = e,
            H = t,
            k = n,
            e && void 0 === w.get(e).__webglFramebuffer && M.setupRenderTarget(e);
            var i = F
              , r = !1;
            if (e) {
                var a = w.get(e).__webglFramebuffer;
                e.isWebGLCubeRenderTarget ? (i = a[t || 0],
                r = !0) : i = e.isWebGLMultisampleRenderTarget ? w.get(e).__webglMultisampledFramebuffer : a,
                Z.copy(e.viewport),
                J.copy(e.scissor),
                K = e.scissorTest
            } else
                Z.copy(ie).multiplyScalar(ee).floor(),
                J.copy(re).multiplyScalar(ee).floor(),
                K = ae;
            if (V !== i && (v.bindFramebuffer(36160, i),
            V = i),
            x.viewport(Z),
            x.scissor(J),
            x.setScissorTest(K),
            r) {
                var o = w.get(e.texture);
                v.framebufferTexture2D(36160, 36064, 34069 + (t || 0), o.__webglTexture, n || 0)
            }
        }
        ,
        this.readRenderTargetPixels = function(e, t, n, i, r, a, o) {
            if (e && e.isWebGLRenderTarget) {
                var s = w.get(e).__webglFramebuffer;
                if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]),
                s) {
                    var c = !1;
                    s !== V && (v.bindFramebuffer(36160, s),
                    c = !0);
                    try {
                        var h = e.texture
                          , l = h.format
                          , u = h.type;
                        if (1023 !== l && U.convert(l) !== v.getParameter(35739))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(1009 === u || U.convert(u) === v.getParameter(35738) || 1015 === u && (y.isWebGL2 || g.get("OES_texture_float") || g.get("WEBGL_color_buffer_float")) || 1016 === u && (y.isWebGL2 ? g.get("EXT_color_buffer_float") : g.get("EXT_color_buffer_half_float"))))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === v.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && v.readPixels(t, n, i, r, U.convert(l), U.convert(u), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        c && v.bindFramebuffer(36160, V)
                    }
                }
            } else
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }
        ,
        this.copyFramebufferToTexture = function(e, t, n) {
            void 0 === n && (n = 0);
            var i = Math.pow(2, -n)
              , r = Math.floor(t.image.width * i)
              , a = Math.floor(t.image.height * i)
              , o = U.convert(t.format);
            M.setTexture2D(t, 0),
            v.copyTexImage2D(3553, n, o, e.x, e.y, r, a, 0),
            x.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(e, t, n, i) {
            void 0 === i && (i = 0);
            var r = t.image.width
              , a = t.image.height
              , o = U.convert(n.format)
              , s = U.convert(n.type);
            M.setTexture2D(n, 0),
            t.isDataTexture ? v.texSubImage2D(3553, i, e.x, e.y, r, a, o, s, t.image.data) : t.isCompressedTexture ? v.compressedTexSubImage2D(3553, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : v.texSubImage2D(3553, i, e.x, e.y, o, s, t.image),
            0 === i && n.generateMipmaps && v.generateMipmap(3553),
            x.unbindTexture()
        }
        ,
        this.initTexture = function(e) {
            M.setTexture2D(e, 0),
            x.unbindTexture()
        }
        ,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    function nr(e, t) {
        this.name = "",
        this.color = new ze(e),
        this.density = void 0 !== t ? t : 25e-5
    }
    function ir(e, t, n) {
        this.name = "",
        this.color = new ze(e),
        this.near = void 0 !== t ? t : 1,
        this.far = void 0 !== n ? n : 1e3
    }
    function rr(e, t) {
        this.array = e,
        this.stride = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.usage = 35044,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    Ji.prototype = Object.assign(Object.create(Vt.prototype), {
        constructor: Ji,
        isArrayCamera: !0
    }),
    Ki.prototype = Object.assign(Object.create(q.prototype), {
        constructor: Ki,
        isGroup: !0
    }),
    Object.assign(Qi.prototype, {
        constructor: Qi,
        getTargetRaySpace: function() {
            return null === this._targetRay && (this._targetRay = new Ki,
            this._targetRay.matrixAutoUpdate = !1,
            this._targetRay.visible = !1),
            this._targetRay
        },
        getGripSpace: function() {
            return null === this._grip && (this._grip = new Ki,
            this._grip.matrixAutoUpdate = !1,
            this._grip.visible = !1),
            this._grip
        },
        dispatchEvent: function(e) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(e),
            null !== this._grip && this._grip.dispatchEvent(e),
            this
        },
        disconnect: function(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            this
        },
        update: function(e, t, n) {
            var i = null
              , r = null
              , a = this._targetRay
              , o = this._grip;
            return e && (null !== a && null !== (i = t.getPose(e.targetRaySpace, n)) && (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale)),
            null !== o && e.gripSpace && null !== (r = t.getPose(e.gripSpace, n)) && (o.matrix.fromArray(r.transform.matrix),
            o.matrix.decompose(o.position, o.rotation, o.scale))),
            null !== a && (a.visible = null !== i),
            null !== o && (o.visible = null !== r),
            this
        }
    }),
    Object.assign($i.prototype, r.prototype),
    Object.assign(nr.prototype, {
        isFogExp2: !0,
        clone: function() {
            return new nr(this.color,this.density)
        },
        toJSON: function() {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }),
    Object.assign(ir.prototype, {
        isFog: !0,
        clone: function() {
            return new ir(this.color,this.near,this.far)
        },
        toJSON: function() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }),
    Object.defineProperty(rr.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(rr.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setUsage: function(e) {
            return this.usage = e,
            this
        },
        copy: function(e) {
            return this.array = new e.array.constructor(e.array),
            this.count = e.count,
            this.stride = e.stride,
            this.usage = e.usage,
            this
        },
        copyAt: function(e, t, n) {
            e *= this.stride,
            n *= t.stride;
            for (var i = 0, r = this.stride; i < r; i++)
                this.array[e + i] = t.array[n + i];
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0),
            this.array.set(e, t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(e) {
            return this.onUploadCallback = e,
            this
        }
    });
    var ar, or = new b;
    function sr(e, t, n, i) {
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = n,
        this.normalized = !0 === i
    }
    function cr(e) {
        Ve.call(this),
        this.type = "SpriteMaterial",
        this.color = new ze(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.setValues(e)
    }
    Object.defineProperties(sr.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }),
    Object.assign(sr.prototype, {
        isInterleavedBufferAttribute: !0,
        applyMatrix4: function(e) {
            for (var t = 0, n = this.data.count; t < n; t++)
                or.x = this.getX(t),
                or.y = this.getY(t),
                or.z = this.getZ(t),
                or.applyMatrix4(e),
                this.setXYZ(t, or.x, or.y, or.z);
            return this
        },
        setX: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t,
            this
        },
        setY: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t,
            this
        },
        setZ: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t,
            this
        },
        setW: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t,
            this
        },
        getX: function(e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function(e, t, n) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = n,
            this
        },
        setXYZ: function(e, t, n, i) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = n,
            this.data.array[e + 2] = i,
            this
        },
        setXYZW: function(e, t, n, i, r) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = n,
            this.data.array[e + 2] = i,
            this.data.array[e + 3] = r,
            this
        },
        clone: function() {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            for (var e = [], t = 0; t < this.count; t++)
                for (var n = t * this.data.stride + this.offset, i = 0; i < this.itemSize; i++)
                    e.push(this.data.array[n + i]);
            return new qe(new this.array.constructor(e),this.itemSize,this.normalized)
        },
        toJSON: function() {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            for (var e = [], t = 0; t < this.count; t++)
                for (var n = t * this.data.stride + this.offset, i = 0; i < this.itemSize; i++)
                    e.push(this.data.array[n + i]);
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: e,
                normalized: this.normalized
            }
        }
    }),
    cr.prototype = Object.create(Ve.prototype),
    cr.prototype.constructor = cr,
    cr.prototype.isSpriteMaterial = !0,
    cr.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this
    }
    ;
    var hr = new b
      , lr = new b
      , ur = new b
      , pr = new h
      , dr = new h
      , fr = new L
      , mr = new b
      , vr = new b
      , gr = new b
      , yr = new h
      , xr = new h
      , br = new h;
    function _r(e) {
        if (q.call(this),
        this.type = "Sprite",
        void 0 === ar) {
            ar = new ut;
            var t = new rr(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),5);
            ar.setIndex([0, 1, 2, 0, 2, 3]),
            ar.setAttribute("position", new sr(t,3,0,!1)),
            ar.setAttribute("uv", new sr(t,2,3,!1))
        }
        this.geometry = ar,
        this.material = void 0 !== e ? e : new cr,
        this.center = new h(.5,.5)
    }
    function wr(e, t, n, i, r, a) {
        pr.subVectors(e, n).addScalar(.5).multiply(i),
        void 0 !== r ? (dr.x = a * pr.x - r * pr.y,
        dr.y = r * pr.x + a * pr.y) : dr.copy(pr),
        e.copy(t),
        e.x += dr.x,
        e.y += dr.y,
        e.applyMatrix4(fr)
    }
    _r.prototype = Object.assign(Object.create(q.prototype), {
        constructor: _r,
        isSprite: !0,
        raycast: function(e, t) {
            null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
            lr.setFromMatrixScale(this.matrixWorld),
            fr.copy(e.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
            ur.setFromMatrixPosition(this.modelViewMatrix),
            e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && lr.multiplyScalar(-ur.z);
            var n, i, r = this.material.rotation;
            0 !== r && (i = Math.cos(r),
            n = Math.sin(r));
            var a = this.center;
            wr(mr.set(-.5, -.5, 0), ur, a, lr, n, i),
            wr(vr.set(.5, -.5, 0), ur, a, lr, n, i),
            wr(gr.set(.5, .5, 0), ur, a, lr, n, i),
            yr.set(0, 0),
            xr.set(1, 0),
            br.set(1, 1);
            var o = e.ray.intersectTriangle(mr, vr, gr, !1, hr);
            if (null !== o || (wr(vr.set(-.5, .5, 0), ur, a, lr, n, i),
            xr.set(0, 1),
            null !== (o = e.ray.intersectTriangle(mr, gr, vr, !1, hr)))) {
                var s = e.ray.origin.distanceTo(hr);
                s < e.near || s > e.far || t.push({
                    distance: s,
                    point: hr.clone(),
                    uv: Ie.getUV(hr, mr, vr, gr, yr, xr, br, new h),
                    face: null,
                    object: this
                })
            }
        },
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(e) {
            return q.prototype.copy.call(this, e),
            void 0 !== e.center && this.center.copy(e.center),
            this
        }
    });
    var Mr, Sr, Tr, Er, Ar, Lr = new b, Rr = new b;
    function Pr() {
        q.call(this),
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        }),
        this.autoUpdate = !0
    }
    function Cr(e, t) {
        e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),
        Rt.call(this, e, t),
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new L,
        this.bindMatrixInverse = new L
    }
    Pr.prototype = Object.assign(Object.create(q.prototype), {
        constructor: Pr,
        isLOD: !0,
        copy: function(e) {
            q.prototype.copy.call(this, e, !1);
            for (var t = e.levels, n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                this.addLevel(r.object.clone(), r.distance)
            }
            return this.autoUpdate = e.autoUpdate,
            this
        },
        addLevel: function(e, t) {
            void 0 === t && (t = 0),
            t = Math.abs(t);
            for (var n = this.levels, i = 0; i < n.length && !(t < n[i].distance); i++)
                ;
            return n.splice(i, 0, {
                distance: t,
                object: e
            }),
            this.add(e),
            this
        },
        getCurrentLevel: function() {
            return this._currentLevel
        },
        getObjectForDistance: function(e) {
            var t = this.levels;
            if (t.length > 0) {
                for (var n = 1, i = t.length; n < i && !(e < t[n].distance); n++)
                    ;
                return t[n - 1].object
            }
            return null
        },
        raycast: function(e, t) {
            if (this.levels.length > 0) {
                Lr.setFromMatrixPosition(this.matrixWorld);
                var n = e.ray.origin.distanceTo(Lr);
                this.getObjectForDistance(n).raycast(e, t)
            }
        },
        update: function(e) {
            var t = this.levels;
            if (t.length > 1) {
                Lr.setFromMatrixPosition(e.matrixWorld),
                Rr.setFromMatrixPosition(this.matrixWorld);
                var n = Lr.distanceTo(Rr) / e.zoom;
                t[0].object.visible = !0;
                for (var i = 1, r = t.length; i < r && n >= t[i].distance; i++)
                    t[i - 1].object.visible = !1,
                    t[i].object.visible = !0;
                for (this._currentLevel = i - 1; i < r; i++)
                    t[i].object.visible = !1
            }
        },
        toJSON: function(e) {
            var t = q.prototype.toJSON.call(this, e);
            !1 === this.autoUpdate && (t.object.autoUpdate = !1),
            t.object.levels = [];
            for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
                var a = n[i];
                t.object.levels.push({
                    object: a.object.uuid,
                    distance: a.distance
                })
            }
            return t
        }
    }),
    Cr.prototype = Object.assign(Object.create(Rt.prototype), {
        constructor: Cr,
        isSkinnedMesh: !0,
        bind: function(e, t) {
            this.skeleton = e,
            void 0 === t && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            t = this.matrixWorld),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.getInverse(t)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            for (var e = new f, t = this.geometry.attributes.skinWeight, n = 0, i = t.count; n < i; n++) {
                e.x = t.getX(n),
                e.y = t.getY(n),
                e.z = t.getZ(n),
                e.w = t.getW(n);
                var r = 1 / e.manhattanLength();
                r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
                t.setXYZW(n, e.x, e.y, e.z, e.w)
            }
        },
        updateMatrixWorld: function(e) {
            Rt.prototype.updateMatrixWorld.call(this, e),
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        },
        boneTransform: (Mr = new b,
        Sr = new f,
        Tr = new f,
        Er = new b,
        Ar = new L,
        function(e, t) {
            var n = this.skeleton
              , i = this.geometry;
            Sr.fromBufferAttribute(i.attributes.skinIndex, e),
            Tr.fromBufferAttribute(i.attributes.skinWeight, e),
            Mr.fromBufferAttribute(i.attributes.position, e).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
            for (var r = 0; r < 4; r++) {
                var a = Tr.getComponent(r);
                if (0 !== a) {
                    var o = Sr.getComponent(r);
                    Ar.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]),
                    t.addScaledVector(Er.copy(Mr).applyMatrix4(Ar), a)
                }
            }
            return t.applyMatrix4(this.bindMatrixInverse)
        }
        )
    });
    var Or = new L
      , Ir = new L;
    function Dr(e, t) {
        if (e = e || [],
        this.bones = e.slice(0),
        this.boneMatrices = new Float32Array(16 * this.bones.length),
        this.frame = -1,
        void 0 === t)
            this.calculateInverses();
        else if (this.bones.length === t.length)
            this.boneInverses = t.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."),
            this.boneInverses = [];
            for (var n = 0, i = this.bones.length; n < i; n++)
                this.boneInverses.push(new L)
        }
    }
    function Nr() {
        q.call(this),
        this.type = "Bone"
    }
    Object.assign(Dr.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var n = new L;
                this.bones[e] && n.getInverse(this.bones[e].matrixWorld),
                this.boneInverses.push(n)
            }
        },
        pose: function() {
            var e, t, n;
            for (t = 0,
            n = this.bones.length; t < n; t++)
                (e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
            for (t = 0,
            n = this.bones.length; t < n; t++)
                (e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld),
                e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale))
        },
        update: function() {
            for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture, r = 0, a = e.length; r < a; r++) {
                var o = e[r] ? e[r].matrixWorld : Ir;
                Or.multiplyMatrices(o, t[r]),
                Or.toArray(n, 16 * r)
            }
            void 0 !== i && (i.needsUpdate = !0)
        },
        clone: function() {
            return new Dr(this.bones,this.boneInverses)
        },
        getBoneByName: function(e) {
            for (var t = 0, n = this.bones.length; t < n; t++) {
                var i = this.bones[t];
                if (i.name === e)
                    return i
            }
        },
        dispose: function() {
            this.boneTexture && (this.boneTexture.dispose(),
            this.boneTexture = void 0)
        }
    }),
    Nr.prototype = Object.assign(Object.create(q.prototype), {
        constructor: Nr,
        isBone: !0
    });
    var Ur = new L
      , zr = new L
      , Br = []
      , Fr = new Rt;
    function Hr(e, t, n) {
        Rt.call(this, e, t),
        this.instanceMatrix = new qe(new Float32Array(16 * n),16),
        this.count = n,
        this.frustumCulled = !1
    }
    function kr(e) {
        Ve.call(this),
        this.type = "LineBasicMaterial",
        this.color = new ze(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.morphTargets = !1,
        this.setValues(e)
    }
    Hr.prototype = Object.assign(Object.create(Rt.prototype), {
        constructor: Hr,
        isInstancedMesh: !0,
        getMatrixAt: function(e, t) {
            t.fromArray(this.instanceMatrix.array, 16 * e)
        },
        raycast: function(e, t) {
            var n = this.matrixWorld
              , i = this.count;
            if (Fr.geometry = this.geometry,
            Fr.material = this.material,
            void 0 !== Fr.material)
                for (var r = 0; r < i; r++) {
                    this.getMatrixAt(r, Ur),
                    zr.multiplyMatrices(n, Ur),
                    Fr.matrixWorld = zr,
                    Fr.raycast(e, Br);
                    for (var a = 0, o = Br.length; a < o; a++) {
                        var s = Br[a];
                        s.instanceId = r,
                        s.object = this,
                        t.push(s)
                    }
                    Br.length = 0
                }
        },
        setMatrixAt: function(e, t) {
            t.toArray(this.instanceMatrix.array, 16 * e)
        },
        updateMorphTargets: function() {}
    }),
    kr.prototype = Object.create(Ve.prototype),
    kr.prototype.constructor = kr,
    kr.prototype.isLineBasicMaterial = !0,
    kr.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.morphTargets = e.morphTargets,
        this
    }
    ;
    var Gr = new b
      , Vr = new b
      , jr = new L
      , Wr = new ye
      , qr = new le;
    function Xr(e, t, n) {
        1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."),
        q.call(this),
        this.type = "Line",
        this.geometry = void 0 !== e ? e : new ut,
        this.material = void 0 !== t ? t : new kr,
        this.updateMorphTargets()
    }
    Xr.prototype = Object.assign(Object.create(q.prototype), {
        constructor: Xr,
        isLine: !0,
        computeLineDistances: function() {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, n = [0], i = 1, r = t.count; i < r; i++)
                        Gr.fromBufferAttribute(t, i - 1),
                        Vr.fromBufferAttribute(t, i),
                        n[i] = n[i - 1],
                        n[i] += Gr.distanceTo(Vr);
                    e.setAttribute("lineDistance", new et(n,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (e.isGeometry) {
                var a = e.vertices;
                (n = e.lineDistances)[0] = 0;
                for (i = 1,
                r = a.length; i < r; i++)
                    n[i] = n[i - 1],
                    n[i] += a[i - 1].distanceTo(a[i])
            }
            return this
        },
        raycast: function(e, t) {
            var n = this.geometry
              , i = this.matrixWorld
              , r = e.params.Line.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            qr.copy(n.boundingSphere),
            qr.applyMatrix4(i),
            qr.radius += r,
            !1 !== e.ray.intersectsSphere(qr)) {
                jr.getInverse(i),
                Wr.copy(e.ray).applyMatrix4(jr);
                var a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , o = a * a
                  , s = new b
                  , c = new b
                  , h = new b
                  , l = new b
                  , u = this && this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    var p = n.index
                      , d = n.attributes.position.array;
                    if (null !== p)
                        for (var f = p.array, m = 0, v = f.length - 1; m < v; m += u) {
                            var g = f[m]
                              , y = f[m + 1];
                            if (s.fromArray(d, 3 * g),
                            c.fromArray(d, 3 * y),
                            !(Wr.distanceSqToSegment(s, c, l, h) > o))
                                l.applyMatrix4(this.matrixWorld),
                                (w = e.ray.origin.distanceTo(l)) < e.near || w > e.far || t.push({
                                    distance: w,
                                    point: h.clone().applyMatrix4(this.matrixWorld),
                                    index: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                        }
                    else
                        for (m = 0,
                        v = d.length / 3 - 1; m < v; m += u) {
                            if (s.fromArray(d, 3 * m),
                            c.fromArray(d, 3 * m + 3),
                            !(Wr.distanceSqToSegment(s, c, l, h) > o))
                                l.applyMatrix4(this.matrixWorld),
                                (w = e.ray.origin.distanceTo(l)) < e.near || w > e.far || t.push({
                                    distance: w,
                                    point: h.clone().applyMatrix4(this.matrixWorld),
                                    index: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                        }
                } else if (n.isGeometry) {
                    var x = n.vertices
                      , _ = x.length;
                    for (m = 0; m < _ - 1; m += u) {
                        var w;
                        if (!(Wr.distanceSqToSegment(x[m], x[m + 1], l, h) > o))
                            l.applyMatrix4(this.matrixWorld),
                            (w = e.ray.origin.distanceTo(l)) < e.near || w > e.far || t.push({
                                distance: w,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: m,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                    }
                }
            }
        },
        updateMorphTargets: function() {
            var e, t, n, i = this.geometry;
            if (i.isBufferGeometry) {
                var r = i.morphAttributes
                  , a = Object.keys(r);
                if (a.length > 0) {
                    var o = r[a[0]];
                    if (void 0 !== o)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        e = 0,
                        t = o.length; e < t; e++)
                            n = o[e].name || String(e),
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                }
            } else {
                var s = i.morphTargets;
                void 0 !== s && s.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    });
    var Yr = new b
      , Zr = new b;
    function Jr(e, t) {
        Xr.call(this, e, t),
        this.type = "LineSegments"
    }
    function Kr(e, t) {
        Xr.call(this, e, t),
        this.type = "LineLoop"
    }
    function Qr(e) {
        Ve.call(this),
        this.type = "PointsMaterial",
        this.color = new ze(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.morphTargets = !1,
        this.setValues(e)
    }
    Jr.prototype = Object.assign(Object.create(Xr.prototype), {
        constructor: Jr,
        isLineSegments: !0,
        computeLineDistances: function() {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, n = [], i = 0, r = t.count; i < r; i += 2)
                        Yr.fromBufferAttribute(t, i),
                        Zr.fromBufferAttribute(t, i + 1),
                        n[i] = 0 === i ? 0 : n[i - 1],
                        n[i + 1] = n[i] + Yr.distanceTo(Zr);
                    e.setAttribute("lineDistance", new et(n,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (e.isGeometry) {
                var a = e.vertices;
                for (n = e.lineDistances,
                i = 0,
                r = a.length; i < r; i += 2)
                    Yr.copy(a[i]),
                    Zr.copy(a[i + 1]),
                    n[i] = 0 === i ? 0 : n[i - 1],
                    n[i + 1] = n[i] + Yr.distanceTo(Zr)
            }
            return this
        }
    }),
    Kr.prototype = Object.assign(Object.create(Xr.prototype), {
        constructor: Kr,
        isLineLoop: !0
    }),
    Qr.prototype = Object.create(Ve.prototype),
    Qr.prototype.constructor = Qr,
    Qr.prototype.isPointsMaterial = !0,
    Qr.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.morphTargets = e.morphTargets,
        this
    }
    ;
    var $r = new L
      , ea = new ye
      , ta = new le
      , na = new b;
    function ia(e, t) {
        q.call(this),
        this.type = "Points",
        this.geometry = void 0 !== e ? e : new ut,
        this.material = void 0 !== t ? t : new Qr,
        this.updateMorphTargets()
    }
    function ra(e, t, n, i, r, a, o) {
        var s = ea.distanceSqToPoint(e);
        if (s < n) {
            var c = new b;
            ea.closestPointToPoint(e, c),
            c.applyMatrix4(i);
            var h = r.ray.origin.distanceTo(c);
            if (h < r.near || h > r.far)
                return;
            a.push({
                distance: h,
                distanceToRay: Math.sqrt(s),
                point: c,
                index: t,
                face: null,
                object: o
            })
        }
    }
    function aa(e, t, n, i, r, a, o, s, c) {
        d.call(this, e, t, n, i, r, a, o, s, c),
        this.format = void 0 !== o ? o : 1022,
        this.minFilter = void 0 !== a ? a : 1006,
        this.magFilter = void 0 !== r ? r : 1006,
        this.generateMipmaps = !1
    }
    function oa(e, t, n, i, r, a, o, s, c, h, l, u) {
        d.call(this, null, a, o, s, c, h, i, r, l, u),
        this.image = {
            width: t,
            height: n
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function sa(e, t, n, i, r, a, o, s, c) {
        d.call(this, e, t, n, i, r, a, o, s, c),
        this.needsUpdate = !0
    }
    function ca(e, t, n, i, r, a, o, s, c, h) {
        if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && 1026 === h && (n = 1012),
        void 0 === n && 1027 === h && (n = 1020),
        d.call(this, null, i, r, a, o, s, h, n, c),
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = void 0 !== o ? o : 1003,
        this.minFilter = void 0 !== s ? s : 1003,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function ha(e) {
        ut.call(this),
        this.type = "WireframeGeometry";
        var t, n, i, r, a, o, s, c, h, l, u = [], p = [0, 0], d = {}, f = ["a", "b", "c"];
        if (e && e.isGeometry) {
            var m = e.faces;
            for (t = 0,
            i = m.length; t < i; t++) {
                var v = m[t];
                for (n = 0; n < 3; n++)
                    s = v[f[n]],
                    c = v[f[(n + 1) % 3]],
                    p[0] = Math.min(s, c),
                    p[1] = Math.max(s, c),
                    void 0 === d[h = p[0] + "," + p[1]] && (d[h] = {
                        index1: p[0],
                        index2: p[1]
                    })
            }
            for (h in d)
                o = d[h],
                l = e.vertices[o.index1],
                u.push(l.x, l.y, l.z),
                l = e.vertices[o.index2],
                u.push(l.x, l.y, l.z)
        } else if (e && e.isBufferGeometry) {
            var g, y, x, _, w, M, S;
            if (l = new b,
            null !== e.index) {
                for (g = e.attributes.position,
                y = e.index,
                0 === (x = e.groups).length && (x = [{
                    start: 0,
                    count: y.count,
                    materialIndex: 0
                }]),
                r = 0,
                a = x.length; r < a; ++r)
                    for (t = w = (_ = x[r]).start,
                    i = w + _.count; t < i; t += 3)
                        for (n = 0; n < 3; n++)
                            s = y.getX(t + n),
                            c = y.getX(t + (n + 1) % 3),
                            p[0] = Math.min(s, c),
                            p[1] = Math.max(s, c),
                            void 0 === d[h = p[0] + "," + p[1]] && (d[h] = {
                                index1: p[0],
                                index2: p[1]
                            });
                for (h in d)
                    o = d[h],
                    l.fromBufferAttribute(g, o.index1),
                    u.push(l.x, l.y, l.z),
                    l.fromBufferAttribute(g, o.index2),
                    u.push(l.x, l.y, l.z)
            } else
                for (t = 0,
                i = (g = e.attributes.position).count / 3; t < i; t++)
                    for (n = 0; n < 3; n++)
                        M = 3 * t + n,
                        l.fromBufferAttribute(g, M),
                        u.push(l.x, l.y, l.z),
                        S = 3 * t + (n + 1) % 3,
                        l.fromBufferAttribute(g, S),
                        u.push(l.x, l.y, l.z)
        }
        this.setAttribute("position", new et(u,3))
    }
    function la(e, t, n) {
        Ut.call(this),
        this.type = "ParametricGeometry",
        this.parameters = {
            func: e,
            slices: t,
            stacks: n
        },
        this.fromBufferGeometry(new ua(e,t,n)),
        this.mergeVertices()
    }
    function ua(e, t, n) {
        ut.call(this),
        this.type = "ParametricBufferGeometry",
        this.parameters = {
            func: e,
            slices: t,
            stacks: n
        };
        var i, r, a = [], o = [], s = [], c = [], h = 1e-5, l = new b, u = new b, p = new b, d = new b, f = new b;
        e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var m = t + 1;
        for (i = 0; i <= n; i++) {
            var v = i / n;
            for (r = 0; r <= t; r++) {
                var g = r / t;
                e(g, v, u),
                o.push(u.x, u.y, u.z),
                g - h >= 0 ? (e(g - h, v, p),
                d.subVectors(u, p)) : (e(g + h, v, p),
                d.subVectors(p, u)),
                v - h >= 0 ? (e(g, v - h, p),
                f.subVectors(u, p)) : (e(g, v + h, p),
                f.subVectors(p, u)),
                l.crossVectors(d, f).normalize(),
                s.push(l.x, l.y, l.z),
                c.push(g, v)
            }
        }
        for (i = 0; i < n; i++)
            for (r = 0; r < t; r++) {
                var y = i * m + r
                  , x = i * m + r + 1
                  , _ = (i + 1) * m + r + 1
                  , w = (i + 1) * m + r;
                a.push(y, x, w),
                a.push(x, _, w)
            }
        this.setIndex(a),
        this.setAttribute("position", new et(o,3)),
        this.setAttribute("normal", new et(s,3)),
        this.setAttribute("uv", new et(c,2))
    }
    function pa(e, t, n, i) {
        Ut.call(this),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: i
        },
        this.fromBufferGeometry(new da(e,t,n,i)),
        this.mergeVertices()
    }
    function da(e, t, n, i) {
        ut.call(this),
        this.type = "PolyhedronBufferGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: i
        },
        n = n || 1;
        var r = []
          , a = [];
        function o(e, t, n, i) {
            var r, a, o = Math.pow(2, i), c = [];
            for (r = 0; r <= o; r++) {
                c[r] = [];
                var h = e.clone().lerp(n, r / o)
                  , l = t.clone().lerp(n, r / o)
                  , u = o - r;
                for (a = 0; a <= u; a++)
                    c[r][a] = 0 === a && r === o ? h : h.clone().lerp(l, a / u)
            }
            for (r = 0; r < o; r++)
                for (a = 0; a < 2 * (o - r) - 1; a++) {
                    var p = Math.floor(a / 2);
                    a % 2 == 0 ? (s(c[r][p + 1]),
                    s(c[r + 1][p]),
                    s(c[r][p])) : (s(c[r][p + 1]),
                    s(c[r + 1][p + 1]),
                    s(c[r + 1][p]))
                }
        }
        function s(e) {
            r.push(e.x, e.y, e.z)
        }
        function c(t, n) {
            var i = 3 * t;
            n.x = e[i + 0],
            n.y = e[i + 1],
            n.z = e[i + 2]
        }
        function l(e, t, n, i) {
            i < 0 && 1 === e.x && (a[t] = e.x - 1),
            0 === n.x && 0 === n.z && (a[t] = i / 2 / Math.PI + .5)
        }
        function u(e) {
            return Math.atan2(e.z, -e.x)
        }
        function p(e) {
            return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z))
        }
        !function(e) {
            for (var n = new b, i = new b, r = new b, a = 0; a < t.length; a += 3)
                c(t[a + 0], n),
                c(t[a + 1], i),
                c(t[a + 2], r),
                o(n, i, r, e)
        }(i = i || 0),
        function(e) {
            for (var t = new b, n = 0; n < r.length; n += 3)
                t.x = r[n + 0],
                t.y = r[n + 1],
                t.z = r[n + 2],
                t.normalize().multiplyScalar(e),
                r[n + 0] = t.x,
                r[n + 1] = t.y,
                r[n + 2] = t.z
        }(n),
        function() {
            for (var e = new b, t = 0; t < r.length; t += 3) {
                e.x = r[t + 0],
                e.y = r[t + 1],
                e.z = r[t + 2];
                var n = u(e) / 2 / Math.PI + .5
                  , i = p(e) / Math.PI + .5;
                a.push(n, 1 - i)
            }
            (function() {
                for (var e = new b, t = new b, n = new b, i = new b, o = new h, s = new h, c = new h, p = 0, d = 0; p < r.length; p += 9,
                d += 6) {
                    e.set(r[p + 0], r[p + 1], r[p + 2]),
                    t.set(r[p + 3], r[p + 4], r[p + 5]),
                    n.set(r[p + 6], r[p + 7], r[p + 8]),
                    o.set(a[d + 0], a[d + 1]),
                    s.set(a[d + 2], a[d + 3]),
                    c.set(a[d + 4], a[d + 5]),
                    i.copy(e).add(t).add(n).divideScalar(3);
                    var f = u(i);
                    l(o, d + 0, e, f),
                    l(s, d + 2, t, f),
                    l(c, d + 4, n, f)
                }
            }
            )(),
            function() {
                for (var e = 0; e < a.length; e += 6) {
                    var t = a[e + 0]
                      , n = a[e + 2]
                      , i = a[e + 4]
                      , r = Math.max(t, n, i)
                      , o = Math.min(t, n, i);
                    r > .9 && o < .1 && (t < .2 && (a[e + 0] += 1),
                    n < .2 && (a[e + 2] += 1),
                    i < .2 && (a[e + 4] += 1))
                }
            }()
        }(),
        this.setAttribute("position", new et(r,3)),
        this.setAttribute("normal", new et(r.slice(),3)),
        this.setAttribute("uv", new et(a,2)),
        0 === i ? this.computeVertexNormals() : this.normalizeNormals()
    }
    function fa(e, t) {
        Ut.call(this),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new ma(e,t)),
        this.mergeVertices()
    }
    function ma(e, t) {
        da.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t),
        this.type = "TetrahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function va(e, t) {
        Ut.call(this),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new ga(e,t)),
        this.mergeVertices()
    }
    function ga(e, t) {
        da.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t),
        this.type = "OctahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function ya(e, t) {
        Ut.call(this),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new xa(e,t)),
        this.mergeVertices()
    }
    function xa(e, t) {
        var n = (1 + Math.sqrt(5)) / 2
          , i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
        da.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t),
        this.type = "IcosahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function ba(e, t) {
        Ut.call(this),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new _a(e,t)),
        this.mergeVertices()
    }
    function _a(e, t) {
        var n = (1 + Math.sqrt(5)) / 2
          , i = 1 / n
          , r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i];
        da.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t),
        this.type = "DodecahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function wa(e, t, n, i, r, a) {
        Ut.call(this),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: i,
            closed: r
        },
        void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed.");
        var o = new Ma(e,t,n,i,r);
        this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals,
        this.fromBufferGeometry(o),
        this.mergeVertices()
    }
    function Ma(e, t, n, i, r) {
        ut.call(this),
        this.type = "TubeBufferGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: i,
            closed: r
        },
        t = t || 64,
        n = n || 1,
        i = i || 8,
        r = r || !1;
        var a = e.computeFrenetFrames(t, r);
        this.tangents = a.tangents,
        this.normals = a.normals,
        this.binormals = a.binormals;
        var o, s, c = new b, l = new b, u = new h, p = new b, d = [], f = [], m = [], v = [];
        function g(r) {
            p = e.getPointAt(r / t, p);
            var o = a.normals[r]
              , h = a.binormals[r];
            for (s = 0; s <= i; s++) {
                var u = s / i * Math.PI * 2
                  , m = Math.sin(u)
                  , v = -Math.cos(u);
                l.x = v * o.x + m * h.x,
                l.y = v * o.y + m * h.y,
                l.z = v * o.z + m * h.z,
                l.normalize(),
                f.push(l.x, l.y, l.z),
                c.x = p.x + n * l.x,
                c.y = p.y + n * l.y,
                c.z = p.z + n * l.z,
                d.push(c.x, c.y, c.z)
            }
        }
        !function() {
            for (o = 0; o < t; o++)
                g(o);
            g(!1 === r ? t : 0),
            function() {
                for (o = 0; o <= t; o++)
                    for (s = 0; s <= i; s++)
                        u.x = o / t,
                        u.y = s / i,
                        m.push(u.x, u.y)
            }(),
            function() {
                for (s = 1; s <= t; s++)
                    for (o = 1; o <= i; o++) {
                        var e = (i + 1) * (s - 1) + (o - 1)
                          , n = (i + 1) * s + (o - 1)
                          , r = (i + 1) * s + o
                          , a = (i + 1) * (s - 1) + o;
                        v.push(e, n, a),
                        v.push(n, r, a)
                    }
            }()
        }(),
        this.setIndex(v),
        this.setAttribute("position", new et(d,3)),
        this.setAttribute("normal", new et(f,3)),
        this.setAttribute("uv", new et(m,2))
    }
    function Sa(e, t, n, i, r, a, o) {
        Ut.call(this),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: a
        },
        void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
        this.fromBufferGeometry(new Ta(e,t,n,i,r,a)),
        this.mergeVertices()
    }
    function Ta(e, t, n, i, r, a) {
        ut.call(this),
        this.type = "TorusKnotBufferGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: a
        },
        e = e || 1,
        t = t || .4,
        n = Math.floor(n) || 64,
        i = Math.floor(i) || 8,
        r = r || 2,
        a = a || 3;
        var o, s, c = [], h = [], l = [], u = [], p = new b, d = new b, f = new b, m = new b, v = new b, g = new b, y = new b;
        for (o = 0; o <= n; ++o) {
            var x = o / n * r * Math.PI * 2;
            for (L(x, r, a, e, f),
            L(x + .01, r, a, e, m),
            g.subVectors(m, f),
            y.addVectors(m, f),
            v.crossVectors(g, y),
            y.crossVectors(v, g),
            v.normalize(),
            y.normalize(),
            s = 0; s <= i; ++s) {
                var _ = s / i * Math.PI * 2
                  , w = -t * Math.cos(_)
                  , M = t * Math.sin(_);
                p.x = f.x + (w * y.x + M * v.x),
                p.y = f.y + (w * y.y + M * v.y),
                p.z = f.z + (w * y.z + M * v.z),
                h.push(p.x, p.y, p.z),
                d.subVectors(p, f).normalize(),
                l.push(d.x, d.y, d.z),
                u.push(o / n),
                u.push(s / i)
            }
        }
        for (s = 1; s <= n; s++)
            for (o = 1; o <= i; o++) {
                var S = (i + 1) * (s - 1) + (o - 1)
                  , T = (i + 1) * s + (o - 1)
                  , E = (i + 1) * s + o
                  , A = (i + 1) * (s - 1) + o;
                c.push(S, T, A),
                c.push(T, E, A)
            }
        function L(e, t, n, i, r) {
            var a = Math.cos(e)
              , o = Math.sin(e)
              , s = n / t * e
              , c = Math.cos(s);
            r.x = i * (2 + c) * .5 * a,
            r.y = i * (2 + c) * o * .5,
            r.z = i * Math.sin(s) * .5
        }
        this.setIndex(c),
        this.setAttribute("position", new et(h,3)),
        this.setAttribute("normal", new et(l,3)),
        this.setAttribute("uv", new et(u,2))
    }
    function Ea(e, t, n, i, r) {
        Ut.call(this),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: i,
            arc: r
        },
        this.fromBufferGeometry(new Aa(e,t,n,i,r)),
        this.mergeVertices()
    }
    function Aa(e, t, n, i, r) {
        ut.call(this),
        this.type = "TorusBufferGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: i,
            arc: r
        },
        e = e || 1,
        t = t || .4,
        n = Math.floor(n) || 8,
        i = Math.floor(i) || 6,
        r = r || 2 * Math.PI;
        var a, o, s = [], c = [], h = [], l = [], u = new b, p = new b, d = new b;
        for (a = 0; a <= n; a++)
            for (o = 0; o <= i; o++) {
                var f = o / i * r
                  , m = a / n * Math.PI * 2;
                p.x = (e + t * Math.cos(m)) * Math.cos(f),
                p.y = (e + t * Math.cos(m)) * Math.sin(f),
                p.z = t * Math.sin(m),
                c.push(p.x, p.y, p.z),
                u.x = e * Math.cos(f),
                u.y = e * Math.sin(f),
                d.subVectors(p, u).normalize(),
                h.push(d.x, d.y, d.z),
                l.push(o / i),
                l.push(a / n)
            }
        for (a = 1; a <= n; a++)
            for (o = 1; o <= i; o++) {
                var v = (i + 1) * a + o - 1
                  , g = (i + 1) * (a - 1) + o - 1
                  , y = (i + 1) * (a - 1) + o
                  , x = (i + 1) * a + o;
                s.push(v, g, x),
                s.push(g, y, x)
            }
        this.setIndex(s),
        this.setAttribute("position", new et(c,3)),
        this.setAttribute("normal", new et(h,3)),
        this.setAttribute("uv", new et(l,2))
    }
    ia.prototype = Object.assign(Object.create(q.prototype), {
        constructor: ia,
        isPoints: !0,
        raycast: function(e, t) {
            var n = this.geometry
              , i = this.matrixWorld
              , r = e.params.Points.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            ta.copy(n.boundingSphere),
            ta.applyMatrix4(i),
            ta.radius += r,
            !1 !== e.ray.intersectsSphere(ta)) {
                $r.getInverse(i),
                ea.copy(e.ray).applyMatrix4($r);
                var a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , o = a * a;
                if (n.isBufferGeometry) {
                    var s = n.index
                      , c = n.attributes.position.array;
                    if (null !== s)
                        for (var h = s.array, l = 0, u = h.length; l < u; l++) {
                            var p = h[l];
                            na.fromArray(c, 3 * p),
                            ra(na, p, o, i, e, t, this)
                        }
                    else {
                        l = 0;
                        for (var d = c.length / 3; l < d; l++)
                            na.fromArray(c, 3 * l),
                            ra(na, l, o, i, e, t, this)
                    }
                } else {
                    var f = n.vertices;
                    for (l = 0,
                    d = f.length; l < d; l++)
                        ra(f[l], l, o, i, e, t, this)
                }
            }
        },
        updateMorphTargets: function() {
            var e, t, n, i = this.geometry;
            if (i.isBufferGeometry) {
                var r = i.morphAttributes
                  , a = Object.keys(r);
                if (a.length > 0) {
                    var o = r[a[0]];
                    if (void 0 !== o)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        e = 0,
                        t = o.length; e < t; e++)
                            n = o[e].name || String(e),
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                }
            } else {
                var s = i.morphTargets;
                void 0 !== s && s.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    aa.prototype = Object.assign(Object.create(d.prototype), {
        constructor: aa,
        isVideoTexture: !0,
        update: function() {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }),
    oa.prototype = Object.create(d.prototype),
    oa.prototype.constructor = oa,
    oa.prototype.isCompressedTexture = !0,
    sa.prototype = Object.create(d.prototype),
    sa.prototype.constructor = sa,
    sa.prototype.isCanvasTexture = !0,
    ca.prototype = Object.create(d.prototype),
    ca.prototype.constructor = ca,
    ca.prototype.isDepthTexture = !0,
    ha.prototype = Object.create(ut.prototype),
    ha.prototype.constructor = ha,
    la.prototype = Object.create(Ut.prototype),
    la.prototype.constructor = la,
    ua.prototype = Object.create(ut.prototype),
    ua.prototype.constructor = ua,
    pa.prototype = Object.create(Ut.prototype),
    pa.prototype.constructor = pa,
    da.prototype = Object.create(ut.prototype),
    da.prototype.constructor = da,
    fa.prototype = Object.create(Ut.prototype),
    fa.prototype.constructor = fa,
    ma.prototype = Object.create(da.prototype),
    ma.prototype.constructor = ma,
    va.prototype = Object.create(Ut.prototype),
    va.prototype.constructor = va,
    ga.prototype = Object.create(da.prototype),
    ga.prototype.constructor = ga,
    ya.prototype = Object.create(Ut.prototype),
    ya.prototype.constructor = ya,
    xa.prototype = Object.create(da.prototype),
    xa.prototype.constructor = xa,
    ba.prototype = Object.create(Ut.prototype),
    ba.prototype.constructor = ba,
    _a.prototype = Object.create(da.prototype),
    _a.prototype.constructor = _a,
    wa.prototype = Object.create(Ut.prototype),
    wa.prototype.constructor = wa,
    Ma.prototype = Object.create(ut.prototype),
    Ma.prototype.constructor = Ma,
    Ma.prototype.toJSON = function() {
        var e = ut.prototype.toJSON.call(this);
        return e.path = this.parameters.path.toJSON(),
        e
    }
    ,
    Sa.prototype = Object.create(Ut.prototype),
    Sa.prototype.constructor = Sa,
    Ta.prototype = Object.create(ut.prototype),
    Ta.prototype.constructor = Ta,
    Ea.prototype = Object.create(Ut.prototype),
    Ea.prototype.constructor = Ea,
    Aa.prototype = Object.create(ut.prototype),
    Aa.prototype.constructor = Aa;
    var La = function(e, t, n) {
        n = n || 2;
        var i, r, a, o, s, c, h, l = t && t.length, u = l ? t[0] * n : e.length, p = Ra(e, 0, u, n, !0), d = [];
        if (!p || p.next === p.prev)
            return d;
        if (l && (p = function(e, t, n, i) {
            var r, a, o, s, c, h = [];
            for (r = 0,
            a = t.length; r < a; r++)
                o = t[r] * i,
                s = r < a - 1 ? t[r + 1] * i : e.length,
                (c = Ra(e, o, s, i, !1)) === c.next && (c.steiner = !0),
                h.push(Ha(c));
            for (h.sort(Ua),
            r = 0; r < h.length; r++)
                za(h[r], n),
                n = Pa(n, n.next);
            return n
        }(e, t, p, n)),
        e.length > 80 * n) {
            i = a = e[0],
            r = o = e[1];
            for (var f = n; f < u; f += n)
                (s = e[f]) < i && (i = s),
                (c = e[f + 1]) < r && (r = c),
                s > a && (a = s),
                c > o && (o = c);
            h = 0 !== (h = Math.max(a - i, o - r)) ? 1 / h : 0
        }
        return Ca(p, d, n, i, r, h),
        d
    };
    function Ra(e, t, n, i, r) {
        var a, o;
        if (r === function(e, t, n, i) {
            for (var r = 0, a = t, o = n - i; a < n; a += i)
                r += (e[o] - e[a]) * (e[a + 1] + e[o + 1]),
                o = a;
            return r
        }(e, t, n, i) > 0)
            for (a = t; a < n; a += i)
                o = Ja(a, e[a], e[a + 1], o);
        else
            for (a = n - i; a >= t; a -= i)
                o = Ja(a, e[a], e[a + 1], o);
        return o && ja(o, o.next) && (Ka(o),
        o = o.next),
        o
    }
    function Pa(e, t) {
        if (!e)
            return e;
        t || (t = e);
        var n, i = e;
        do {
            if (n = !1,
            i.steiner || !ja(i, i.next) && 0 !== Va(i.prev, i, i.next))
                i = i.next;
            else {
                if (Ka(i),
                (i = t = i.prev) === i.next)
                    break;
                n = !0
            }
        } while (n || i !== t);
        return t
    }
    function Ca(e, t, n, i, r, a, o) {
        if (e) {
            !o && a && function(e, t, n, i) {
                var r = e;
                do {
                    null === r.z && (r.z = Fa(r.x, r.y, t, n, i)),
                    r.prevZ = r.prev,
                    r.nextZ = r.next,
                    r = r.next
                } while (r !== e);
                r.prevZ.nextZ = null,
                r.prevZ = null,
                function(e) {
                    var t, n, i, r, a, o, s, c, h = 1;
                    do {
                        for (n = e,
                        e = null,
                        a = null,
                        o = 0; n; ) {
                            for (o++,
                            i = n,
                            s = 0,
                            t = 0; t < h && (s++,
                            i = i.nextZ); t++)
                                ;
                            for (c = h; s > 0 || c > 0 && i; )
                                0 !== s && (0 === c || !i || n.z <= i.z) ? (r = n,
                                n = n.nextZ,
                                s--) : (r = i,
                                i = i.nextZ,
                                c--),
                                a ? a.nextZ = r : e = r,
                                r.prevZ = a,
                                a = r;
                            n = i
                        }
                        a.nextZ = null,
                        h *= 2
                    } while (o > 1)
                }(r)
            }(e, i, r, a);
            for (var s, c, h = e; e.prev !== e.next; )
                if (s = e.prev,
                c = e.next,
                a ? Ia(e, i, r, a) : Oa(e))
                    t.push(s.i / n),
                    t.push(e.i / n),
                    t.push(c.i / n),
                    Ka(e),
                    e = c.next,
                    h = c.next;
                else if ((e = c) === h) {
                    o ? 1 === o ? Ca(e = Da(Pa(e), t, n), t, n, i, r, a, 2) : 2 === o && Na(e, t, n, i, r, a) : Ca(Pa(e), t, n, i, r, a, 1);
                    break
                }
        }
    }
    function Oa(e) {
        var t = e.prev
          , n = e
          , i = e.next;
        if (Va(t, n, i) >= 0)
            return !1;
        for (var r = e.next.next; r !== e.prev; ) {
            if (ka(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && Va(r.prev, r, r.next) >= 0)
                return !1;
            r = r.next
        }
        return !0
    }
    function Ia(e, t, n, i) {
        var r = e.prev
          , a = e
          , o = e.next;
        if (Va(r, a, o) >= 0)
            return !1;
        for (var s = r.x < a.x ? r.x < o.x ? r.x : o.x : a.x < o.x ? a.x : o.x, c = r.y < a.y ? r.y < o.y ? r.y : o.y : a.y < o.y ? a.y : o.y, h = r.x > a.x ? r.x > o.x ? r.x : o.x : a.x > o.x ? a.x : o.x, l = r.y > a.y ? r.y > o.y ? r.y : o.y : a.y > o.y ? a.y : o.y, u = Fa(s, c, t, n, i), p = Fa(h, l, t, n, i), d = e.prevZ, f = e.nextZ; d && d.z >= u && f && f.z <= p; ) {
            if (d !== e.prev && d !== e.next && ka(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && Va(d.prev, d, d.next) >= 0)
                return !1;
            if (d = d.prevZ,
            f !== e.prev && f !== e.next && ka(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) && Va(f.prev, f, f.next) >= 0)
                return !1;
            f = f.nextZ
        }
        for (; d && d.z >= u; ) {
            if (d !== e.prev && d !== e.next && ka(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && Va(d.prev, d, d.next) >= 0)
                return !1;
            d = d.prevZ
        }
        for (; f && f.z <= p; ) {
            if (f !== e.prev && f !== e.next && ka(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) && Va(f.prev, f, f.next) >= 0)
                return !1;
            f = f.nextZ
        }
        return !0
    }
    function Da(e, t, n) {
        var i = e;
        do {
            var r = i.prev
              , a = i.next.next;
            !ja(r, a) && Wa(r, i, i.next, a) && Ya(r, a) && Ya(a, r) && (t.push(r.i / n),
            t.push(i.i / n),
            t.push(a.i / n),
            Ka(i),
            Ka(i.next),
            i = e = a),
            i = i.next
        } while (i !== e);
        return Pa(i)
    }
    function Na(e, t, n, i, r, a) {
        var o = e;
        do {
            for (var s = o.next.next; s !== o.prev; ) {
                if (o.i !== s.i && Ga(o, s)) {
                    var c = Za(o, s);
                    return o = Pa(o, o.next),
                    c = Pa(c, c.next),
                    Ca(o, t, n, i, r, a),
                    void Ca(c, t, n, i, r, a)
                }
                s = s.next
            }
            o = o.next
        } while (o !== e)
    }
    function Ua(e, t) {
        return e.x - t.x
    }
    function za(e, t) {
        if (t = function(e, t) {
            var n, i = t, r = e.x, a = e.y, o = -1 / 0;
            do {
                if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
                    var s = i.x + (a - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                    if (s <= r && s > o) {
                        if (o = s,
                        s === r) {
                            if (a === i.y)
                                return i;
                            if (a === i.next.y)
                                return i.next
                        }
                        n = i.x < i.next.x ? i : i.next
                    }
                }
                i = i.next
            } while (i !== t);
            if (!n)
                return null;
            if (r === o)
                return n;
            var c, h = n, l = n.x, u = n.y, p = 1 / 0;
            i = n;
            do {
                r >= i.x && i.x >= l && r !== i.x && ka(a < u ? r : o, a, l, u, a < u ? o : r, a, i.x, i.y) && (c = Math.abs(a - i.y) / (r - i.x),
                Ya(i, e) && (c < p || c === p && (i.x > n.x || i.x === n.x && Ba(n, i))) && (n = i,
                p = c)),
                i = i.next
            } while (i !== h);
            return n
        }(e, t)) {
            var n = Za(t, e);
            Pa(t, t.next),
            Pa(n, n.next)
        }
    }
    function Ba(e, t) {
        return Va(e.prev, e, t.prev) < 0 && Va(t.next, e, e.next) < 0
    }
    function Fa(e, t, n, i, r) {
        return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }
    function Ha(e) {
        var t = e
          , n = e;
        do {
            (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t),
            t = t.next
        } while (t !== e);
        return n
    }
    function ka(e, t, n, i, r, a, o, s) {
        return (r - o) * (t - s) - (e - o) * (a - s) >= 0 && (e - o) * (i - s) - (n - o) * (t - s) >= 0 && (n - o) * (a - s) - (r - o) * (i - s) >= 0
    }
    function Ga(e, t) {
        return e.next.i !== t.i && e.prev.i !== t.i && !function(e, t) {
            var n = e;
            do {
                if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Wa(n, n.next, e, t))
                    return !0;
                n = n.next
            } while (n !== e);
            return !1
        }(e, t) && (Ya(e, t) && Ya(t, e) && function(e, t) {
            var n = e
              , i = !1
              , r = (e.x + t.x) / 2
              , a = (e.y + t.y) / 2;
            do {
                n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                n = n.next
            } while (n !== e);
            return i
        }(e, t) && (Va(e.prev, e, t.prev) || Va(e, t.prev, t)) || ja(e, t) && Va(e.prev, e, e.next) > 0 && Va(t.prev, t, t.next) > 0)
    }
    function Va(e, t, n) {
        return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
    }
    function ja(e, t) {
        return e.x === t.x && e.y === t.y
    }
    function Wa(e, t, n, i) {
        var r = Xa(Va(e, t, n))
          , a = Xa(Va(e, t, i))
          , o = Xa(Va(n, i, e))
          , s = Xa(Va(n, i, t));
        return r !== a && o !== s || (!(0 !== r || !qa(e, n, t)) || (!(0 !== a || !qa(e, i, t)) || (!(0 !== o || !qa(n, e, i)) || !(0 !== s || !qa(n, t, i)))))
    }
    function qa(e, t, n) {
        return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
    }
    function Xa(e) {
        return e > 0 ? 1 : e < 0 ? -1 : 0
    }
    function Ya(e, t) {
        return Va(e.prev, e, e.next) < 0 ? Va(e, t, e.next) >= 0 && Va(e, e.prev, t) >= 0 : Va(e, t, e.prev) < 0 || Va(e, e.next, t) < 0
    }
    function Za(e, t) {
        var n = new Qa(e.i,e.x,e.y)
          , i = new Qa(t.i,t.x,t.y)
          , r = e.next
          , a = t.prev;
        return e.next = t,
        t.prev = e,
        n.next = r,
        r.prev = n,
        i.next = n,
        n.prev = i,
        a.next = i,
        i.prev = a,
        i
    }
    function Ja(e, t, n, i) {
        var r = new Qa(e,t,n);
        return i ? (r.next = i.next,
        r.prev = i,
        i.next.prev = r,
        i.next = r) : (r.prev = r,
        r.next = r),
        r
    }
    function Ka(e) {
        e.next.prev = e.prev,
        e.prev.next = e.next,
        e.prevZ && (e.prevZ.nextZ = e.nextZ),
        e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }
    function Qa(e, t, n) {
        this.i = e,
        this.x = t,
        this.y = n,
        this.prev = null,
        this.next = null,
        this.z = null,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
    }
    var $a = {
        area: function(e) {
            for (var t = e.length, n = 0, i = t - 1, r = 0; r < t; i = r++)
                n += e[i].x * e[r].y - e[r].x * e[i].y;
            return .5 * n
        },
        isClockWise: function(e) {
            return $a.area(e) < 0
        },
        triangulateShape: function(e, t) {
            var n = []
              , i = []
              , r = [];
            eo(e),
            to(n, e);
            var a = e.length;
            t.forEach(eo);
            for (var o = 0; o < t.length; o++)
                i.push(a),
                a += t[o].length,
                to(n, t[o]);
            var s = La(n, i);
            for (o = 0; o < s.length; o += 3)
                r.push(s.slice(o, o + 3));
            return r
        }
    };
    function eo(e) {
        var t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop()
    }
    function to(e, t) {
        for (var n = 0; n < t.length; n++)
            e.push(t[n].x),
            e.push(t[n].y)
    }
    function no(e, t) {
        Ut.call(this),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        this.fromBufferGeometry(new io(e,t)),
        this.mergeVertices()
    }
    function io(e, t) {
        ut.call(this),
        this.type = "ExtrudeBufferGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        for (var n = this, i = [], r = [], a = 0, o = e.length; a < o; a++) {
            s(e[a])
        }
        function s(e) {
            var a = []
              , o = void 0 !== t.curveSegments ? t.curveSegments : 12
              , s = void 0 !== t.steps ? t.steps : 1
              , c = void 0 !== t.depth ? t.depth : 100
              , l = void 0 === t.bevelEnabled || t.bevelEnabled
              , u = void 0 !== t.bevelThickness ? t.bevelThickness : 6
              , p = void 0 !== t.bevelSize ? t.bevelSize : u - 2
              , d = void 0 !== t.bevelOffset ? t.bevelOffset : 0
              , f = void 0 !== t.bevelSegments ? t.bevelSegments : 3
              , m = t.extrudePath
              , v = void 0 !== t.UVGenerator ? t.UVGenerator : ro;
            void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
            c = t.amount);
            var g, y, x, _, w, M, S, T, E = !1;
            m && (g = m.getSpacedPoints(s),
            E = !0,
            l = !1,
            y = m.computeFrenetFrames(s, !1),
            x = new b,
            _ = new b,
            w = new b),
            l || (f = 0,
            u = 0,
            p = 0,
            d = 0);
            var A = e.extractPoints(o)
              , L = A.shape
              , R = A.holes;
            if (!$a.isClockWise(L))
                for (L = L.reverse(),
                S = 0,
                T = R.length; S < T; S++)
                    M = R[S],
                    $a.isClockWise(M) && (R[S] = M.reverse());
            var P = $a.triangulateShape(L, R)
              , C = L;
            for (S = 0,
            T = R.length; S < T; S++)
                M = R[S],
                L = L.concat(M);
            function O(e, t, n) {
                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                t.clone().multiplyScalar(n).add(e)
            }
            var I, D, N, U, z, B, F = L.length, H = P.length;
            function k(e, t, n) {
                var i, r, a, o = e.x - t.x, s = e.y - t.y, c = n.x - e.x, l = n.y - e.y, u = o * o + s * s, p = o * l - s * c;
                if (Math.abs(p) > Number.EPSILON) {
                    var d = Math.sqrt(u)
                      , f = Math.sqrt(c * c + l * l)
                      , m = t.x - s / d
                      , v = t.y + o / d
                      , g = ((n.x - l / f - m) * l - (n.y + c / f - v) * c) / (o * l - s * c)
                      , y = (i = m + o * g - e.x) * i + (r = v + s * g - e.y) * r;
                    if (y <= 2)
                        return new h(i,r);
                    a = Math.sqrt(y / 2)
                } else {
                    var x = !1;
                    o > Number.EPSILON ? c > Number.EPSILON && (x = !0) : o < -Number.EPSILON ? c < -Number.EPSILON && (x = !0) : Math.sign(s) === Math.sign(l) && (x = !0),
                    x ? (i = -s,
                    r = o,
                    a = Math.sqrt(u)) : (i = o,
                    r = s,
                    a = Math.sqrt(u / 2))
                }
                return new h(i / a,r / a)
            }
            for (var G = [], V = 0, j = C.length, W = j - 1, q = V + 1; V < j; V++,
            W++,
            q++)
                W === j && (W = 0),
                q === j && (q = 0),
                G[V] = k(C[V], C[W], C[q]);
            var X, Y, Z = [], J = G.concat();
            for (S = 0,
            T = R.length; S < T; S++) {
                for (M = R[S],
                X = [],
                V = 0,
                W = (j = M.length) - 1,
                q = V + 1; V < j; V++,
                W++,
                q++)
                    W === j && (W = 0),
                    q === j && (q = 0),
                    X[V] = k(M[V], M[W], M[q]);
                Z.push(X),
                J = J.concat(X)
            }
            for (I = 0; I < f; I++) {
                for (N = I / f,
                U = u * Math.cos(N * Math.PI / 2),
                D = p * Math.sin(N * Math.PI / 2) + d,
                V = 0,
                j = C.length; V < j; V++)
                    Q((z = O(C[V], G[V], D)).x, z.y, -U);
                for (S = 0,
                T = R.length; S < T; S++)
                    for (M = R[S],
                    X = Z[S],
                    V = 0,
                    j = M.length; V < j; V++)
                        Q((z = O(M[V], X[V], D)).x, z.y, -U)
            }
            for (D = p + d,
            V = 0; V < F; V++)
                z = l ? O(L[V], J[V], D) : L[V],
                E ? (_.copy(y.normals[0]).multiplyScalar(z.x),
                x.copy(y.binormals[0]).multiplyScalar(z.y),
                w.copy(g[0]).add(_).add(x),
                Q(w.x, w.y, w.z)) : Q(z.x, z.y, 0);
            for (Y = 1; Y <= s; Y++)
                for (V = 0; V < F; V++)
                    z = l ? O(L[V], J[V], D) : L[V],
                    E ? (_.copy(y.normals[Y]).multiplyScalar(z.x),
                    x.copy(y.binormals[Y]).multiplyScalar(z.y),
                    w.copy(g[Y]).add(_).add(x),
                    Q(w.x, w.y, w.z)) : Q(z.x, z.y, c / s * Y);
            for (I = f - 1; I >= 0; I--) {
                for (N = I / f,
                U = u * Math.cos(N * Math.PI / 2),
                D = p * Math.sin(N * Math.PI / 2) + d,
                V = 0,
                j = C.length; V < j; V++)
                    Q((z = O(C[V], G[V], D)).x, z.y, c + U);
                for (S = 0,
                T = R.length; S < T; S++)
                    for (M = R[S],
                    X = Z[S],
                    V = 0,
                    j = M.length; V < j; V++)
                        z = O(M[V], X[V], D),
                        E ? Q(z.x, z.y + g[s - 1].y, g[s - 1].x + U) : Q(z.x, z.y, c + U)
            }
            function K(e, t) {
                var n, i;
                for (V = e.length; --V >= 0; ) {
                    n = V,
                    (i = V - 1) < 0 && (i = e.length - 1);
                    var r = 0
                      , a = s + 2 * f;
                    for (r = 0; r < a; r++) {
                        var o = F * r
                          , c = F * (r + 1);
                        ee(t + n + o, t + i + o, t + i + c, t + n + c)
                    }
                }
            }
            function Q(e, t, n) {
                a.push(e),
                a.push(t),
                a.push(n)
            }
            function $(e, t, r) {
                te(e),
                te(t),
                te(r);
                var a = i.length / 3
                  , o = v.generateTopUV(n, i, a - 3, a - 2, a - 1);
                ne(o[0]),
                ne(o[1]),
                ne(o[2])
            }
            function ee(e, t, r, a) {
                te(e),
                te(t),
                te(a),
                te(t),
                te(r),
                te(a);
                var o = i.length / 3
                  , s = v.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
                ne(s[0]),
                ne(s[1]),
                ne(s[3]),
                ne(s[1]),
                ne(s[2]),
                ne(s[3])
            }
            function te(e) {
                i.push(a[3 * e + 0]),
                i.push(a[3 * e + 1]),
                i.push(a[3 * e + 2])
            }
            function ne(e) {
                r.push(e.x),
                r.push(e.y)
            }
            !function() {
                var e = i.length / 3;
                if (l) {
                    var t = 0
                      , r = F * t;
                    for (V = 0; V < H; V++)
                        $((B = P[V])[2] + r, B[1] + r, B[0] + r);
                    for (r = F * (t = s + 2 * f),
                    V = 0; V < H; V++)
                        $((B = P[V])[0] + r, B[1] + r, B[2] + r)
                } else {
                    for (V = 0; V < H; V++)
                        $((B = P[V])[2], B[1], B[0]);
                    for (V = 0; V < H; V++)
                        $((B = P[V])[0] + F * s, B[1] + F * s, B[2] + F * s)
                }
                n.addGroup(e, i.length / 3 - e, 0)
            }(),
            function() {
                var e = i.length / 3
                  , t = 0;
                for (K(C, t),
                t += C.length,
                S = 0,
                T = R.length; S < T; S++)
                    K(M = R[S], t),
                    t += M.length;
                n.addGroup(e, i.length / 3 - e, 1)
            }()
        }
        this.setAttribute("position", new et(i,3)),
        this.setAttribute("uv", new et(r,2)),
        this.computeVertexNormals()
    }
    no.prototype = Object.create(Ut.prototype),
    no.prototype.constructor = no,
    no.prototype.toJSON = function() {
        var e = Ut.prototype.toJSON.call(this);
        return ao(this.parameters.shapes, this.parameters.options, e)
    }
    ,
    io.prototype = Object.create(ut.prototype),
    io.prototype.constructor = io,
    io.prototype.toJSON = function() {
        var e = ut.prototype.toJSON.call(this);
        return ao(this.parameters.shapes, this.parameters.options, e)
    }
    ;
    var ro = {
        generateTopUV: function(e, t, n, i, r) {
            var a = t[3 * n]
              , o = t[3 * n + 1]
              , s = t[3 * i]
              , c = t[3 * i + 1]
              , l = t[3 * r]
              , u = t[3 * r + 1];
            return [new h(a,o), new h(s,c), new h(l,u)]
        },
        generateSideWallUV: function(e, t, n, i, r, a) {
            var o = t[3 * n]
              , s = t[3 * n + 1]
              , c = t[3 * n + 2]
              , l = t[3 * i]
              , u = t[3 * i + 1]
              , p = t[3 * i + 2]
              , d = t[3 * r]
              , f = t[3 * r + 1]
              , m = t[3 * r + 2]
              , v = t[3 * a]
              , g = t[3 * a + 1]
              , y = t[3 * a + 2];
            return Math.abs(s - u) < .01 ? [new h(o,1 - c), new h(l,1 - p), new h(d,1 - m), new h(v,1 - y)] : [new h(s,1 - c), new h(u,1 - p), new h(f,1 - m), new h(g,1 - y)]
        }
    };
    function ao(e, t, n) {
        if (n.shapes = [],
        Array.isArray(e))
            for (var i = 0, r = e.length; i < r; i++) {
                var a = e[i];
                n.shapes.push(a.uuid)
            }
        else
            n.shapes.push(e.uuid);
        return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()),
        n
    }
    function oo(e, t) {
        Ut.call(this),
        this.type = "TextGeometry",
        this.parameters = {
            text: e,
            parameters: t
        },
        this.fromBufferGeometry(new so(e,t)),
        this.mergeVertices()
    }
    function so(e, t) {
        var n = (t = t || {}).font;
        if (!n || !n.isFont)
            return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
            new Ut;
        var i = n.generateShapes(e, t.size);
        t.depth = void 0 !== t.height ? t.height : 50,
        void 0 === t.bevelThickness && (t.bevelThickness = 10),
        void 0 === t.bevelSize && (t.bevelSize = 8),
        void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
        io.call(this, i, t),
        this.type = "TextBufferGeometry"
    }
    function co(e, t, n, i, r, a, o) {
        Ut.call(this),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: a,
            thetaLength: o
        },
        this.fromBufferGeometry(new ho(e,t,n,i,r,a,o)),
        this.mergeVertices()
    }
    function ho(e, t, n, i, r, a, o) {
        ut.call(this),
        this.type = "SphereBufferGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: a,
            thetaLength: o
        },
        e = e || 1,
        t = Math.max(3, Math.floor(t) || 8),
        n = Math.max(2, Math.floor(n) || 6),
        i = void 0 !== i ? i : 0,
        r = void 0 !== r ? r : 2 * Math.PI,
        a = void 0 !== a ? a : 0,
        o = void 0 !== o ? o : Math.PI;
        var s, c, h = Math.min(a + o, Math.PI), l = 0, u = [], p = new b, d = new b, f = [], m = [], v = [], g = [];
        for (c = 0; c <= n; c++) {
            var y = []
              , x = c / n
              , _ = 0;
            for (0 == c && 0 == a ? _ = .5 / t : c == n && h == Math.PI && (_ = -.5 / t),
            s = 0; s <= t; s++) {
                var w = s / t;
                p.x = -e * Math.cos(i + w * r) * Math.sin(a + x * o),
                p.y = e * Math.cos(a + x * o),
                p.z = e * Math.sin(i + w * r) * Math.sin(a + x * o),
                m.push(p.x, p.y, p.z),
                d.copy(p).normalize(),
                v.push(d.x, d.y, d.z),
                g.push(w + _, 1 - x),
                y.push(l++)
            }
            u.push(y)
        }
        for (c = 0; c < n; c++)
            for (s = 0; s < t; s++) {
                var M = u[c][s + 1]
                  , S = u[c][s]
                  , T = u[c + 1][s]
                  , E = u[c + 1][s + 1];
                (0 !== c || a > 0) && f.push(M, S, E),
                (c !== n - 1 || h < Math.PI) && f.push(S, T, E)
            }
        this.setIndex(f),
        this.setAttribute("position", new et(m,3)),
        this.setAttribute("normal", new et(v,3)),
        this.setAttribute("uv", new et(g,2))
    }
    function lo(e, t, n, i, r, a) {
        Ut.call(this),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: a
        },
        this.fromBufferGeometry(new uo(e,t,n,i,r,a)),
        this.mergeVertices()
    }
    function uo(e, t, n, i, r, a) {
        ut.call(this),
        this.type = "RingBufferGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: a
        },
        e = e || .5,
        t = t || 1,
        r = void 0 !== r ? r : 0,
        a = void 0 !== a ? a : 2 * Math.PI,
        n = void 0 !== n ? Math.max(3, n) : 8;
        var o, s, c, l = [], u = [], p = [], d = [], f = e, m = (t - e) / (i = void 0 !== i ? Math.max(1, i) : 1), v = new b, g = new h;
        for (s = 0; s <= i; s++) {
            for (c = 0; c <= n; c++)
                o = r + c / n * a,
                v.x = f * Math.cos(o),
                v.y = f * Math.sin(o),
                u.push(v.x, v.y, v.z),
                p.push(0, 0, 1),
                g.x = (v.x / t + 1) / 2,
                g.y = (v.y / t + 1) / 2,
                d.push(g.x, g.y);
            f += m
        }
        for (s = 0; s < i; s++) {
            var y = s * (n + 1);
            for (c = 0; c < n; c++) {
                var x = o = c + y
                  , _ = o + n + 1
                  , w = o + n + 2
                  , M = o + 1;
                l.push(x, _, M),
                l.push(_, w, M)
            }
        }
        this.setIndex(l),
        this.setAttribute("position", new et(u,3)),
        this.setAttribute("normal", new et(p,3)),
        this.setAttribute("uv", new et(d,2))
    }
    function po(e, t, n, i) {
        Ut.call(this),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: i
        },
        this.fromBufferGeometry(new fo(e,t,n,i)),
        this.mergeVertices()
    }
    function fo(e, t, n, i) {
        ut.call(this),
        this.type = "LatheBufferGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: i
        },
        t = Math.floor(t) || 12,
        n = n || 0,
        i = i || 2 * Math.PI,
        i = c.clamp(i, 0, 2 * Math.PI);
        var r, a, o, s = [], l = [], u = [], p = 1 / t, d = new b, f = new h;
        for (a = 0; a <= t; a++) {
            var m = n + a * p * i
              , v = Math.sin(m)
              , g = Math.cos(m);
            for (o = 0; o <= e.length - 1; o++)
                d.x = e[o].x * v,
                d.y = e[o].y,
                d.z = e[o].x * g,
                l.push(d.x, d.y, d.z),
                f.x = a / t,
                f.y = o / (e.length - 1),
                u.push(f.x, f.y)
        }
        for (a = 0; a < t; a++)
            for (o = 0; o < e.length - 1; o++) {
                var y = r = o + a * e.length
                  , x = r + e.length
                  , _ = r + e.length + 1
                  , w = r + 1;
                s.push(y, x, w),
                s.push(x, _, w)
            }
        if (this.setIndex(s),
        this.setAttribute("position", new et(l,3)),
        this.setAttribute("uv", new et(u,2)),
        this.computeVertexNormals(),
        i === 2 * Math.PI) {
            var M = this.attributes.normal.array
              , S = new b
              , T = new b
              , E = new b;
            for (r = t * e.length * 3,
            a = 0,
            o = 0; a < e.length; a++,
            o += 3)
                S.x = M[o + 0],
                S.y = M[o + 1],
                S.z = M[o + 2],
                T.x = M[r + o + 0],
                T.y = M[r + o + 1],
                T.z = M[r + o + 2],
                E.addVectors(S, T).normalize(),
                M[o + 0] = M[r + o + 0] = E.x,
                M[o + 1] = M[r + o + 1] = E.y,
                M[o + 2] = M[r + o + 2] = E.z
        }
    }
    function mo(e, t) {
        Ut.call(this),
        this.type = "ShapeGeometry",
        "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
        t = t.curveSegments),
        this.parameters = {
            shapes: e,
            curveSegments: t
        },
        this.fromBufferGeometry(new vo(e,t)),
        this.mergeVertices()
    }
    function vo(e, t) {
        ut.call(this),
        this.type = "ShapeBufferGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        },
        t = t || 12;
        var n = []
          , i = []
          , r = []
          , a = []
          , o = 0
          , s = 0;
        if (!1 === Array.isArray(e))
            h(e);
        else
            for (var c = 0; c < e.length; c++)
                h(e[c]),
                this.addGroup(o, s, c),
                o += s,
                s = 0;
        function h(e) {
            var o, c, h, l = i.length / 3, u = e.extractPoints(t), p = u.shape, d = u.holes;
            for (!1 === $a.isClockWise(p) && (p = p.reverse()),
            o = 0,
            c = d.length; o < c; o++)
                h = d[o],
                !0 === $a.isClockWise(h) && (d[o] = h.reverse());
            var f = $a.triangulateShape(p, d);
            for (o = 0,
            c = d.length; o < c; o++)
                h = d[o],
                p = p.concat(h);
            for (o = 0,
            c = p.length; o < c; o++) {
                var m = p[o];
                i.push(m.x, m.y, 0),
                r.push(0, 0, 1),
                a.push(m.x, m.y)
            }
            for (o = 0,
            c = f.length; o < c; o++) {
                var v = f[o]
                  , g = v[0] + l
                  , y = v[1] + l
                  , x = v[2] + l;
                n.push(g, y, x),
                s += 3
            }
        }
        this.setIndex(n),
        this.setAttribute("position", new et(i,3)),
        this.setAttribute("normal", new et(r,3)),
        this.setAttribute("uv", new et(a,2))
    }
    function go(e, t) {
        if (t.shapes = [],
        Array.isArray(e))
            for (var n = 0, i = e.length; n < i; n++) {
                var r = e[n];
                t.shapes.push(r.uuid)
            }
        else
            t.shapes.push(e.uuid);
        return t
    }
    function yo(e, t) {
        ut.call(this),
        this.type = "EdgesGeometry",
        this.parameters = {
            thresholdAngle: t
        },
        t = void 0 !== t ? t : 1;
        var n, i, r, a, o = [], s = Math.cos(c.DEG2RAD * t), h = [0, 0], l = {}, u = ["a", "b", "c"];
        e.isBufferGeometry ? (a = new Ut).fromBufferGeometry(e) : a = e.clone(),
        a.mergeVertices(),
        a.computeFaceNormals();
        for (var p = a.vertices, d = a.faces, f = 0, m = d.length; f < m; f++)
            for (var v = d[f], g = 0; g < 3; g++)
                n = v[u[g]],
                i = v[u[(g + 1) % 3]],
                h[0] = Math.min(n, i),
                h[1] = Math.max(n, i),
                void 0 === l[r = h[0] + "," + h[1]] ? l[r] = {
                    index1: h[0],
                    index2: h[1],
                    face1: f,
                    face2: void 0
                } : l[r].face2 = f;
        for (r in l) {
            var y = l[r];
            if (void 0 === y.face2 || d[y.face1].normal.dot(d[y.face2].normal) <= s) {
                var x = p[y.index1];
                o.push(x.x, x.y, x.z),
                x = p[y.index2],
                o.push(x.x, x.y, x.z)
            }
        }
        this.setAttribute("position", new et(o,3))
    }
    function xo(e, t, n, i, r, a, o, s) {
        Ut.call(this),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: a,
            thetaStart: o,
            thetaLength: s
        },
        this.fromBufferGeometry(new bo(e,t,n,i,r,a,o,s)),
        this.mergeVertices()
    }
    function bo(e, t, n, i, r, a, o, s) {
        ut.call(this),
        this.type = "CylinderBufferGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: a,
            thetaStart: o,
            thetaLength: s
        };
        var c = this;
        e = void 0 !== e ? e : 1,
        t = void 0 !== t ? t : 1,
        n = n || 1,
        i = Math.floor(i) || 8,
        r = Math.floor(r) || 1,
        a = void 0 !== a && a,
        o = void 0 !== o ? o : 0,
        s = void 0 !== s ? s : 2 * Math.PI;
        var l = []
          , u = []
          , p = []
          , d = []
          , f = 0
          , m = []
          , v = n / 2
          , g = 0;
        function y(n) {
            var r, a, m, y = new h, x = new b, _ = 0, w = !0 === n ? e : t, M = !0 === n ? 1 : -1;
            for (a = f,
            r = 1; r <= i; r++)
                u.push(0, v * M, 0),
                p.push(0, M, 0),
                d.push(.5, .5),
                f++;
            for (m = f,
            r = 0; r <= i; r++) {
                var S = r / i * s + o
                  , T = Math.cos(S)
                  , E = Math.sin(S);
                x.x = w * E,
                x.y = v * M,
                x.z = w * T,
                u.push(x.x, x.y, x.z),
                p.push(0, M, 0),
                y.x = .5 * T + .5,
                y.y = .5 * E * M + .5,
                d.push(y.x, y.y),
                f++
            }
            for (r = 0; r < i; r++) {
                var A = a + r
                  , L = m + r;
                !0 === n ? l.push(L, L + 1, A) : l.push(L + 1, L, A),
                _ += 3
            }
            c.addGroup(g, _, !0 === n ? 1 : 2),
            g += _
        }
        !function() {
            var a, h, y = new b, x = new b, _ = 0, w = (t - e) / n;
            for (h = 0; h <= r; h++) {
                var M = []
                  , S = h / r
                  , T = S * (t - e) + e;
                for (a = 0; a <= i; a++) {
                    var E = a / i
                      , A = E * s + o
                      , L = Math.sin(A)
                      , R = Math.cos(A);
                    x.x = T * L,
                    x.y = -S * n + v,
                    x.z = T * R,
                    u.push(x.x, x.y, x.z),
                    y.set(L, w, R).normalize(),
                    p.push(y.x, y.y, y.z),
                    d.push(E, 1 - S),
                    M.push(f++)
                }
                m.push(M)
            }
            for (a = 0; a < i; a++)
                for (h = 0; h < r; h++) {
                    var P = m[h][a]
                      , C = m[h + 1][a]
                      , O = m[h + 1][a + 1]
                      , I = m[h][a + 1];
                    l.push(P, C, I),
                    l.push(C, O, I),
                    _ += 6
                }
            c.addGroup(g, _, 0),
            g += _
        }(),
        !1 === a && (e > 0 && y(!0),
        t > 0 && y(!1)),
        this.setIndex(l),
        this.setAttribute("position", new et(u,3)),
        this.setAttribute("normal", new et(p,3)),
        this.setAttribute("uv", new et(d,2))
    }
    function _o(e, t, n, i, r, a, o) {
        xo.call(this, 0, e, t, n, i, r, a, o),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: a,
            thetaLength: o
        }
    }
    function wo(e, t, n, i, r, a, o) {
        bo.call(this, 0, e, t, n, i, r, a, o),
        this.type = "ConeBufferGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: a,
            thetaLength: o
        }
    }
    function Mo(e, t, n, i) {
        Ut.call(this),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: i
        },
        this.fromBufferGeometry(new So(e,t,n,i)),
        this.mergeVertices()
    }
    function So(e, t, n, i) {
        ut.call(this),
        this.type = "CircleBufferGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: i
        },
        e = e || 1,
        t = void 0 !== t ? Math.max(3, t) : 8,
        n = void 0 !== n ? n : 0,
        i = void 0 !== i ? i : 2 * Math.PI;
        var r, a, o = [], s = [], c = [], l = [], u = new b, p = new h;
        for (s.push(0, 0, 0),
        c.push(0, 0, 1),
        l.push(.5, .5),
        a = 0,
        r = 3; a <= t; a++,
        r += 3) {
            var d = n + a / t * i;
            u.x = e * Math.cos(d),
            u.y = e * Math.sin(d),
            s.push(u.x, u.y, u.z),
            c.push(0, 0, 1),
            p.x = (s[r] / e + 1) / 2,
            p.y = (s[r + 1] / e + 1) / 2,
            l.push(p.x, p.y)
        }
        for (r = 1; r <= t; r++)
            o.push(r, r + 1, 0);
        this.setIndex(o),
        this.setAttribute("position", new et(s,3)),
        this.setAttribute("normal", new et(c,3)),
        this.setAttribute("uv", new et(l,2))
    }
    oo.prototype = Object.create(Ut.prototype),
    oo.prototype.constructor = oo,
    so.prototype = Object.create(io.prototype),
    so.prototype.constructor = so,
    co.prototype = Object.create(Ut.prototype),
    co.prototype.constructor = co,
    ho.prototype = Object.create(ut.prototype),
    ho.prototype.constructor = ho,
    lo.prototype = Object.create(Ut.prototype),
    lo.prototype.constructor = lo,
    uo.prototype = Object.create(ut.prototype),
    uo.prototype.constructor = uo,
    po.prototype = Object.create(Ut.prototype),
    po.prototype.constructor = po,
    fo.prototype = Object.create(ut.prototype),
    fo.prototype.constructor = fo,
    mo.prototype = Object.create(Ut.prototype),
    mo.prototype.constructor = mo,
    mo.prototype.toJSON = function() {
        var e = Ut.prototype.toJSON.call(this);
        return go(this.parameters.shapes, e)
    }
    ,
    vo.prototype = Object.create(ut.prototype),
    vo.prototype.constructor = vo,
    vo.prototype.toJSON = function() {
        var e = ut.prototype.toJSON.call(this);
        return go(this.parameters.shapes, e)
    }
    ,
    yo.prototype = Object.create(ut.prototype),
    yo.prototype.constructor = yo,
    xo.prototype = Object.create(Ut.prototype),
    xo.prototype.constructor = xo,
    bo.prototype = Object.create(ut.prototype),
    bo.prototype.constructor = bo,
    _o.prototype = Object.create(xo.prototype),
    _o.prototype.constructor = _o,
    wo.prototype = Object.create(bo.prototype),
    wo.prototype.constructor = wo,
    Mo.prototype = Object.create(Ut.prototype),
    Mo.prototype.constructor = Mo,
    So.prototype = Object.create(ut.prototype),
    So.prototype.constructor = So;
    var To = Object.freeze({
        __proto__: null,
        WireframeGeometry: ha,
        ParametricGeometry: la,
        ParametricBufferGeometry: ua,
        TetrahedronGeometry: fa,
        TetrahedronBufferGeometry: ma,
        OctahedronGeometry: va,
        OctahedronBufferGeometry: ga,
        IcosahedronGeometry: ya,
        IcosahedronBufferGeometry: xa,
        DodecahedronGeometry: ba,
        DodecahedronBufferGeometry: _a,
        PolyhedronGeometry: pa,
        PolyhedronBufferGeometry: da,
        TubeGeometry: wa,
        TubeBufferGeometry: Ma,
        TorusKnotGeometry: Sa,
        TorusKnotBufferGeometry: Ta,
        TorusGeometry: Ea,
        TorusBufferGeometry: Aa,
        TextGeometry: oo,
        TextBufferGeometry: so,
        SphereGeometry: co,
        SphereBufferGeometry: ho,
        RingGeometry: lo,
        RingBufferGeometry: uo,
        PlaneGeometry: $t,
        PlaneBufferGeometry: en,
        LatheGeometry: po,
        LatheBufferGeometry: fo,
        ShapeGeometry: mo,
        ShapeBufferGeometry: vo,
        ExtrudeGeometry: no,
        ExtrudeBufferGeometry: io,
        EdgesGeometry: yo,
        ConeGeometry: _o,
        ConeBufferGeometry: wo,
        CylinderGeometry: xo,
        CylinderBufferGeometry: bo,
        CircleGeometry: Mo,
        CircleBufferGeometry: So,
        BoxGeometry: class extends Ut {
            constructor(e, t, n, i, r, a) {
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: a
                },
                this.fromBufferGeometry(new zt(e,t,n,i,r,a)),
                this.mergeVertices()
            }
        }
        ,
        BoxBufferGeometry: zt
    });
    function Eo(e) {
        Ve.call(this),
        this.type = "ShadowMaterial",
        this.color = new ze(0),
        this.transparent = !0,
        this.setValues(e)
    }
    function Ao(e) {
        kt.call(this, e),
        this.type = "RawShaderMaterial"
    }
    function Lo(e) {
        Ve.call(this),
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new ze(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ze(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new h(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.vertexTangents = !1,
        this.setValues(e)
    }
    function Ro(e) {
        Lo.call(this),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.clearcoat = 0,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new h(1,1),
        this.clearcoatNormalMap = null,
        this.reflectivity = .5,
        this.sheen = null,
        this.transparency = 0,
        this.setValues(e)
    }
    function Po(e) {
        Ve.call(this),
        this.type = "MeshPhongMaterial",
        this.color = new ze(16777215),
        this.specular = new ze(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ze(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new h(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function Co(e) {
        Ve.call(this),
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new ze(16777215),
        this.specular = new ze(1118481),
        this.shininess = 30,
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ze(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new h(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function Oo(e) {
        Ve.call(this),
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new h(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function Io(e) {
        Ve.call(this),
        this.type = "MeshLambertMaterial",
        this.color = new ze(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ze(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function Do(e) {
        Ve.call(this),
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new ze(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new h(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function No(e) {
        kr.call(this),
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    Eo.prototype = Object.create(Ve.prototype),
    Eo.prototype.constructor = Eo,
    Eo.prototype.isShadowMaterial = !0,
    Eo.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this
    }
    ,
    Ao.prototype = Object.create(kt.prototype),
    Ao.prototype.constructor = Ao,
    Ao.prototype.isRawShaderMaterial = !0,
    Lo.prototype = Object.create(Ve.prototype),
    Lo.prototype.constructor = Lo,
    Lo.prototype.isMeshStandardMaterial = !0,
    Lo.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this.vertexTangents = e.vertexTangents,
        this
    }
    ,
    Ro.prototype = Object.create(Lo.prototype),
    Ro.prototype.constructor = Ro,
    Ro.prototype.isMeshPhysicalMaterial = !0,
    Ro.prototype.copy = function(e) {
        return Lo.prototype.copy.call(this, e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.reflectivity = e.reflectivity,
        e.sheen ? this.sheen = (this.sheen || new ze).copy(e.sheen) : this.sheen = null,
        this.transparency = e.transparency,
        this
    }
    ,
    Po.prototype = Object.create(Ve.prototype),
    Po.prototype.constructor = Po,
    Po.prototype.isMeshPhongMaterial = !0,
    Po.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    Co.prototype = Object.create(Ve.prototype),
    Co.prototype.constructor = Co,
    Co.prototype.isMeshToonMaterial = !0,
    Co.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    Oo.prototype = Object.create(Ve.prototype),
    Oo.prototype.constructor = Oo,
    Oo.prototype.isMeshNormalMaterial = !0,
    Oo.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    Io.prototype = Object.create(Ve.prototype),
    Io.prototype.constructor = Io,
    Io.prototype.isMeshLambertMaterial = !0,
    Io.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    Do.prototype = Object.create(Ve.prototype),
    Do.prototype.constructor = Do,
    Do.prototype.isMeshMatcapMaterial = !0,
    Do.prototype.copy = function(e) {
        return Ve.prototype.copy.call(this, e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    No.prototype = Object.create(kr.prototype),
    No.prototype.constructor = No,
    No.prototype.isLineDashedMaterial = !0,
    No.prototype.copy = function(e) {
        return kr.prototype.copy.call(this, e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
    ;
    var Uo = Object.freeze({
        __proto__: null,
        ShadowMaterial: Eo,
        SpriteMaterial: cr,
        RawShaderMaterial: Ao,
        ShaderMaterial: kt,
        PointsMaterial: Qr,
        MeshPhysicalMaterial: Ro,
        MeshStandardMaterial: Lo,
        MeshPhongMaterial: Po,
        MeshToonMaterial: Co,
        MeshNormalMaterial: Oo,
        MeshLambertMaterial: Io,
        MeshDepthMaterial: ji,
        MeshDistanceMaterial: Wi,
        MeshBasicMaterial: je,
        MeshMatcapMaterial: Do,
        LineDashedMaterial: No,
        LineBasicMaterial: kr,
        Material: Ve
    })
      , zo = {
        arraySlice: function(e, t, n) {
            return zo.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
        },
        convertArray: function(e, t, n) {
            return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        },
        isTypedArray: function(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        },
        getKeyframeOrder: function(e) {
            for (var t = e.length, n = new Array(t), i = 0; i !== t; ++i)
                n[i] = i;
            return n.sort((function(t, n) {
                return e[t] - e[n]
            }
            )),
            n
        },
        sortedArray: function(e, t, n) {
            for (var i = e.length, r = new e.constructor(i), a = 0, o = 0; o !== i; ++a)
                for (var s = n[a] * t, c = 0; c !== t; ++c)
                    r[o++] = e[s + c];
            return r
        },
        flattenJSON: function(e, t, n, i) {
            for (var r = 1, a = e[0]; void 0 !== a && void 0 === a[i]; )
                a = e[r++];
            if (void 0 !== a) {
                var o = a[i];
                if (void 0 !== o)
                    if (Array.isArray(o))
                        do {
                            void 0 !== (o = a[i]) && (t.push(a.time),
                            n.push.apply(n, o)),
                            a = e[r++]
                        } while (void 0 !== a);
                    else if (void 0 !== o.toArray)
                        do {
                            void 0 !== (o = a[i]) && (t.push(a.time),
                            o.toArray(n, n.length)),
                            a = e[r++]
                        } while (void 0 !== a);
                    else
                        do {
                            void 0 !== (o = a[i]) && (t.push(a.time),
                            n.push(o)),
                            a = e[r++]
                        } while (void 0 !== a)
            }
        },
        subclip: function(e, t, n, i, r) {
            r = r || 30;
            var a = e.clone();
            a.name = t;
            for (var o = [], s = 0; s < a.tracks.length; ++s) {
                for (var c = a.tracks[s], h = c.getValueSize(), l = [], u = [], p = 0; p < c.times.length; ++p) {
                    var d = c.times[p] * r;
                    if (!(d < n || d >= i)) {
                        l.push(c.times[p]);
                        for (var f = 0; f < h; ++f)
                            u.push(c.values[p * h + f])
                    }
                }
                0 !== l.length && (c.times = zo.convertArray(l, c.times.constructor),
                c.values = zo.convertArray(u, c.values.constructor),
                o.push(c))
            }
            a.tracks = o;
            var m = 1 / 0;
            for (s = 0; s < a.tracks.length; ++s)
                m > a.tracks[s].times[0] && (m = a.tracks[s].times[0]);
            for (s = 0; s < a.tracks.length; ++s)
                a.tracks[s].shift(-1 * m);
            return a.resetDuration(),
            a
        },
        makeClipAdditive: function(e, t, n, i) {
            void 0 === t && (t = 0),
            void 0 === n && (n = e),
            (void 0 === i || i <= 0) && (i = 30);
            for (var r = e.tracks.length, a = t / i, o = 0; o < r; ++o) {
                var s = n.tracks[o]
                  , c = s.ValueTypeName;
                if ("bool" !== c && "string" !== c) {
                    var h = e.tracks.find((function(e) {
                        return e.name === s.name && e.ValueTypeName === c
                    }
                    ));
                    if (void 0 !== h) {
                        var l, u = s.getValueSize(), p = s.times.length - 1;
                        if (a <= s.times[0])
                            l = zo.arraySlice(s.values, 0, s.valueSize);
                        else if (a >= s.times[p]) {
                            var d = p * u;
                            l = zo.arraySlice(s.values, d)
                        } else {
                            var f = s.createInterpolant();
                            f.evaluate(a),
                            l = f.resultBuffer
                        }
                        if ("quaternion" === c)
                            new g(l[0],l[1],l[2],l[3]).normalize().conjugate().toArray(l);
                        for (var m = h.times.length, v = 0; v < m; ++v) {
                            var y = v * u;
                            if ("quaternion" === c)
                                g.multiplyQuaternionsFlat(h.values, y, l, 0, h.values, y);
                            else
                                for (var x = 0; x < u; ++x)
                                    h.values[y + x] -= l[x]
                        }
                    }
                }
            }
            return e.blendMode = 2501,
            e
        }
    };
    function Bo(e, t, n, i) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== i ? i : new t.constructor(n),
        this.sampleValues = t,
        this.valueSize = n
    }
    function Fo(e, t, n, i) {
        Bo.call(this, e, t, n, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0
    }
    function Ho(e, t, n, i) {
        Bo.call(this, e, t, n, i)
    }
    function ko(e, t, n, i) {
        Bo.call(this, e, t, n, i)
    }
    function Go(e, t, n, i) {
        if (void 0 === e)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = zo.convertArray(t, this.TimeBufferType),
        this.values = zo.convertArray(n, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    function Vo(e, t, n) {
        Go.call(this, e, t, n)
    }
    function jo(e, t, n, i) {
        Go.call(this, e, t, n, i)
    }
    function Wo(e, t, n, i) {
        Go.call(this, e, t, n, i)
    }
    function qo(e, t, n, i) {
        Bo.call(this, e, t, n, i)
    }
    function Xo(e, t, n, i) {
        Go.call(this, e, t, n, i)
    }
    function Yo(e, t, n, i) {
        Go.call(this, e, t, n, i)
    }
    function Zo(e, t, n, i) {
        Go.call(this, e, t, n, i)
    }
    function Jo(e, t, n, i) {
        this.name = e,
        this.tracks = n,
        this.duration = void 0 !== t ? t : -1,
        this.blendMode = void 0 !== i ? i : 2500,
        this.uuid = c.generateUUID(),
        this.duration < 0 && this.resetDuration()
    }
    function Ko(e) {
        if (void 0 === e.type)
            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var t = function(e) {
            switch (e.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return Wo;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return Zo;
            case "color":
                return jo;
            case "quaternion":
                return Xo;
            case "bool":
            case "boolean":
                return Vo;
            case "string":
                return Yo
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        if (void 0 === e.times) {
            var n = []
              , i = [];
            zo.flattenJSON(e.keys, n, i, "value"),
            e.times = n,
            e.values = i
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
    }
    Object.assign(Bo.prototype, {
        evaluate: function(e) {
            var t = this.parameterPositions
              , n = this._cachedIndex
              , i = t[n]
              , r = t[n - 1];
            e: {
                t: {
                    var a;
                    n: {
                        i: if (!(e < i)) {
                            for (var o = n + 2; ; ) {
                                if (void 0 === i) {
                                    if (e < r)
                                        break i;
                                    return n = t.length,
                                    this._cachedIndex = n,
                                    this.afterEnd_(n - 1, e, r)
                                }
                                if (n === o)
                                    break;
                                if (r = i,
                                e < (i = t[++n]))
                                    break t
                            }
                            a = t.length;
                            break n
                        }
                        if (e >= r)
                            break e;
                        var s = t[1];
                        e < s && (n = 2,
                        r = s);
                        for (o = n - 2; ; ) {
                            if (void 0 === r)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, e, i);
                            if (n === o)
                                break;
                            if (i = r,
                            e >= (r = t[--n - 1]))
                                break t
                        }
                        a = n,
                        n = 0
                    }
                    for (; n < a; ) {
                        var c = n + a >>> 1;
                        e < t[c] ? a = c : n = c + 1
                    }
                    if (i = t[n],
                    void 0 === (r = t[n - 1]))
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, e, i);
                    if (void 0 === i)
                        return n = t.length,
                        this._cachedIndex = n,
                        this.afterEnd_(n - 1, r, e)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, r, i)
            }
            return this.interpolate_(n, r, e, i)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(e) {
            for (var t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i, a = 0; a !== i; ++a)
                t[a] = n[r + a];
            return t
        },
        interpolate_: function() {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }),
    Object.assign(Bo.prototype, {
        beforeStart_: Bo.prototype.copySampleValue_,
        afterEnd_: Bo.prototype.copySampleValue_
    }),
    Fo.prototype = Object.assign(Object.create(Bo.prototype), {
        constructor: Fo,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function(e, t, n) {
            var i = this.parameterPositions
              , r = e - 2
              , a = e + 1
              , o = i[r]
              , s = i[a];
            if (void 0 === o)
                switch (this.getSettings_().endingStart) {
                case 2401:
                    r = e,
                    o = 2 * t - n;
                    break;
                case 2402:
                    o = t + i[r = i.length - 2] - i[r + 1];
                    break;
                default:
                    r = e,
                    o = n
                }
            if (void 0 === s)
                switch (this.getSettings_().endingEnd) {
                case 2401:
                    a = e,
                    s = 2 * n - t;
                    break;
                case 2402:
                    a = 1,
                    s = n + i[1] - i[0];
                    break;
                default:
                    a = e - 1,
                    s = t
                }
            var c = .5 * (n - t)
              , h = this.valueSize;
            this._weightPrev = c / (t - o),
            this._weightNext = c / (s - n),
            this._offsetPrev = r * h,
            this._offsetNext = a * h
        },
        interpolate_: function(e, t, n, i) {
            for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, c = s - o, h = this._offsetPrev, l = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (n - t) / (i - t), f = d * d, m = f * d, v = -u * m + 2 * u * f - u * d, g = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, x = p * m - p * f, b = 0; b !== o; ++b)
                r[b] = v * a[h + b] + g * a[c + b] + y * a[s + b] + x * a[l + b];
            return r
        }
    }),
    Ho.prototype = Object.assign(Object.create(Bo.prototype), {
        constructor: Ho,
        interpolate_: function(e, t, n, i) {
            for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, c = s - o, h = (n - t) / (i - t), l = 1 - h, u = 0; u !== o; ++u)
                r[u] = a[c + u] * l + a[s + u] * h;
            return r
        }
    }),
    ko.prototype = Object.assign(Object.create(Bo.prototype), {
        constructor: ko,
        interpolate_: function(e) {
            return this.copySampleValue_(e - 1)
        }
    }),
    Object.assign(Go, {
        toJSON: function(e) {
            var t, n = e.constructor;
            if (void 0 !== n.toJSON)
                t = n.toJSON(e);
            else {
                t = {
                    name: e.name,
                    times: zo.convertArray(e.times, Array),
                    values: zo.convertArray(e.values, Array)
                };
                var i = e.getInterpolation();
                i !== e.DefaultInterpolation && (t.interpolation = i)
            }
            return t.type = e.ValueTypeName,
            t
        }
    }),
    Object.assign(Go.prototype, {
        constructor: Go,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(e) {
            return new ko(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodLinear: function(e) {
            return new Ho(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodSmooth: function(e) {
            return new Fo(this.times,this.values,this.getValueSize(),e)
        },
        setInterpolation: function(e) {
            var t;
            switch (e) {
            case 2300:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
            case 2301:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case 2302:
                t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation)
                        throw new Error(n);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", n),
                this
            }
            return this.createInterpolant = t,
            this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return 2300;
            case this.InterpolantFactoryMethodLinear:
                return 2301;
            case this.InterpolantFactoryMethodSmooth:
                return 2302
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(e) {
            if (0 !== e)
                for (var t = this.times, n = 0, i = t.length; n !== i; ++n)
                    t[n] += e;
            return this
        },
        scale: function(e) {
            if (1 !== e)
                for (var t = this.times, n = 0, i = t.length; n !== i; ++n)
                    t[n] *= e;
            return this
        },
        trim: function(e, t) {
            for (var n = this.times, i = n.length, r = 0, a = i - 1; r !== i && n[r] < e; )
                ++r;
            for (; -1 !== a && n[a] > t; )
                --a;
            if (++a,
            0 !== r || a !== i) {
                r >= a && (r = (a = Math.max(a, 1)) - 1);
                var o = this.getValueSize();
                this.times = zo.arraySlice(n, r, a),
                this.values = zo.arraySlice(this.values, r * o, a * o)
            }
            return this
        },
        validate: function() {
            var e = !0
              , t = this.getValueSize();
            t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            e = !1);
            var n = this.times
              , i = this.values
              , r = n.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
            e = !1);
            for (var a = null, o = 0; o !== r; o++) {
                var s = n[o];
                if ("number" == typeof s && isNaN(s)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s),
                    e = !1;
                    break
                }
                if (null !== a && a > s) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a),
                    e = !1;
                    break
                }
                a = s
            }
            if (void 0 !== i && zo.isTypedArray(i)) {
                o = 0;
                for (var c = i.length; o !== c; ++o) {
                    var h = i[o];
                    if (isNaN(h)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, h),
                        e = !1;
                        break
                    }
                }
            }
            return e
        },
        optimize: function() {
            for (var e = zo.arraySlice(this.times), t = zo.arraySlice(this.values), n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = 1, a = e.length - 1, o = 1; o < a; ++o) {
                var s = !1
                  , c = e[o];
                if (c !== e[o + 1] && (1 !== o || c !== c[0]))
                    if (i)
                        s = !0;
                    else
                        for (var h = o * n, l = h - n, u = h + n, p = 0; p !== n; ++p) {
                            var d = t[h + p];
                            if (d !== t[l + p] || d !== t[u + p]) {
                                s = !0;
                                break
                            }
                        }
                if (s) {
                    if (o !== r) {
                        e[r] = e[o];
                        var f = o * n
                          , m = r * n;
                        for (p = 0; p !== n; ++p)
                            t[m + p] = t[f + p]
                    }
                    ++r
                }
            }
            if (a > 0) {
                e[r] = e[a];
                for (f = a * n,
                m = r * n,
                p = 0; p !== n; ++p)
                    t[m + p] = t[f + p];
                ++r
            }
            return r !== e.length ? (this.times = zo.arraySlice(e, 0, r),
            this.values = zo.arraySlice(t, 0, r * n)) : (this.times = e,
            this.values = t),
            this
        },
        clone: function() {
            var e = zo.arraySlice(this.times, 0)
              , t = zo.arraySlice(this.values, 0)
              , n = new (0,
            this.constructor)(this.name,e,t);
            return n.createInterpolant = this.createInterpolant,
            n
        }
    }),
    Vo.prototype = Object.assign(Object.create(Go.prototype), {
        constructor: Vo,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    jo.prototype = Object.assign(Object.create(Go.prototype), {
        constructor: jo,
        ValueTypeName: "color"
    }),
    Wo.prototype = Object.assign(Object.create(Go.prototype), {
        constructor: Wo,
        ValueTypeName: "number"
    }),
    qo.prototype = Object.assign(Object.create(Bo.prototype), {
        constructor: qo,
        interpolate_: function(e, t, n, i) {
            for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, c = (n - t) / (i - t), h = s + o; s !== h; s += 4)
                g.slerpFlat(r, 0, a, s - o, a, s, c);
            return r
        }
    }),
    Xo.prototype = Object.assign(Object.create(Go.prototype), {
        constructor: Xo,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(e) {
            return new qo(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }),
    Yo.prototype = Object.assign(Object.create(Go.prototype), {
        constructor: Yo,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    Zo.prototype = Object.assign(Object.create(Go.prototype), {
        constructor: Zo,
        ValueTypeName: "vector"
    }),
    Object.assign(Jo, {
        parse: function(e) {
            for (var t = [], n = e.tracks, i = 1 / (e.fps || 1), r = 0, a = n.length; r !== a; ++r)
                t.push(Ko(n[r]).scale(i));
            return new Jo(e.name,e.duration,t,e.blendMode)
        },
        toJSON: function(e) {
            for (var t = [], n = e.tracks, i = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode
            }, r = 0, a = n.length; r !== a; ++r)
                t.push(Go.toJSON(n[r]));
            return i
        },
        CreateFromMorphTargetSequence: function(e, t, n, i) {
            for (var r = t.length, a = [], o = 0; o < r; o++) {
                var s = []
                  , c = [];
                s.push((o + r - 1) % r, o, (o + 1) % r),
                c.push(0, 1, 0);
                var h = zo.getKeyframeOrder(s);
                s = zo.sortedArray(s, 1, h),
                c = zo.sortedArray(c, 1, h),
                i || 0 !== s[0] || (s.push(r),
                c.push(c[0])),
                a.push(new Wo(".morphTargetInfluences[" + t[o].name + "]",s,c).scale(1 / n))
            }
            return new Jo(e,-1,a)
        },
        findByName: function(e, t) {
            var n = e;
            if (!Array.isArray(e)) {
                var i = e;
                n = i.geometry && i.geometry.animations || i.animations
            }
            for (var r = 0; r < n.length; r++)
                if (n[r].name === t)
                    return n[r];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(e, t, n) {
            for (var i = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
                var s = e[a]
                  , c = s.name.match(r);
                if (c && c.length > 1) {
                    var h = i[u = c[1]];
                    h || (i[u] = h = []),
                    h.push(s)
                }
            }
            var l = [];
            for (var u in i)
                l.push(Jo.CreateFromMorphTargetSequence(u, i[u], t, n));
            return l
        },
        parseAnimation: function(e, t) {
            if (!e)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            for (var n = function(e, t, n, i, r) {
                if (0 !== n.length) {
                    var a = []
                      , o = [];
                    zo.flattenJSON(n, a, o, i),
                    0 !== a.length && r.push(new e(t,a,o))
                }
            }, i = [], r = e.name || "default", a = e.length || -1, o = e.fps || 30, s = e.blendMode, c = e.hierarchy || [], h = 0; h < c.length; h++) {
                var l = c[h].keys;
                if (l && 0 !== l.length)
                    if (l[0].morphTargets) {
                        for (var u = {}, p = 0; p < l.length; p++)
                            if (l[p].morphTargets)
                                for (var d = 0; d < l[p].morphTargets.length; d++)
                                    u[l[p].morphTargets[d]] = -1;
                        for (var f in u) {
                            var m = []
                              , v = [];
                            for (d = 0; d !== l[p].morphTargets.length; ++d) {
                                var g = l[p];
                                m.push(g.time),
                                v.push(g.morphTarget === f ? 1 : 0)
                            }
                            i.push(new Wo(".morphTargetInfluence[" + f + "]",m,v))
                        }
                        a = u.length * (o || 1)
                    } else {
                        var y = ".bones[" + t[h].name + "]";
                        n(Zo, y + ".position", l, "pos", i),
                        n(Xo, y + ".quaternion", l, "rot", i),
                        n(Zo, y + ".scale", l, "scl", i)
                    }
            }
            return 0 === i.length ? null : new Jo(r,a,i,s)
        }
    }),
    Object.assign(Jo.prototype, {
        resetDuration: function() {
            for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
                var i = this.tracks[t];
                e = Math.max(e, i.times[i.times.length - 1])
            }
            return this.duration = e,
            this
        },
        trim: function() {
            for (var e = 0; e < this.tracks.length; e++)
                this.tracks[e].trim(0, this.duration);
            return this
        },
        validate: function() {
            for (var e = !0, t = 0; t < this.tracks.length; t++)
                e = e && this.tracks[t].validate();
            return e
        },
        optimize: function() {
            for (var e = 0; e < this.tracks.length; e++)
                this.tracks[e].optimize();
            return this
        },
        clone: function() {
            for (var e = [], t = 0; t < this.tracks.length; t++)
                e.push(this.tracks[t].clone());
            return new Jo(this.name,this.duration,e,this.blendMode)
        }
    });
    var Qo = {
        enabled: !1,
        files: {},
        add: function(e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        },
        get: function(e) {
            if (!1 !== this.enabled)
                return this.files[e]
        },
        remove: function(e) {
            delete this.files[e]
        },
        clear: function() {
            this.files = {}
        }
    };
    function $o(e, t, n) {
        var i = this
          , r = !1
          , a = 0
          , o = 0
          , s = void 0
          , c = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = n,
        this.itemStart = function(e) {
            o++,
            !1 === r && void 0 !== i.onStart && i.onStart(e, a, o),
            r = !0
        }
        ,
        this.itemEnd = function(e) {
            a++,
            void 0 !== i.onProgress && i.onProgress(e, a, o),
            a === o && (r = !1,
            void 0 !== i.onLoad && i.onLoad())
        }
        ,
        this.itemError = function(e) {
            void 0 !== i.onError && i.onError(e)
        }
        ,
        this.resolveURL = function(e) {
            return s ? s(e) : e
        }
        ,
        this.setURLModifier = function(e) {
            return s = e,
            this
        }
        ,
        this.addHandler = function(e, t) {
            return c.push(e, t),
            this
        }
        ,
        this.removeHandler = function(e) {
            var t = c.indexOf(e);
            return -1 !== t && c.splice(t, 2),
            this
        }
        ,
        this.getHandler = function(e) {
            for (var t = 0, n = c.length; t < n; t += 2) {
                var i = c[t]
                  , r = c[t + 1];
                if (i.global && (i.lastIndex = 0),
                i.test(e))
                    return r
            }
            return null
        }
    }
    var es = new $o;
    function ts(e) {
        this.manager = void 0 !== e ? e : es,
        this.crossOrigin = "anonymous",
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    Object.assign(ts.prototype, {
        load: function() {},
        loadAsync: function(e, t) {
            var n = this;
            return new Promise((function(i, r) {
                n.load(e, i, t, r)
            }
            ))
        },
        parse: function() {},
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setResourcePath: function(e) {
            return this.resourcePath = e,
            this
        },
        setRequestHeader: function(e) {
            return this.requestHeader = e,
            this
        }
    });
    var ns = {};
    function is(e) {
        ts.call(this, e)
    }
    function rs(e) {
        ts.call(this, e)
    }
    function as(e) {
        ts.call(this, e)
    }
    function os(e) {
        ts.call(this, e)
    }
    function ss(e) {
        ts.call(this, e)
    }
    function cs(e) {
        ts.call(this, e)
    }
    function hs(e) {
        ts.call(this, e)
    }
    function ls() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    function us(e, t, n, i, r, a, o, s) {
        ls.call(this),
        this.type = "EllipseCurve",
        this.aX = e || 0,
        this.aY = t || 0,
        this.xRadius = n || 1,
        this.yRadius = i || 1,
        this.aStartAngle = r || 0,
        this.aEndAngle = a || 2 * Math.PI,
        this.aClockwise = o || !1,
        this.aRotation = s || 0
    }
    function ps(e, t, n, i, r, a) {
        us.call(this, e, t, n, n, i, r, a),
        this.type = "ArcCurve"
    }
    function ds() {
        var e = 0
          , t = 0
          , n = 0
          , i = 0;
        function r(r, a, o, s) {
            e = r,
            t = o,
            n = -3 * r + 3 * a - 2 * o - s,
            i = 2 * r - 2 * a + o + s
        }
        return {
            initCatmullRom: function(e, t, n, i, a) {
                r(t, n, a * (n - e), a * (i - t))
            },
            initNonuniformCatmullRom: function(e, t, n, i, a, o, s) {
                var c = (t - e) / a - (n - e) / (a + o) + (n - t) / o
                  , h = (n - t) / o - (i - t) / (o + s) + (i - n) / s;
                r(t, n, c *= o, h *= o)
            },
            calc: function(r) {
                var a = r * r;
                return e + t * r + n * a + i * (a * r)
            }
        }
    }
    is.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: is,
        load: function(e, t, n, i) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var r = this
              , a = Qo.get(e);
            if (void 0 !== a)
                return r.manager.itemStart(e),
                setTimeout((function() {
                    t && t(a),
                    r.manager.itemEnd(e)
                }
                ), 0),
                a;
            if (void 0 === ns[e]) {
                var o = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (o) {
                    var s = o[1]
                      , c = !!o[2]
                      , h = o[3];
                    h = decodeURIComponent(h),
                    c && (h = atob(h));
                    try {
                        var l, u = (this.responseType || "").toLowerCase();
                        switch (u) {
                        case "arraybuffer":
                        case "blob":
                            for (var p = new Uint8Array(h.length), d = 0; d < h.length; d++)
                                p[d] = h.charCodeAt(d);
                            l = "blob" === u ? new Blob([p.buffer],{
                                type: s
                            }) : p.buffer;
                            break;
                        case "document":
                            var f = new DOMParser;
                            l = f.parseFromString(h, s);
                            break;
                        case "json":
                            l = JSON.parse(h);
                            break;
                        default:
                            l = h
                        }
                        setTimeout((function() {
                            t && t(l),
                            r.manager.itemEnd(e)
                        }
                        ), 0)
                    } catch (t) {
                        setTimeout((function() {
                            i && i(t),
                            r.manager.itemError(e),
                            r.manager.itemEnd(e)
                        }
                        ), 0)
                    }
                } else {
                    ns[e] = [],
                    ns[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                    var m = new XMLHttpRequest;
                    for (var v in m.open("GET", e, !0),
                    m.addEventListener("load", (function(t) {
                        var n = this.response
                          , i = ns[e];
                        if (delete ns[e],
                        200 === this.status || 0 === this.status) {
                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                            Qo.add(e, n);
                            for (var a = 0, o = i.length; a < o; a++) {
                                (s = i[a]).onLoad && s.onLoad(n)
                            }
                            r.manager.itemEnd(e)
                        } else {
                            for (a = 0,
                            o = i.length; a < o; a++) {
                                var s;
                                (s = i[a]).onError && s.onError(t)
                            }
                            r.manager.itemError(e),
                            r.manager.itemEnd(e)
                        }
                    }
                    ), !1),
                    m.addEventListener("progress", (function(t) {
                        for (var n = ns[e], i = 0, r = n.length; i < r; i++) {
                            var a = n[i];
                            a.onProgress && a.onProgress(t)
                        }
                    }
                    ), !1),
                    m.addEventListener("error", (function(t) {
                        var n = ns[e];
                        delete ns[e];
                        for (var i = 0, a = n.length; i < a; i++) {
                            var o = n[i];
                            o.onError && o.onError(t)
                        }
                        r.manager.itemError(e),
                        r.manager.itemEnd(e)
                    }
                    ), !1),
                    m.addEventListener("abort", (function(t) {
                        var n = ns[e];
                        delete ns[e];
                        for (var i = 0, a = n.length; i < a; i++) {
                            var o = n[i];
                            o.onError && o.onError(t)
                        }
                        r.manager.itemError(e),
                        r.manager.itemEnd(e)
                    }
                    ), !1),
                    void 0 !== this.responseType && (m.responseType = this.responseType),
                    void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials),
                    m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"),
                    this.requestHeader)
                        m.setRequestHeader(v, this.requestHeader[v]);
                    m.send(null)
                }
                return r.manager.itemStart(e),
                m
            }
            ns[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            })
        },
        setResponseType: function(e) {
            return this.responseType = e,
            this
        },
        setWithCredentials: function(e) {
            return this.withCredentials = e,
            this
        },
        setMimeType: function(e) {
            return this.mimeType = e,
            this
        }
    }),
    rs.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: rs,
        load: function(e, t, n, i) {
            var r = this
              , a = new is(r.manager);
            a.setPath(r.path),
            a.load(e, (function(n) {
                try {
                    t(r.parse(JSON.parse(n)))
                } catch (t) {
                    i ? i(t) : console.error(t),
                    r.manager.itemError(e)
                }
            }
            ), n, i)
        },
        parse: function(e) {
            for (var t = [], n = 0; n < e.length; n++) {
                var i = Jo.parse(e[n]);
                t.push(i)
            }
            return t
        }
    }),
    as.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: as,
        load: function(e, t, n, i) {
            var r = this
              , a = []
              , o = new oa;
            o.image = a;
            var s = new is(this.manager);
            function c(c) {
                s.load(e[c], (function(e) {
                    var n = r.parse(e, !0);
                    a[c] = {
                        width: n.width,
                        height: n.height,
                        format: n.format,
                        mipmaps: n.mipmaps
                    },
                    6 === (h += 1) && (1 === n.mipmapCount && (o.minFilter = 1006),
                    o.format = n.format,
                    o.needsUpdate = !0,
                    t && t(o))
                }
                ), n, i)
            }
            if (s.setPath(this.path),
            s.setResponseType("arraybuffer"),
            Array.isArray(e))
                for (var h = 0, l = 0, u = e.length; l < u; ++l)
                    c(l);
            else
                s.load(e, (function(e) {
                    var n = r.parse(e, !0);
                    if (n.isCubemap)
                        for (var i = n.mipmaps.length / n.mipmapCount, s = 0; s < i; s++) {
                            a[s] = {
                                mipmaps: []
                            };
                            for (var c = 0; c < n.mipmapCount; c++)
                                a[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]),
                                a[s].format = n.format,
                                a[s].width = n.width,
                                a[s].height = n.height
                        }
                    else
                        o.image.width = n.width,
                        o.image.height = n.height,
                        o.mipmaps = n.mipmaps;
                    1 === n.mipmapCount && (o.minFilter = 1006),
                    o.format = n.format,
                    o.needsUpdate = !0,
                    t && t(o)
                }
                ), n, i);
            return o
        }
    }),
    os.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: os,
        load: function(e, t, n, i) {
            var r = this
              , a = new qt
              , o = new is(this.manager);
            return o.setResponseType("arraybuffer"),
            o.setPath(this.path),
            o.load(e, (function(e) {
                var n = r.parse(e);
                n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width,
                a.image.height = n.height,
                a.image.data = n.data),
                a.wrapS = void 0 !== n.wrapS ? n.wrapS : 1001,
                a.wrapT = void 0 !== n.wrapT ? n.wrapT : 1001,
                a.magFilter = void 0 !== n.magFilter ? n.magFilter : 1006,
                a.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006,
                a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                void 0 !== n.format && (a.format = n.format),
                void 0 !== n.type && (a.type = n.type),
                void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps,
                a.minFilter = 1008),
                1 === n.mipmapCount && (a.minFilter = 1006),
                a.needsUpdate = !0,
                t && t(a, n))
            }
            ), n, i),
            a
        }
    }),
    ss.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: ss,
        load: function(e, t, n, i) {
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var r = this
              , a = Qo.get(e);
            if (void 0 !== a)
                return r.manager.itemStart(e),
                setTimeout((function() {
                    t && t(a),
                    r.manager.itemEnd(e)
                }
                ), 0),
                a;
            var o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            function s() {
                o.removeEventListener("load", s, !1),
                o.removeEventListener("error", c, !1),
                Qo.add(e, this),
                t && t(this),
                r.manager.itemEnd(e)
            }
            function c(t) {
                o.removeEventListener("load", s, !1),
                o.removeEventListener("error", c, !1),
                i && i(t),
                r.manager.itemError(e),
                r.manager.itemEnd(e)
            }
            return o.addEventListener("load", s, !1),
            o.addEventListener("error", c, !1),
            "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin),
            r.manager.itemStart(e),
            o.src = e,
            o
        }
    }),
    cs.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: cs,
        load: function(e, t, n, i) {
            var r = new mn
              , a = new ss(this.manager);
            a.setCrossOrigin(this.crossOrigin),
            a.setPath(this.path);
            var o = 0;
            function s(n) {
                a.load(e[n], (function(e) {
                    r.images[n] = e,
                    6 === ++o && (r.needsUpdate = !0,
                    t && t(r))
                }
                ), void 0, i)
            }
            for (var c = 0; c < e.length; ++c)
                s(c);
            return r
        }
    }),
    hs.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: hs,
        load: function(e, t, n, i) {
            var r = new d
              , a = new ss(this.manager);
            return a.setCrossOrigin(this.crossOrigin),
            a.setPath(this.path),
            a.load(e, (function(n) {
                r.image = n;
                var i = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                r.format = i ? 1022 : 1023,
                r.needsUpdate = !0,
                void 0 !== t && t(r)
            }
            ), n, i),
            r
        }
    }),
    Object.assign(ls.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        },
        getPointAt: function(e, t) {
            var n = this.getUtoTmapping(e);
            return this.getPoint(n, t)
        },
        getPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], n = 0; n <= e; n++)
                t.push(this.getPoint(n / e));
            return t
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], n = 0; n <= e; n++)
                t.push(this.getPointAt(n / e));
            return t
        },
        getLength: function() {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function(e) {
            if (void 0 === e && (e = this.arcLengthDivisions),
            this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, n, i = [], r = this.getPoint(0), a = 0;
            for (i.push(0),
            n = 1; n <= e; n++)
                a += (t = this.getPoint(n / e)).distanceTo(r),
                i.push(a),
                r = t;
            return this.cacheArcLengths = i,
            i
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.getLengths()
        },
        getUtoTmapping: function(e, t) {
            var n, i = this.getLengths(), r = 0, a = i.length;
            n = t || e * i[a - 1];
            for (var o, s = 0, c = a - 1; s <= c; )
                if ((o = i[r = Math.floor(s + (c - s) / 2)] - n) < 0)
                    s = r + 1;
                else {
                    if (!(o > 0)) {
                        c = r;
                        break
                    }
                    c = r - 1
                }
            if (i[r = c] === n)
                return r / (a - 1);
            var h = i[r];
            return (r + (n - h) / (i[r + 1] - h)) / (a - 1)
        },
        getTangent: function(e, t) {
            var n = e - 1e-4
              , i = e + 1e-4;
            n < 0 && (n = 0),
            i > 1 && (i = 1);
            var r = this.getPoint(n)
              , a = this.getPoint(i)
              , o = t || (r.isVector2 ? new h : new b);
            return o.copy(a).sub(r).normalize(),
            o
        },
        getTangentAt: function(e, t) {
            var n = this.getUtoTmapping(e);
            return this.getTangent(n, t)
        },
        computeFrenetFrames: function(e, t) {
            var n, i, r, a = new b, o = [], s = [], h = [], l = new b, u = new L;
            for (n = 0; n <= e; n++)
                i = n / e,
                o[n] = this.getTangentAt(i, new b),
                o[n].normalize();
            s[0] = new b,
            h[0] = new b;
            var p = Number.MAX_VALUE
              , d = Math.abs(o[0].x)
              , f = Math.abs(o[0].y)
              , m = Math.abs(o[0].z);
            for (d <= p && (p = d,
            a.set(1, 0, 0)),
            f <= p && (p = f,
            a.set(0, 1, 0)),
            m <= p && a.set(0, 0, 1),
            l.crossVectors(o[0], a).normalize(),
            s[0].crossVectors(o[0], l),
            h[0].crossVectors(o[0], s[0]),
            n = 1; n <= e; n++)
                s[n] = s[n - 1].clone(),
                h[n] = h[n - 1].clone(),
                l.crossVectors(o[n - 1], o[n]),
                l.length() > Number.EPSILON && (l.normalize(),
                r = Math.acos(c.clamp(o[n - 1].dot(o[n]), -1, 1)),
                s[n].applyMatrix4(u.makeRotationAxis(l, r))),
                h[n].crossVectors(o[n], s[n]);
            if (!0 === t)
                for (r = Math.acos(c.clamp(s[0].dot(s[e]), -1, 1)),
                r /= e,
                o[0].dot(l.crossVectors(s[0], s[e])) > 0 && (r = -r),
                n = 1; n <= e; n++)
                    s[n].applyMatrix4(u.makeRotationAxis(o[n], r * n)),
                    h[n].crossVectors(o[n], s[n]);
            return {
                tangents: o,
                normals: s,
                binormals: h
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions,
            e.type = this.type,
            e
        },
        fromJSON: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        }
    }),
    us.prototype = Object.create(ls.prototype),
    us.prototype.constructor = us,
    us.prototype.isEllipseCurve = !0,
    us.prototype.getPoint = function(e, t) {
        for (var n = t || new h, i = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; r < 0; )
            r += i;
        for (; r > i; )
            r -= i;
        r < Number.EPSILON && (r = a ? 0 : i),
        !0 !== this.aClockwise || a || (r === i ? r = -i : r -= i);
        var o = this.aStartAngle + e * r
          , s = this.aX + this.xRadius * Math.cos(o)
          , c = this.aY + this.yRadius * Math.sin(o);
        if (0 !== this.aRotation) {
            var l = Math.cos(this.aRotation)
              , u = Math.sin(this.aRotation)
              , p = s - this.aX
              , d = c - this.aY;
            s = p * l - d * u + this.aX,
            c = p * u + d * l + this.aY
        }
        return n.set(s, c)
    }
    ,
    us.prototype.copy = function(e) {
        return ls.prototype.copy.call(this, e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    ,
    us.prototype.toJSON = function() {
        var e = ls.prototype.toJSON.call(this);
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    ,
    us.prototype.fromJSON = function(e) {
        return ls.prototype.fromJSON.call(this, e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    ,
    ps.prototype = Object.create(us.prototype),
    ps.prototype.constructor = ps,
    ps.prototype.isArcCurve = !0;
    var fs = new b
      , ms = new ds
      , vs = new ds
      , gs = new ds;
    function ys(e, t, n, i) {
        ls.call(this),
        this.type = "CatmullRomCurve3",
        this.points = e || [],
        this.closed = t || !1,
        this.curveType = n || "centripetal",
        this.tension = i || .5
    }
    function xs(e, t, n, i, r) {
        var a = .5 * (i - t)
          , o = .5 * (r - n)
          , s = e * e;
        return (2 * n - 2 * i + a + o) * (e * s) + (-3 * n + 3 * i - 2 * a - o) * s + a * e + n
    }
    function bs(e, t, n, i) {
        return function(e, t) {
            var n = 1 - e;
            return n * n * t
        }(e, t) + function(e, t) {
            return 2 * (1 - e) * e * t
        }(e, n) + function(e, t) {
            return e * e * t
        }(e, i)
    }
    function _s(e, t, n, i, r) {
        return function(e, t) {
            var n = 1 - e;
            return n * n * n * t
        }(e, t) + function(e, t) {
            var n = 1 - e;
            return 3 * n * n * e * t
        }(e, n) + function(e, t) {
            return 3 * (1 - e) * e * e * t
        }(e, i) + function(e, t) {
            return e * e * e * t
        }(e, r)
    }
    function ws(e, t, n, i) {
        ls.call(this),
        this.type = "CubicBezierCurve",
        this.v0 = e || new h,
        this.v1 = t || new h,
        this.v2 = n || new h,
        this.v3 = i || new h
    }
    function Ms(e, t, n, i) {
        ls.call(this),
        this.type = "CubicBezierCurve3",
        this.v0 = e || new b,
        this.v1 = t || new b,
        this.v2 = n || new b,
        this.v3 = i || new b
    }
    function Ss(e, t) {
        ls.call(this),
        this.type = "LineCurve",
        this.v1 = e || new h,
        this.v2 = t || new h
    }
    function Ts(e, t) {
        ls.call(this),
        this.type = "LineCurve3",
        this.v1 = e || new b,
        this.v2 = t || new b
    }
    function Es(e, t, n) {
        ls.call(this),
        this.type = "QuadraticBezierCurve",
        this.v0 = e || new h,
        this.v1 = t || new h,
        this.v2 = n || new h
    }
    function As(e, t, n) {
        ls.call(this),
        this.type = "QuadraticBezierCurve3",
        this.v0 = e || new b,
        this.v1 = t || new b,
        this.v2 = n || new b
    }
    function Ls(e) {
        ls.call(this),
        this.type = "SplineCurve",
        this.points = e || []
    }
    ys.prototype = Object.create(ls.prototype),
    ys.prototype.constructor = ys,
    ys.prototype.isCatmullRomCurve3 = !0,
    ys.prototype.getPoint = function(e, t) {
        var n, i, r, a, o = t || new b, s = this.points, c = s.length, h = (c - (this.closed ? 0 : 1)) * e, l = Math.floor(h), u = h - l;
        if (this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / c) + 1) * c : 0 === u && l === c - 1 && (l = c - 2,
        u = 1),
        this.closed || l > 0 ? n = s[(l - 1) % c] : (fs.subVectors(s[0], s[1]).add(s[0]),
        n = fs),
        i = s[l % c],
        r = s[(l + 1) % c],
        this.closed || l + 2 < c ? a = s[(l + 2) % c] : (fs.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]),
        a = fs),
        "centripetal" === this.curveType || "chordal" === this.curveType) {
            var p = "chordal" === this.curveType ? .5 : .25
              , d = Math.pow(n.distanceToSquared(i), p)
              , f = Math.pow(i.distanceToSquared(r), p)
              , m = Math.pow(r.distanceToSquared(a), p);
            f < 1e-4 && (f = 1),
            d < 1e-4 && (d = f),
            m < 1e-4 && (m = f),
            ms.initNonuniformCatmullRom(n.x, i.x, r.x, a.x, d, f, m),
            vs.initNonuniformCatmullRom(n.y, i.y, r.y, a.y, d, f, m),
            gs.initNonuniformCatmullRom(n.z, i.z, r.z, a.z, d, f, m)
        } else
            "catmullrom" === this.curveType && (ms.initCatmullRom(n.x, i.x, r.x, a.x, this.tension),
            vs.initCatmullRom(n.y, i.y, r.y, a.y, this.tension),
            gs.initCatmullRom(n.z, i.z, r.z, a.z, this.tension));
        return o.set(ms.calc(u), vs.calc(u), gs.calc(u)),
        o
    }
    ,
    ys.prototype.copy = function(e) {
        ls.prototype.copy.call(this, e),
        this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var i = e.points[t];
            this.points.push(i.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    ,
    ys.prototype.toJSON = function() {
        var e = ls.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, n = this.points.length; t < n; t++) {
            var i = this.points[t];
            e.points.push(i.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    ,
    ys.prototype.fromJSON = function(e) {
        ls.prototype.fromJSON.call(this, e),
        this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var i = e.points[t];
            this.points.push((new b).fromArray(i))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    ,
    ws.prototype = Object.create(ls.prototype),
    ws.prototype.constructor = ws,
    ws.prototype.isCubicBezierCurve = !0,
    ws.prototype.getPoint = function(e, t) {
        var n = t || new h
          , i = this.v0
          , r = this.v1
          , a = this.v2
          , o = this.v3;
        return n.set(_s(e, i.x, r.x, a.x, o.x), _s(e, i.y, r.y, a.y, o.y)),
        n
    }
    ,
    ws.prototype.copy = function(e) {
        return ls.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    ,
    ws.prototype.toJSON = function() {
        var e = ls.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    ,
    ws.prototype.fromJSON = function(e) {
        return ls.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
    ,
    Ms.prototype = Object.create(ls.prototype),
    Ms.prototype.constructor = Ms,
    Ms.prototype.isCubicBezierCurve3 = !0,
    Ms.prototype.getPoint = function(e, t) {
        var n = t || new b
          , i = this.v0
          , r = this.v1
          , a = this.v2
          , o = this.v3;
        return n.set(_s(e, i.x, r.x, a.x, o.x), _s(e, i.y, r.y, a.y, o.y), _s(e, i.z, r.z, a.z, o.z)),
        n
    }
    ,
    Ms.prototype.copy = function(e) {
        return ls.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    ,
    Ms.prototype.toJSON = function() {
        var e = ls.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    ,
    Ms.prototype.fromJSON = function(e) {
        return ls.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
    ,
    Ss.prototype = Object.create(ls.prototype),
    Ss.prototype.constructor = Ss,
    Ss.prototype.isLineCurve = !0,
    Ss.prototype.getPoint = function(e, t) {
        var n = t || new h;
        return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(e).add(this.v1)),
        n
    }
    ,
    Ss.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }
    ,
    Ss.prototype.getTangent = function(e, t) {
        return (t || new h).copy(this.v2).sub(this.v1).normalize()
    }
    ,
    Ss.prototype.copy = function(e) {
        return ls.prototype.copy.call(this, e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    Ss.prototype.toJSON = function() {
        var e = ls.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    Ss.prototype.fromJSON = function(e) {
        return ls.prototype.fromJSON.call(this, e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    Ts.prototype = Object.create(ls.prototype),
    Ts.prototype.constructor = Ts,
    Ts.prototype.isLineCurve3 = !0,
    Ts.prototype.getPoint = function(e, t) {
        var n = t || new b;
        return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(e).add(this.v1)),
        n
    }
    ,
    Ts.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }
    ,
    Ts.prototype.copy = function(e) {
        return ls.prototype.copy.call(this, e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    Ts.prototype.toJSON = function() {
        var e = ls.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    Ts.prototype.fromJSON = function(e) {
        return ls.prototype.fromJSON.call(this, e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    Es.prototype = Object.create(ls.prototype),
    Es.prototype.constructor = Es,
    Es.prototype.isQuadraticBezierCurve = !0,
    Es.prototype.getPoint = function(e, t) {
        var n = t || new h
          , i = this.v0
          , r = this.v1
          , a = this.v2;
        return n.set(bs(e, i.x, r.x, a.x), bs(e, i.y, r.y, a.y)),
        n
    }
    ,
    Es.prototype.copy = function(e) {
        return ls.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    Es.prototype.toJSON = function() {
        var e = ls.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    Es.prototype.fromJSON = function(e) {
        return ls.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    As.prototype = Object.create(ls.prototype),
    As.prototype.constructor = As,
    As.prototype.isQuadraticBezierCurve3 = !0,
    As.prototype.getPoint = function(e, t) {
        var n = t || new b
          , i = this.v0
          , r = this.v1
          , a = this.v2;
        return n.set(bs(e, i.x, r.x, a.x), bs(e, i.y, r.y, a.y), bs(e, i.z, r.z, a.z)),
        n
    }
    ,
    As.prototype.copy = function(e) {
        return ls.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    As.prototype.toJSON = function() {
        var e = ls.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    As.prototype.fromJSON = function(e) {
        return ls.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    Ls.prototype = Object.create(ls.prototype),
    Ls.prototype.constructor = Ls,
    Ls.prototype.isSplineCurve = !0,
    Ls.prototype.getPoint = function(e, t) {
        var n = t || new h
          , i = this.points
          , r = (i.length - 1) * e
          , a = Math.floor(r)
          , o = r - a
          , s = i[0 === a ? a : a - 1]
          , c = i[a]
          , l = i[a > i.length - 2 ? i.length - 1 : a + 1]
          , u = i[a > i.length - 3 ? i.length - 1 : a + 2];
        return n.set(xs(o, s.x, c.x, l.x, u.x), xs(o, s.y, c.y, l.y, u.y)),
        n
    }
    ,
    Ls.prototype.copy = function(e) {
        ls.prototype.copy.call(this, e),
        this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var i = e.points[t];
            this.points.push(i.clone())
        }
        return this
    }
    ,
    Ls.prototype.toJSON = function() {
        var e = ls.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, n = this.points.length; t < n; t++) {
            var i = this.points[t];
            e.points.push(i.toArray())
        }
        return e
    }
    ,
    Ls.prototype.fromJSON = function(e) {
        ls.prototype.fromJSON.call(this, e),
        this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var i = e.points[t];
            this.points.push((new h).fromArray(i))
        }
        return this
    }
    ;
    var Rs = Object.freeze({
        __proto__: null,
        ArcCurve: ps,
        CatmullRomCurve3: ys,
        CubicBezierCurve: ws,
        CubicBezierCurve3: Ms,
        EllipseCurve: us,
        LineCurve: Ss,
        LineCurve3: Ts,
        QuadraticBezierCurve: Es,
        QuadraticBezierCurve3: As,
        SplineCurve: Ls
    });
    function Ps() {
        ls.call(this),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    function Cs(e) {
        Ps.call(this),
        this.type = "Path",
        this.currentPoint = new h,
        e && this.setFromPoints(e)
    }
    function Os(e) {
        Cs.call(this, e),
        this.uuid = c.generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    function Is(e, t) {
        q.call(this),
        this.type = "Light",
        this.color = new ze(e),
        this.intensity = void 0 !== t ? t : 1,
        this.receiveShadow = void 0
    }
    function Ds(e, t, n) {
        Is.call(this, e, n),
        this.type = "HemisphereLight",
        this.castShadow = void 0,
        this.position.copy(q.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new ze(t)
    }
    function Ns(e) {
        this.camera = e,
        this.bias = 0,
        this.radius = 1,
        this.mapSize = new h(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new L,
        this._frustum = new Zt,
        this._frameExtents = new h(1,1),
        this._viewportCount = 1,
        this._viewports = [new f(0,0,1,1)]
    }
    function Us() {
        Ns.call(this, new Vt(50,1,.5,500))
    }
    function zs(e, t, n, i, r, a) {
        Is.call(this, e, t),
        this.type = "SpotLight",
        this.position.copy(q.DefaultUp),
        this.updateMatrix(),
        this.target = new q,
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / Math.PI
            }
        }),
        this.distance = void 0 !== n ? n : 0,
        this.angle = void 0 !== i ? i : Math.PI / 3,
        this.penumbra = void 0 !== r ? r : 0,
        this.decay = void 0 !== a ? a : 1,
        this.shadow = new Us
    }
    function Bs() {
        Ns.call(this, new Vt(90,1,.5,500)),
        this._frameExtents = new h(4,2),
        this._viewportCount = 6,
        this._viewports = [new f(2,1,1,1), new f(0,1,1,1), new f(3,1,1,1), new f(1,1,1,1), new f(3,0,1,1), new f(1,0,1,1)],
        this._cubeDirections = [new b(1,0,0), new b(-1,0,0), new b(0,0,1), new b(0,0,-1), new b(0,1,0), new b(0,-1,0)],
        this._cubeUps = [new b(0,1,0), new b(0,1,0), new b(0,1,0), new b(0,1,0), new b(0,0,1), new b(0,0,-1)]
    }
    function Fs(e, t, n, i) {
        Is.call(this, e, t),
        this.type = "PointLight",
        Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / (4 * Math.PI)
            }
        }),
        this.distance = void 0 !== n ? n : 0,
        this.decay = void 0 !== i ? i : 1,
        this.shadow = new Bs
    }
    function Hs(e, t, n, i, r, a) {
        Gt.call(this),
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = void 0 !== e ? e : -1,
        this.right = void 0 !== t ? t : 1,
        this.top = void 0 !== n ? n : 1,
        this.bottom = void 0 !== i ? i : -1,
        this.near = void 0 !== r ? r : .1,
        this.far = void 0 !== a ? a : 2e3,
        this.updateProjectionMatrix()
    }
    function ks() {
        Ns.call(this, new Hs(-5,5,5,-5,.5,500))
    }
    function Gs(e, t) {
        Is.call(this, e, t),
        this.type = "DirectionalLight",
        this.position.copy(q.DefaultUp),
        this.updateMatrix(),
        this.target = new q,
        this.shadow = new ks
    }
    function Vs(e, t) {
        Is.call(this, e, t),
        this.type = "AmbientLight",
        this.castShadow = void 0
    }
    function js(e, t, n, i) {
        Is.call(this, e, t),
        this.type = "RectAreaLight",
        this.width = void 0 !== n ? n : 10,
        this.height = void 0 !== i ? i : 10
    }
    function Ws() {
        this.coefficients = [];
        for (var e = 0; e < 9; e++)
            this.coefficients.push(new b)
    }
    function qs(e, t) {
        Is.call(this, void 0, t),
        this.type = "LightProbe",
        this.sh = void 0 !== e ? e : new Ws
    }
    function Xs(e) {
        ts.call(this, e),
        this.textures = {}
    }
    Ps.prototype = Object.assign(Object.create(ls.prototype), {
        constructor: Ps,
        add: function(e) {
            this.curves.push(e)
        },
        closePath: function() {
            var e = this.curves[0].getPoint(0)
              , t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new Ss(t,e))
        },
        getPoint: function(e) {
            for (var t = e * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length; ) {
                if (n[i] >= t) {
                    var r = n[i] - t
                      , a = this.curves[i]
                      , o = a.getLength()
                      , s = 0 === o ? 0 : 1 - r / o;
                    return a.getPointAt(s)
                }
                i++
            }
            return null
        },
        getLength: function() {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            for (var e = [], t = 0, n = 0, i = this.curves.length; n < i; n++)
                t += this.curves[n].getLength(),
                e.push(t);
            return this.cacheLengths = e,
            e
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 40);
            for (var t = [], n = 0; n <= e; n++)
                t.push(this.getPoint(n / e));
            return this.autoClose && t.push(t[0]),
            t
        },
        getPoints: function(e) {
            e = e || 12;
            for (var t, n = [], i = 0, r = this.curves; i < r.length; i++)
                for (var a = r[i], o = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e, s = a.getPoints(o), c = 0; c < s.length; c++) {
                    var h = s[c];
                    t && t.equals(h) || (n.push(h),
                    t = h)
                }
            return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]),
            n
        },
        copy: function(e) {
            ls.prototype.copy.call(this, e),
            this.curves = [];
            for (var t = 0, n = e.curves.length; t < n; t++) {
                var i = e.curves[t];
                this.curves.push(i.clone())
            }
            return this.autoClose = e.autoClose,
            this
        },
        toJSON: function() {
            var e = ls.prototype.toJSON.call(this);
            e.autoClose = this.autoClose,
            e.curves = [];
            for (var t = 0, n = this.curves.length; t < n; t++) {
                var i = this.curves[t];
                e.curves.push(i.toJSON())
            }
            return e
        },
        fromJSON: function(e) {
            ls.prototype.fromJSON.call(this, e),
            this.autoClose = e.autoClose,
            this.curves = [];
            for (var t = 0, n = e.curves.length; t < n; t++) {
                var i = e.curves[t];
                this.curves.push((new Rs[i.type]).fromJSON(i))
            }
            return this
        }
    }),
    Cs.prototype = Object.assign(Object.create(Ps.prototype), {
        constructor: Cs,
        setFromPoints: function(e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, n = e.length; t < n; t++)
                this.lineTo(e[t].x, e[t].y);
            return this
        },
        moveTo: function(e, t) {
            return this.currentPoint.set(e, t),
            this
        },
        lineTo: function(e, t) {
            var n = new Ss(this.currentPoint.clone(),new h(e,t));
            return this.curves.push(n),
            this.currentPoint.set(e, t),
            this
        },
        quadraticCurveTo: function(e, t, n, i) {
            var r = new Es(this.currentPoint.clone(),new h(e,t),new h(n,i));
            return this.curves.push(r),
            this.currentPoint.set(n, i),
            this
        },
        bezierCurveTo: function(e, t, n, i, r, a) {
            var o = new ws(this.currentPoint.clone(),new h(e,t),new h(n,i),new h(r,a));
            return this.curves.push(o),
            this.currentPoint.set(r, a),
            this
        },
        splineThru: function(e) {
            var t = new Ls([this.currentPoint.clone()].concat(e));
            return this.curves.push(t),
            this.currentPoint.copy(e[e.length - 1]),
            this
        },
        arc: function(e, t, n, i, r, a) {
            var o = this.currentPoint.x
              , s = this.currentPoint.y;
            return this.absarc(e + o, t + s, n, i, r, a),
            this
        },
        absarc: function(e, t, n, i, r, a) {
            return this.absellipse(e, t, n, n, i, r, a),
            this
        },
        ellipse: function(e, t, n, i, r, a, o, s) {
            var c = this.currentPoint.x
              , h = this.currentPoint.y;
            return this.absellipse(e + c, t + h, n, i, r, a, o, s),
            this
        },
        absellipse: function(e, t, n, i, r, a, o, s) {
            var c = new us(e,t,n,i,r,a,o,s);
            if (this.curves.length > 0) {
                var h = c.getPoint(0);
                h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
            }
            this.curves.push(c);
            var l = c.getPoint(1);
            return this.currentPoint.copy(l),
            this
        },
        copy: function(e) {
            return Ps.prototype.copy.call(this, e),
            this.currentPoint.copy(e.currentPoint),
            this
        },
        toJSON: function() {
            var e = Ps.prototype.toJSON.call(this);
            return e.currentPoint = this.currentPoint.toArray(),
            e
        },
        fromJSON: function(e) {
            return Ps.prototype.fromJSON.call(this, e),
            this.currentPoint.fromArray(e.currentPoint),
            this
        }
    }),
    Os.prototype = Object.assign(Object.create(Cs.prototype), {
        constructor: Os,
        getPointsHoles: function(e) {
            for (var t = [], n = 0, i = this.holes.length; n < i; n++)
                t[n] = this.holes[n].getPoints(e);
            return t
        },
        extractPoints: function(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        copy: function(e) {
            Cs.prototype.copy.call(this, e),
            this.holes = [];
            for (var t = 0, n = e.holes.length; t < n; t++) {
                var i = e.holes[t];
                this.holes.push(i.clone())
            }
            return this
        },
        toJSON: function() {
            var e = Cs.prototype.toJSON.call(this);
            e.uuid = this.uuid,
            e.holes = [];
            for (var t = 0, n = this.holes.length; t < n; t++) {
                var i = this.holes[t];
                e.holes.push(i.toJSON())
            }
            return e
        },
        fromJSON: function(e) {
            Cs.prototype.fromJSON.call(this, e),
            this.uuid = e.uuid,
            this.holes = [];
            for (var t = 0, n = e.holes.length; t < n; t++) {
                var i = e.holes[t];
                this.holes.push((new Cs).fromJSON(i))
            }
            return this
        }
    }),
    Is.prototype = Object.assign(Object.create(q.prototype), {
        constructor: Is,
        isLight: !0,
        copy: function(e) {
            return q.prototype.copy.call(this, e),
            this.color.copy(e.color),
            this.intensity = e.intensity,
            this
        },
        toJSON: function(e) {
            var t = q.prototype.toJSON.call(this, e);
            return t.object.color = this.color.getHex(),
            t.object.intensity = this.intensity,
            void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            t
        }
    }),
    Ds.prototype = Object.assign(Object.create(Is.prototype), {
        constructor: Ds,
        isHemisphereLight: !0,
        copy: function(e) {
            return Is.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
        }
    }),
    Object.assign(Ns.prototype, {
        _projScreenMatrix: new L,
        _lightPositionWorld: new b,
        _lookTarget: new b,
        getViewportCount: function() {
            return this._viewportCount
        },
        getFrustum: function() {
            return this._frustum
        },
        updateMatrices: function(e) {
            var t = this.camera
              , n = this.matrix
              , i = this._projScreenMatrix
              , r = this._lookTarget
              , a = this._lightPositionWorld;
            a.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(a),
            r.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(r),
            t.updateMatrixWorld(),
            i.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(i),
            n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            n.multiply(t.projectionMatrix),
            n.multiply(t.matrixWorldInverse)
        },
        getViewport: function(e) {
            return this._viewports[e]
        },
        getFrameExtents: function() {
            return this._frameExtents
        },
        copy: function(e) {
            return this.camera = e.camera.clone(),
            this.bias = e.bias,
            this.radius = e.radius,
            this.mapSize.copy(e.mapSize),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias),
            1 !== this.radius && (e.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
            e.camera = this.camera.toJSON(!1).object,
            delete e.camera.matrix,
            e
        }
    }),
    Us.prototype = Object.assign(Object.create(Ns.prototype), {
        constructor: Us,
        isSpotLightShadow: !0,
        updateMatrices: function(e) {
            var t = this.camera
              , n = 2 * c.RAD2DEG * e.angle
              , i = this.mapSize.width / this.mapSize.height
              , r = e.distance || t.far;
            n === t.fov && i === t.aspect && r === t.far || (t.fov = n,
            t.aspect = i,
            t.far = r,
            t.updateProjectionMatrix()),
            Ns.prototype.updateMatrices.call(this, e)
        }
    }),
    zs.prototype = Object.assign(Object.create(Is.prototype), {
        constructor: zs,
        isSpotLight: !0,
        copy: function(e) {
            return Is.prototype.copy.call(this, e),
            this.distance = e.distance,
            this.angle = e.angle,
            this.penumbra = e.penumbra,
            this.decay = e.decay,
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    Bs.prototype = Object.assign(Object.create(Ns.prototype), {
        constructor: Bs,
        isPointLightShadow: !0,
        updateMatrices: function(e, t) {
            void 0 === t && (t = 0);
            var n = this.camera
              , i = this.matrix
              , r = this._lightPositionWorld
              , a = this._lookTarget
              , o = this._projScreenMatrix;
            r.setFromMatrixPosition(e.matrixWorld),
            n.position.copy(r),
            a.copy(n.position),
            a.add(this._cubeDirections[t]),
            n.up.copy(this._cubeUps[t]),
            n.lookAt(a),
            n.updateMatrixWorld(),
            i.makeTranslation(-r.x, -r.y, -r.z),
            o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(o)
        }
    }),
    Fs.prototype = Object.assign(Object.create(Is.prototype), {
        constructor: Fs,
        isPointLight: !0,
        copy: function(e) {
            return Is.prototype.copy.call(this, e),
            this.distance = e.distance,
            this.decay = e.decay,
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    Hs.prototype = Object.assign(Object.create(Gt.prototype), {
        constructor: Hs,
        isOrthographicCamera: !0,
        copy: function(e, t) {
            return Gt.prototype.copy.call(this, e, t),
            this.left = e.left,
            this.right = e.right,
            this.top = e.top,
            this.bottom = e.bottom,
            this.near = e.near,
            this.far = e.far,
            this.zoom = e.zoom,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this
        },
        setViewOffset: function(e, t, n, i, r, a) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = n,
            this.view.offsetY = i,
            this.view.width = r,
            this.view.height = a,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = (this.right - this.left) / (2 * this.zoom)
              , t = (this.top - this.bottom) / (2 * this.zoom)
              , n = (this.right + this.left) / 2
              , i = (this.top + this.bottom) / 2
              , r = n - e
              , a = n + e
              , o = i + t
              , s = i - t;
            if (null !== this.view && this.view.enabled) {
                var c = (this.right - this.left) / this.view.fullWidth / this.zoom
                  , h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                a = (r += c * this.view.offsetX) + c * this.view.width,
                s = (o -= h * this.view.offsetY) - h * this.view.height
            }
            this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            var t = q.prototype.toJSON.call(this, e);
            return t.object.zoom = this.zoom,
            t.object.left = this.left,
            t.object.right = this.right,
            t.object.top = this.top,
            t.object.bottom = this.bottom,
            t.object.near = this.near,
            t.object.far = this.far,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t
        }
    }),
    ks.prototype = Object.assign(Object.create(Ns.prototype), {
        constructor: ks,
        isDirectionalLightShadow: !0,
        updateMatrices: function(e) {
            Ns.prototype.updateMatrices.call(this, e)
        }
    }),
    Gs.prototype = Object.assign(Object.create(Is.prototype), {
        constructor: Gs,
        isDirectionalLight: !0,
        copy: function(e) {
            return Is.prototype.copy.call(this, e),
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    Vs.prototype = Object.assign(Object.create(Is.prototype), {
        constructor: Vs,
        isAmbientLight: !0
    }),
    js.prototype = Object.assign(Object.create(Is.prototype), {
        constructor: js,
        isRectAreaLight: !0,
        copy: function(e) {
            return Is.prototype.copy.call(this, e),
            this.width = e.width,
            this.height = e.height,
            this
        },
        toJSON: function(e) {
            var t = Is.prototype.toJSON.call(this, e);
            return t.object.width = this.width,
            t.object.height = this.height,
            t
        }
    }),
    Object.assign(Ws.prototype, {
        isSphericalHarmonics3: !0,
        set: function(e) {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].copy(e[t]);
            return this
        },
        zero: function() {
            for (var e = 0; e < 9; e++)
                this.coefficients[e].set(0, 0, 0);
            return this
        },
        getAt: function(e, t) {
            var n = e.x
              , i = e.y
              , r = e.z
              , a = this.coefficients;
            return t.copy(a[0]).multiplyScalar(.282095),
            t.addScaledVector(a[1], .488603 * i),
            t.addScaledVector(a[2], .488603 * r),
            t.addScaledVector(a[3], .488603 * n),
            t.addScaledVector(a[4], n * i * 1.092548),
            t.addScaledVector(a[5], i * r * 1.092548),
            t.addScaledVector(a[6], .315392 * (3 * r * r - 1)),
            t.addScaledVector(a[7], n * r * 1.092548),
            t.addScaledVector(a[8], .546274 * (n * n - i * i)),
            t
        },
        getIrradianceAt: function(e, t) {
            var n = e.x
              , i = e.y
              , r = e.z
              , a = this.coefficients;
            return t.copy(a[0]).multiplyScalar(.886227),
            t.addScaledVector(a[1], 1.023328 * i),
            t.addScaledVector(a[2], 1.023328 * r),
            t.addScaledVector(a[3], 1.023328 * n),
            t.addScaledVector(a[4], .858086 * n * i),
            t.addScaledVector(a[5], .858086 * i * r),
            t.addScaledVector(a[6], .743125 * r * r - .247708),
            t.addScaledVector(a[7], .858086 * n * r),
            t.addScaledVector(a[8], .429043 * (n * n - i * i)),
            t
        },
        add: function(e) {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].add(e.coefficients[t]);
            return this
        },
        addScaledSH: function(e, t) {
            for (var n = 0; n < 9; n++)
                this.coefficients[n].addScaledVector(e.coefficients[n], t);
            return this
        },
        scale: function(e) {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].multiplyScalar(e);
            return this
        },
        lerp: function(e, t) {
            for (var n = 0; n < 9; n++)
                this.coefficients[n].lerp(e.coefficients[n], t);
            return this
        },
        equals: function(e) {
            for (var t = 0; t < 9; t++)
                if (!this.coefficients[t].equals(e.coefficients[t]))
                    return !1;
            return !0
        },
        copy: function(e) {
            return this.set(e.coefficients)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var n = this.coefficients, i = 0; i < 9; i++)
                n[i].fromArray(e, t + 3 * i);
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []),
            void 0 === t && (t = 0);
            for (var n = this.coefficients, i = 0; i < 9; i++)
                n[i].toArray(e, t + 3 * i);
            return e
        }
    }),
    Object.assign(Ws, {
        getBasisAt: function(e, t) {
            var n = e.x
              , i = e.y
              , r = e.z;
            t[0] = .282095,
            t[1] = .488603 * i,
            t[2] = .488603 * r,
            t[3] = .488603 * n,
            t[4] = 1.092548 * n * i,
            t[5] = 1.092548 * i * r,
            t[6] = .315392 * (3 * r * r - 1),
            t[7] = 1.092548 * n * r,
            t[8] = .546274 * (n * n - i * i)
        }
    }),
    qs.prototype = Object.assign(Object.create(Is.prototype), {
        constructor: qs,
        isLightProbe: !0,
        copy: function(e) {
            return Is.prototype.copy.call(this, e),
            this.sh.copy(e.sh),
            this
        },
        fromJSON: function(e) {
            return this.intensity = e.intensity,
            this.sh.fromArray(e.sh),
            this
        },
        toJSON: function(e) {
            var t = Is.prototype.toJSON.call(this, e);
            return t.object.sh = this.sh.toArray(),
            t
        }
    }),
    Xs.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: Xs,
        load: function(e, t, n, i) {
            var r = this
              , a = new is(r.manager);
            a.setPath(r.path),
            a.load(e, (function(n) {
                try {
                    t(r.parse(JSON.parse(n)))
                } catch (t) {
                    i ? i(t) : console.error(t),
                    r.manager.itemError(e)
                }
            }
            ), n, i)
        },
        parse: function(e) {
            var t = this.textures;
            function n(e) {
                return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e),
                t[e]
            }
            var i = new Uo[e.type];
            if (void 0 !== e.uuid && (i.uuid = e.uuid),
            void 0 !== e.name && (i.name = e.name),
            void 0 !== e.color && i.color.setHex(e.color),
            void 0 !== e.roughness && (i.roughness = e.roughness),
            void 0 !== e.metalness && (i.metalness = e.metalness),
            void 0 !== e.sheen && (i.sheen = (new ze).setHex(e.sheen)),
            void 0 !== e.emissive && i.emissive.setHex(e.emissive),
            void 0 !== e.specular && i.specular.setHex(e.specular),
            void 0 !== e.shininess && (i.shininess = e.shininess),
            void 0 !== e.clearcoat && (i.clearcoat = e.clearcoat),
            void 0 !== e.clearcoatRoughness && (i.clearcoatRoughness = e.clearcoatRoughness),
            void 0 !== e.fog && (i.fog = e.fog),
            void 0 !== e.flatShading && (i.flatShading = e.flatShading),
            void 0 !== e.blending && (i.blending = e.blending),
            void 0 !== e.combine && (i.combine = e.combine),
            void 0 !== e.side && (i.side = e.side),
            void 0 !== e.opacity && (i.opacity = e.opacity),
            void 0 !== e.transparent && (i.transparent = e.transparent),
            void 0 !== e.alphaTest && (i.alphaTest = e.alphaTest),
            void 0 !== e.depthTest && (i.depthTest = e.depthTest),
            void 0 !== e.depthWrite && (i.depthWrite = e.depthWrite),
            void 0 !== e.colorWrite && (i.colorWrite = e.colorWrite),
            void 0 !== e.stencilWrite && (i.stencilWrite = e.stencilWrite),
            void 0 !== e.stencilWriteMask && (i.stencilWriteMask = e.stencilWriteMask),
            void 0 !== e.stencilFunc && (i.stencilFunc = e.stencilFunc),
            void 0 !== e.stencilRef && (i.stencilRef = e.stencilRef),
            void 0 !== e.stencilFuncMask && (i.stencilFuncMask = e.stencilFuncMask),
            void 0 !== e.stencilFail && (i.stencilFail = e.stencilFail),
            void 0 !== e.stencilZFail && (i.stencilZFail = e.stencilZFail),
            void 0 !== e.stencilZPass && (i.stencilZPass = e.stencilZPass),
            void 0 !== e.wireframe && (i.wireframe = e.wireframe),
            void 0 !== e.wireframeLinewidth && (i.wireframeLinewidth = e.wireframeLinewidth),
            void 0 !== e.wireframeLinecap && (i.wireframeLinecap = e.wireframeLinecap),
            void 0 !== e.wireframeLinejoin && (i.wireframeLinejoin = e.wireframeLinejoin),
            void 0 !== e.rotation && (i.rotation = e.rotation),
            1 !== e.linewidth && (i.linewidth = e.linewidth),
            void 0 !== e.dashSize && (i.dashSize = e.dashSize),
            void 0 !== e.gapSize && (i.gapSize = e.gapSize),
            void 0 !== e.scale && (i.scale = e.scale),
            void 0 !== e.polygonOffset && (i.polygonOffset = e.polygonOffset),
            void 0 !== e.polygonOffsetFactor && (i.polygonOffsetFactor = e.polygonOffsetFactor),
            void 0 !== e.polygonOffsetUnits && (i.polygonOffsetUnits = e.polygonOffsetUnits),
            void 0 !== e.skinning && (i.skinning = e.skinning),
            void 0 !== e.morphTargets && (i.morphTargets = e.morphTargets),
            void 0 !== e.morphNormals && (i.morphNormals = e.morphNormals),
            void 0 !== e.dithering && (i.dithering = e.dithering),
            void 0 !== e.vertexTangents && (i.vertexTangents = e.vertexTangents),
            void 0 !== e.visible && (i.visible = e.visible),
            void 0 !== e.toneMapped && (i.toneMapped = e.toneMapped),
            void 0 !== e.userData && (i.userData = e.userData),
            void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors),
            void 0 !== e.uniforms)
                for (var r in e.uniforms) {
                    var a = e.uniforms[r];
                    switch (i.uniforms[r] = {},
                    a.type) {
                    case "t":
                        i.uniforms[r].value = n(a.value);
                        break;
                    case "c":
                        i.uniforms[r].value = (new ze).setHex(a.value);
                        break;
                    case "v2":
                        i.uniforms[r].value = (new h).fromArray(a.value);
                        break;
                    case "v3":
                        i.uniforms[r].value = (new b).fromArray(a.value);
                        break;
                    case "v4":
                        i.uniforms[r].value = (new f).fromArray(a.value);
                        break;
                    case "m3":
                        i.uniforms[r].value = (new l).fromArray(a.value);
                    case "m4":
                        i.uniforms[r].value = (new L).fromArray(a.value);
                        break;
                    default:
                        i.uniforms[r].value = a.value
                    }
                }
            if (void 0 !== e.defines && (i.defines = e.defines),
            void 0 !== e.vertexShader && (i.vertexShader = e.vertexShader),
            void 0 !== e.fragmentShader && (i.fragmentShader = e.fragmentShader),
            void 0 !== e.extensions)
                for (var o in e.extensions)
                    i.extensions[o] = e.extensions[o];
            if (void 0 !== e.shading && (i.flatShading = 1 === e.shading),
            void 0 !== e.size && (i.size = e.size),
            void 0 !== e.sizeAttenuation && (i.sizeAttenuation = e.sizeAttenuation),
            void 0 !== e.map && (i.map = n(e.map)),
            void 0 !== e.matcap && (i.matcap = n(e.matcap)),
            void 0 !== e.alphaMap && (i.alphaMap = n(e.alphaMap)),
            void 0 !== e.bumpMap && (i.bumpMap = n(e.bumpMap)),
            void 0 !== e.bumpScale && (i.bumpScale = e.bumpScale),
            void 0 !== e.normalMap && (i.normalMap = n(e.normalMap)),
            void 0 !== e.normalMapType && (i.normalMapType = e.normalMapType),
            void 0 !== e.normalScale) {
                var s = e.normalScale;
                !1 === Array.isArray(s) && (s = [s, s]),
                i.normalScale = (new h).fromArray(s)
            }
            return void 0 !== e.displacementMap && (i.displacementMap = n(e.displacementMap)),
            void 0 !== e.displacementScale && (i.displacementScale = e.displacementScale),
            void 0 !== e.displacementBias && (i.displacementBias = e.displacementBias),
            void 0 !== e.roughnessMap && (i.roughnessMap = n(e.roughnessMap)),
            void 0 !== e.metalnessMap && (i.metalnessMap = n(e.metalnessMap)),
            void 0 !== e.emissiveMap && (i.emissiveMap = n(e.emissiveMap)),
            void 0 !== e.emissiveIntensity && (i.emissiveIntensity = e.emissiveIntensity),
            void 0 !== e.specularMap && (i.specularMap = n(e.specularMap)),
            void 0 !== e.envMap && (i.envMap = n(e.envMap)),
            void 0 !== e.envMapIntensity && (i.envMapIntensity = e.envMapIntensity),
            void 0 !== e.reflectivity && (i.reflectivity = e.reflectivity),
            void 0 !== e.refractionRatio && (i.refractionRatio = e.refractionRatio),
            void 0 !== e.lightMap && (i.lightMap = n(e.lightMap)),
            void 0 !== e.lightMapIntensity && (i.lightMapIntensity = e.lightMapIntensity),
            void 0 !== e.aoMap && (i.aoMap = n(e.aoMap)),
            void 0 !== e.aoMapIntensity && (i.aoMapIntensity = e.aoMapIntensity),
            void 0 !== e.gradientMap && (i.gradientMap = n(e.gradientMap)),
            void 0 !== e.clearcoatMap && (i.clearcoatMap = n(e.clearcoatMap)),
            void 0 !== e.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
            void 0 !== e.clearcoatNormalMap && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
            void 0 !== e.clearcoatNormalScale && (i.clearcoatNormalScale = (new h).fromArray(e.clearcoatNormalScale)),
            i
        },
        setTextures: function(e) {
            return this.textures = e,
            this
        }
    });
    var Ys = function(e) {
        if ("undefined" != typeof TextDecoder)
            return (new TextDecoder).decode(e);
        for (var t = "", n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
        try {
            return decodeURIComponent(escape(t))
        } catch (e) {
            return t
        }
    }
      , Zs = function(e) {
        var t = e.lastIndexOf("/");
        return -1 === t ? "./" : e.substr(0, t + 1)
    };
    function Js() {
        ut.call(this),
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    function Ks(e, t, n, i) {
        "number" == typeof n && (i = n,
        n = !1,
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
        qe.call(this, e, t, n),
        this.meshPerAttribute = i || 1
    }
    function Qs(e) {
        ts.call(this, e)
    }
    Js.prototype = Object.assign(Object.create(ut.prototype), {
        constructor: Js,
        isInstancedBufferGeometry: !0,
        copy: function(e) {
            return ut.prototype.copy.call(this, e),
            this.instanceCount = e.instanceCount,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = ut.prototype.toJSON.call(this);
            return e.instanceCount = this.instanceCount,
            e.isInstancedBufferGeometry = !0,
            e
        }
    }),
    Ks.prototype = Object.assign(Object.create(qe.prototype), {
        constructor: Ks,
        isInstancedBufferAttribute: !0,
        copy: function(e) {
            return qe.prototype.copy.call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        },
        toJSON: function() {
            var e = qe.prototype.toJSON.call(this);
            return e.meshPerAttribute = this.meshPerAttribute,
            e.isInstancedBufferAttribute = !0,
            e
        }
    }),
    Qs.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: Qs,
        load: function(e, t, n, i) {
            var r = this
              , a = new is(r.manager);
            a.setPath(r.path),
            a.load(e, (function(n) {
                try {
                    t(r.parse(JSON.parse(n)))
                } catch (t) {
                    i ? i(t) : console.error(t),
                    r.manager.itemError(e)
                }
            }
            ), n, i)
        },
        parse: function(e) {
            var t = e.isInstancedBufferGeometry ? new Js : new ut
              , n = e.data.index;
            if (void 0 !== n) {
                var i = new $s[n.type](n.array);
                t.setIndex(new qe(i,1))
            }
            var r = e.data.attributes;
            for (var a in r) {
                var o = r[a]
                  , s = (i = new $s[o.type](o.array),
                new (o.isInstancedBufferAttribute ? Ks : qe)(i,o.itemSize,o.normalized));
                void 0 !== o.name && (s.name = o.name),
                t.setAttribute(a, s)
            }
            var c = e.data.morphAttributes;
            if (c)
                for (var a in c) {
                    for (var h = c[a], l = [], u = 0, p = h.length; u < p; u++) {
                        o = h[u],
                        s = new qe(i = new $s[o.type](o.array),o.itemSize,o.normalized);
                        void 0 !== o.name && (s.name = o.name),
                        l.push(s)
                    }
                    t.morphAttributes[a] = l
                }
            e.data.morphTargetsRelative && (t.morphTargetsRelative = !0);
            var d = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (void 0 !== d) {
                u = 0;
                for (var f = d.length; u !== f; ++u) {
                    var m = d[u];
                    t.addGroup(m.start, m.count, m.materialIndex)
                }
            }
            var v = e.data.boundingSphere;
            if (void 0 !== v) {
                var g = new b;
                void 0 !== v.center && g.fromArray(v.center),
                t.boundingSphere = new le(g,v.radius)
            }
            return e.name && (t.name = e.name),
            e.userData && (t.userData = e.userData),
            t
        }
    });
    var $s = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    function ec(e) {
        ts.call(this, e)
    }
    ec.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: ec,
        load: function(e, t, n, i) {
            var r = this
              , a = "" === this.path ? Zs(e) : this.path;
            this.resourcePath = this.resourcePath || a;
            var o = new is(r.manager);
            o.setPath(this.path),
            o.load(e, (function(n) {
                var a = null;
                try {
                    a = JSON.parse(n)
                } catch (t) {
                    return void 0 !== i && i(t),
                    void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                }
                var o = a.metadata;
                void 0 !== o && void 0 !== o.type && "geometry" !== o.type.toLowerCase() ? r.parse(a, t) : console.error("THREE.ObjectLoader: Can't load " + e)
            }
            ), n, i)
        },
        parse: function(e, t) {
            var n = this.parseShape(e.shapes)
              , i = this.parseGeometries(e.geometries, n)
              , r = this.parseImages(e.images, (function() {
                void 0 !== t && t(s)
            }
            ))
              , a = this.parseTextures(e.textures, r)
              , o = this.parseMaterials(e.materials, a)
              , s = this.parseObject(e.object, i, o);
            return e.animations && (s.animations = this.parseAnimations(e.animations)),
            void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s),
            s
        },
        parseShape: function(e) {
            var t = {};
            if (void 0 !== e)
                for (var n = 0, i = e.length; n < i; n++) {
                    var r = (new Os).fromJSON(e[n]);
                    t[r.uuid] = r
                }
            return t
        },
        parseGeometries: function(e, t) {
            var n = {};
            if (void 0 !== e)
                for (var i = new Qs, r = 0, a = e.length; r < a; r++) {
                    var o, s = e[r];
                    switch (s.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                        o = new To[s.type](s.width,s.height,s.widthSegments,s.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                        o = new To[s.type](s.width,s.height,s.depth,s.widthSegments,s.heightSegments,s.depthSegments);
                        break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                        o = new To[s.type](s.radius,s.segments,s.thetaStart,s.thetaLength);
                        break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                        o = new To[s.type](s.radiusTop,s.radiusBottom,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);
                        break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                        o = new To[s.type](s.radius,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);
                        break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                        o = new To[s.type](s.radius,s.widthSegments,s.heightSegments,s.phiStart,s.phiLength,s.thetaStart,s.thetaLength);
                        break;
                    case "DodecahedronGeometry":
                    case "DodecahedronBufferGeometry":
                    case "IcosahedronGeometry":
                    case "IcosahedronBufferGeometry":
                    case "OctahedronGeometry":
                    case "OctahedronBufferGeometry":
                    case "TetrahedronGeometry":
                    case "TetrahedronBufferGeometry":
                        o = new To[s.type](s.radius,s.detail);
                        break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                        o = new To[s.type](s.innerRadius,s.outerRadius,s.thetaSegments,s.phiSegments,s.thetaStart,s.thetaLength);
                        break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                        o = new To[s.type](s.radius,s.tube,s.radialSegments,s.tubularSegments,s.arc);
                        break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                        o = new To[s.type](s.radius,s.tube,s.tubularSegments,s.radialSegments,s.p,s.q);
                        break;
                    case "TubeGeometry":
                    case "TubeBufferGeometry":
                        o = new To[s.type]((new Rs[s.path.type]).fromJSON(s.path),s.tubularSegments,s.radius,s.radialSegments,s.closed);
                        break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                        o = new To[s.type](s.points,s.segments,s.phiStart,s.phiLength);
                        break;
                    case "PolyhedronGeometry":
                    case "PolyhedronBufferGeometry":
                        o = new To[s.type](s.vertices,s.indices,s.radius,s.details);
                        break;
                    case "ShapeGeometry":
                    case "ShapeBufferGeometry":
                        for (var c = [], h = 0, l = s.shapes.length; h < l; h++) {
                            var u = t[s.shapes[h]];
                            c.push(u)
                        }
                        o = new To[s.type](c,s.curveSegments);
                        break;
                    case "ExtrudeGeometry":
                    case "ExtrudeBufferGeometry":
                        for (c = [],
                        h = 0,
                        l = s.shapes.length; h < l; h++) {
                            u = t[s.shapes[h]];
                            c.push(u)
                        }
                        var p = s.options.extrudePath;
                        void 0 !== p && (s.options.extrudePath = (new Rs[p.type]).fromJSON(p)),
                        o = new To[s.type](c,s.options);
                        break;
                    case "BufferGeometry":
                    case "InstancedBufferGeometry":
                        o = i.parse(s);
                        break;
                    case "Geometry":
                        console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                        continue
                    }
                    o.uuid = s.uuid,
                    void 0 !== s.name && (o.name = s.name),
                    !0 === o.isBufferGeometry && void 0 !== s.userData && (o.userData = s.userData),
                    n[s.uuid] = o
                }
            return n
        },
        parseMaterials: function(e, t) {
            var n = {}
              , i = {};
            if (void 0 !== e) {
                var r = new Xs;
                r.setTextures(t);
                for (var a = 0, o = e.length; a < o; a++) {
                    var s = e[a];
                    if ("MultiMaterial" === s.type) {
                        for (var c = [], h = 0; h < s.materials.length; h++) {
                            var l = s.materials[h];
                            void 0 === n[l.uuid] && (n[l.uuid] = r.parse(l)),
                            c.push(n[l.uuid])
                        }
                        i[s.uuid] = c
                    } else
                        void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)),
                        i[s.uuid] = n[s.uuid]
                }
            }
            return i
        },
        parseAnimations: function(e) {
            for (var t = [], n = 0; n < e.length; n++) {
                var i = e[n]
                  , r = Jo.parse(i);
                void 0 !== i.uuid && (r.uuid = i.uuid),
                t.push(r)
            }
            return t
        },
        parseImages: function(e, t) {
            var n = this
              , i = {};
            function r(e) {
                return n.manager.itemStart(e),
                a.load(e, (function() {
                    n.manager.itemEnd(e)
                }
                ), void 0, (function() {
                    n.manager.itemError(e),
                    n.manager.itemEnd(e)
                }
                ))
            }
            if (void 0 !== e && e.length > 0) {
                var a = new ss(new $o(t));
                a.setCrossOrigin(this.crossOrigin);
                for (var o = 0, s = e.length; o < s; o++) {
                    var c = e[o]
                      , h = c.url;
                    if (Array.isArray(h)) {
                        i[c.uuid] = [];
                        for (var l = 0, u = h.length; l < u; l++) {
                            var p = h[l]
                              , d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : n.resourcePath + p;
                            i[c.uuid].push(r(d))
                        }
                    } else {
                        d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.resourcePath + c.url;
                        i[c.uuid] = r(d)
                    }
                }
            }
            return i
        },
        parseTextures: function(e, t) {
            function n(e, t) {
                return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e),
                t[e])
            }
            var i = {};
            if (void 0 !== e)
                for (var r = 0, a = e.length; r < a; r++) {
                    var o, s = e[r];
                    void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid),
                    void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image),
                    (o = Array.isArray(t[s.image]) ? new mn(t[s.image]) : new d(t[s.image])).needsUpdate = !0,
                    o.uuid = s.uuid,
                    void 0 !== s.name && (o.name = s.name),
                    void 0 !== s.mapping && (o.mapping = n(s.mapping, nc)),
                    void 0 !== s.offset && o.offset.fromArray(s.offset),
                    void 0 !== s.repeat && o.repeat.fromArray(s.repeat),
                    void 0 !== s.center && o.center.fromArray(s.center),
                    void 0 !== s.rotation && (o.rotation = s.rotation),
                    void 0 !== s.wrap && (o.wrapS = n(s.wrap[0], ic),
                    o.wrapT = n(s.wrap[1], ic)),
                    void 0 !== s.format && (o.format = s.format),
                    void 0 !== s.type && (o.type = s.type),
                    void 0 !== s.encoding && (o.encoding = s.encoding),
                    void 0 !== s.minFilter && (o.minFilter = n(s.minFilter, rc)),
                    void 0 !== s.magFilter && (o.magFilter = n(s.magFilter, rc)),
                    void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy),
                    void 0 !== s.flipY && (o.flipY = s.flipY),
                    void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha),
                    void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment),
                    i[s.uuid] = o
                }
            return i
        },
        parseObject: function(e, t, n) {
            var i;
            function r(e) {
                return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e),
                t[e]
            }
            function a(e) {
                if (void 0 !== e) {
                    if (Array.isArray(e)) {
                        for (var t = [], i = 0, r = e.length; i < r; i++) {
                            var a = e[i];
                            void 0 === n[a] && console.warn("THREE.ObjectLoader: Undefined material", a),
                            t.push(n[a])
                        }
                        return t
                    }
                    return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e),
                    n[e]
                }
            }
            switch (e.type) {
            case "Scene":
                i = new X,
                void 0 !== e.background && Number.isInteger(e.background) && (i.background = new ze(e.background)),
                void 0 !== e.fog && ("Fog" === e.fog.type ? i.fog = new ir(e.fog.color,e.fog.near,e.fog.far) : "FogExp2" === e.fog.type && (i.fog = new nr(e.fog.color,e.fog.density)));
                break;
            case "PerspectiveCamera":
                i = new Vt(e.fov,e.aspect,e.near,e.far),
                void 0 !== e.focus && (i.focus = e.focus),
                void 0 !== e.zoom && (i.zoom = e.zoom),
                void 0 !== e.filmGauge && (i.filmGauge = e.filmGauge),
                void 0 !== e.filmOffset && (i.filmOffset = e.filmOffset),
                void 0 !== e.view && (i.view = Object.assign({}, e.view));
                break;
            case "OrthographicCamera":
                i = new Hs(e.left,e.right,e.top,e.bottom,e.near,e.far),
                void 0 !== e.zoom && (i.zoom = e.zoom),
                void 0 !== e.view && (i.view = Object.assign({}, e.view));
                break;
            case "AmbientLight":
                i = new Vs(e.color,e.intensity);
                break;
            case "DirectionalLight":
                i = new Gs(e.color,e.intensity);
                break;
            case "PointLight":
                i = new Fs(e.color,e.intensity,e.distance,e.decay);
                break;
            case "RectAreaLight":
                i = new js(e.color,e.intensity,e.width,e.height);
                break;
            case "SpotLight":
                i = new zs(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
                break;
            case "HemisphereLight":
                i = new Ds(e.color,e.groundColor,e.intensity);
                break;
            case "LightProbe":
                i = (new qs).fromJSON(e);
                break;
            case "SkinnedMesh":
                console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
            case "Mesh":
                i = new Rt(o = r(e.geometry),s = a(e.material));
                break;
            case "InstancedMesh":
                var o = r(e.geometry)
                  , s = a(e.material)
                  , c = e.count
                  , h = e.instanceMatrix;
                (i = new Hr(o,s,c)).instanceMatrix = new qe(new Float32Array(h.array),16);
                break;
            case "LOD":
                i = new Pr;
                break;
            case "Line":
                i = new Xr(r(e.geometry),a(e.material),e.mode);
                break;
            case "LineLoop":
                i = new Kr(r(e.geometry),a(e.material));
                break;
            case "LineSegments":
                i = new Jr(r(e.geometry),a(e.material));
                break;
            case "PointCloud":
            case "Points":
                i = new ia(r(e.geometry),a(e.material));
                break;
            case "Sprite":
                i = new _r(a(e.material));
                break;
            case "Group":
                i = new Ki;
                break;
            default:
                i = new q
            }
            if (i.uuid = e.uuid,
            void 0 !== e.name && (i.name = e.name),
            void 0 !== e.matrix ? (i.matrix.fromArray(e.matrix),
            void 0 !== e.matrixAutoUpdate && (i.matrixAutoUpdate = e.matrixAutoUpdate),
            i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== e.position && i.position.fromArray(e.position),
            void 0 !== e.rotation && i.rotation.fromArray(e.rotation),
            void 0 !== e.quaternion && i.quaternion.fromArray(e.quaternion),
            void 0 !== e.scale && i.scale.fromArray(e.scale)),
            void 0 !== e.castShadow && (i.castShadow = e.castShadow),
            void 0 !== e.receiveShadow && (i.receiveShadow = e.receiveShadow),
            e.shadow && (void 0 !== e.shadow.bias && (i.shadow.bias = e.shadow.bias),
            void 0 !== e.shadow.radius && (i.shadow.radius = e.shadow.radius),
            void 0 !== e.shadow.mapSize && i.shadow.mapSize.fromArray(e.shadow.mapSize),
            void 0 !== e.shadow.camera && (i.shadow.camera = this.parseObject(e.shadow.camera))),
            void 0 !== e.visible && (i.visible = e.visible),
            void 0 !== e.frustumCulled && (i.frustumCulled = e.frustumCulled),
            void 0 !== e.renderOrder && (i.renderOrder = e.renderOrder),
            void 0 !== e.userData && (i.userData = e.userData),
            void 0 !== e.layers && (i.layers.mask = e.layers),
            void 0 !== e.children)
                for (var l = e.children, u = 0; u < l.length; u++)
                    i.add(this.parseObject(l[u], t, n));
            if ("LOD" === e.type) {
                void 0 !== e.autoUpdate && (i.autoUpdate = e.autoUpdate);
                for (var p = e.levels, d = 0; d < p.length; d++) {
                    var f = p[d]
                      , m = i.getObjectByProperty("uuid", f.object);
                    void 0 !== m && i.addLevel(m, f.distance)
                }
            }
            return i
        }
    });
    var tc, nc = {
        UVMapping: 300,
        CubeReflectionMapping: 301,
        CubeRefractionMapping: 302,
        EquirectangularReflectionMapping: 303,
        EquirectangularRefractionMapping: 304,
        SphericalReflectionMapping: 305,
        CubeUVReflectionMapping: 306,
        CubeUVRefractionMapping: 307
    }, ic = {
        RepeatWrapping: 1e3,
        ClampToEdgeWrapping: 1001,
        MirroredRepeatWrapping: 1002
    }, rc = {
        NearestFilter: 1003,
        NearestMipmapNearestFilter: 1004,
        NearestMipmapLinearFilter: 1005,
        LinearFilter: 1006,
        LinearMipmapNearestFilter: 1007,
        LinearMipmapLinearFilter: 1008
    };
    function ac(e) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        ts.call(this, e),
        this.options = void 0
    }
    function oc() {
        this.type = "ShapePath",
        this.color = new ze,
        this.subPaths = [],
        this.currentPath = null
    }
    function sc(e) {
        this.type = "Font",
        this.data = e
    }
    function cc(e, t, n, i, r) {
        var a = r.glyphs[e] || r.glyphs["?"];
        if (a) {
            var o, s, c, h, l, u, p, d, f = new oc;
            if (a.o)
                for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), v = 0, g = m.length; v < g; ) {
                    switch (m[v++]) {
                    case "m":
                        o = m[v++] * t + n,
                        s = m[v++] * t + i,
                        f.moveTo(o, s);
                        break;
                    case "l":
                        o = m[v++] * t + n,
                        s = m[v++] * t + i,
                        f.lineTo(o, s);
                        break;
                    case "q":
                        c = m[v++] * t + n,
                        h = m[v++] * t + i,
                        l = m[v++] * t + n,
                        u = m[v++] * t + i,
                        f.quadraticCurveTo(l, u, c, h);
                        break;
                    case "b":
                        c = m[v++] * t + n,
                        h = m[v++] * t + i,
                        l = m[v++] * t + n,
                        u = m[v++] * t + i,
                        p = m[v++] * t + n,
                        d = m[v++] * t + i,
                        f.bezierCurveTo(l, u, p, d, c, h)
                    }
                }
            return {
                offsetX: a.ha * t,
                path: f
            }
        }
        console.error('THREE.Font: character "' + e + '" does not exists in font family ' + r.familyName + ".")
    }
    function hc(e) {
        ts.call(this, e)
    }
    ac.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: ac,
        setOptions: function(e) {
            return this.options = e,
            this
        },
        load: function(e, t, n, i) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var r = this
              , a = Qo.get(e);
            if (void 0 !== a)
                return r.manager.itemStart(e),
                setTimeout((function() {
                    t && t(a),
                    r.manager.itemEnd(e)
                }
                ), 0),
                a;
            fetch(e).then((function(e) {
                return e.blob()
            }
            )).then((function(e) {
                return void 0 === r.options ? createImageBitmap(e) : createImageBitmap(e, r.options)
            }
            )).then((function(n) {
                Qo.add(e, n),
                t && t(n),
                r.manager.itemEnd(e)
            }
            )).catch((function(t) {
                i && i(t),
                r.manager.itemError(e),
                r.manager.itemEnd(e)
            }
            )),
            r.manager.itemStart(e)
        }
    }),
    Object.assign(oc.prototype, {
        moveTo: function(e, t) {
            return this.currentPath = new Cs,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(e, t),
            this
        },
        lineTo: function(e, t) {
            return this.currentPath.lineTo(e, t),
            this
        },
        quadraticCurveTo: function(e, t, n, i) {
            return this.currentPath.quadraticCurveTo(e, t, n, i),
            this
        },
        bezierCurveTo: function(e, t, n, i, r, a) {
            return this.currentPath.bezierCurveTo(e, t, n, i, r, a),
            this
        },
        splineThru: function(e) {
            return this.currentPath.splineThru(e),
            this
        },
        toShapes: function(e, t) {
            function n(e) {
                for (var t = [], n = 0, i = e.length; n < i; n++) {
                    var r = e[n]
                      , a = new Os;
                    a.curves = r.curves,
                    t.push(a)
                }
                return t
            }
            function i(e, t) {
                for (var n = t.length, i = !1, r = n - 1, a = 0; a < n; r = a++) {
                    var o = t[r]
                      , s = t[a]
                      , c = s.x - o.x
                      , h = s.y - o.y;
                    if (Math.abs(h) > Number.EPSILON) {
                        if (h < 0 && (o = t[a],
                        c = -c,
                        s = t[r],
                        h = -h),
                        e.y < o.y || e.y > s.y)
                            continue;
                        if (e.y === o.y) {
                            if (e.x === o.x)
                                return !0
                        } else {
                            var l = h * (e.x - o.x) - c * (e.y - o.y);
                            if (0 === l)
                                return !0;
                            if (l < 0)
                                continue;
                            i = !i
                        }
                    } else {
                        if (e.y !== o.y)
                            continue;
                        if (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x)
                            return !0
                    }
                }
                return i
            }
            var r = $a.isClockWise
              , a = this.subPaths;
            if (0 === a.length)
                return [];
            if (!0 === t)
                return n(a);
            var o, s, c, h = [];
            if (1 === a.length)
                return s = a[0],
                (c = new Os).curves = s.curves,
                h.push(c),
                h;
            var l = !r(a[0].getPoints());
            l = e ? !l : l;
            var u, p, d = [], f = [], m = [], v = 0;
            f[v] = void 0,
            m[v] = [];
            for (var g = 0, y = a.length; g < y; g++)
                o = r(u = (s = a[g]).getPoints()),
                (o = e ? !o : o) ? (!l && f[v] && v++,
                f[v] = {
                    s: new Os,
                    p: u
                },
                f[v].s.curves = s.curves,
                l && v++,
                m[v] = []) : m[v].push({
                    h: s,
                    p: u[0]
                });
            if (!f[0])
                return n(a);
            if (f.length > 1) {
                for (var x = !1, b = [], _ = 0, w = f.length; _ < w; _++)
                    d[_] = [];
                for (_ = 0,
                w = f.length; _ < w; _++)
                    for (var M = m[_], S = 0; S < M.length; S++) {
                        for (var T = M[S], E = !0, A = 0; A < f.length; A++)
                            i(T.p, f[A].p) && (_ !== A && b.push({
                                froms: _,
                                tos: A,
                                hole: S
                            }),
                            E ? (E = !1,
                            d[A].push(T)) : x = !0);
                        E && d[_].push(T)
                    }
                b.length > 0 && (x || (m = d))
            }
            g = 0;
            for (var L = f.length; g < L; g++) {
                c = f[g].s,
                h.push(c);
                for (var R = 0, P = (p = m[g]).length; R < P; R++)
                    c.holes.push(p[R].h)
            }
            return h
        }
    }),
    Object.assign(sc.prototype, {
        isFont: !0,
        generateShapes: function(e, t) {
            void 0 === t && (t = 100);
            for (var n = [], i = function(e, t, n) {
                for (var i = Array.from ? Array.from(e) : String(e).split(""), r = t / n.resolution, a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, o = [], s = 0, c = 0, h = 0; h < i.length; h++) {
                    var l = i[h];
                    if ("\n" === l)
                        s = 0,
                        c -= a;
                    else {
                        var u = cc(l, r, s, c, n);
                        s += u.offsetX,
                        o.push(u.path)
                    }
                }
                return o
            }(e, t, this.data), r = 0, a = i.length; r < a; r++)
                Array.prototype.push.apply(n, i[r].toShapes());
            return n
        }
    }),
    hc.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: hc,
        load: function(e, t, n, i) {
            var r = this
              , a = new is(this.manager);
            a.setPath(this.path),
            a.load(e, (function(e) {
                var n;
                try {
                    n = JSON.parse(e)
                } catch (t) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                    n = JSON.parse(e.substring(65, e.length - 2))
                }
                var i = r.parse(n);
                t && t(i)
            }
            ), n, i)
        },
        parse: function(e) {
            return new sc(e)
        }
    });
    var lc = function() {
        return void 0 === tc && (tc = new (window.AudioContext || window.webkitAudioContext)),
        tc
    };
    function uc(e) {
        ts.call(this, e)
    }
    function pc(e, t, n) {
        qs.call(this, void 0, n);
        var i = (new ze).set(e)
          , r = (new ze).set(t)
          , a = new b(i.r,i.g,i.b)
          , o = new b(r.r,r.g,r.b)
          , s = Math.sqrt(Math.PI)
          , c = s * Math.sqrt(.75);
        this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s),
        this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c)
    }
    function dc(e, t) {
        qs.call(this, void 0, t);
        var n = (new ze).set(e);
        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
    uc.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: uc,
        load: function(e, t, n, i) {
            var r = this
              , a = new is(r.manager);
            a.setResponseType("arraybuffer"),
            a.setPath(r.path),
            a.load(e, (function(n) {
                try {
                    var a = n.slice(0);
                    lc().decodeAudioData(a, (function(e) {
                        t(e)
                    }
                    ))
                } catch (t) {
                    i ? i(t) : console.error(t),
                    r.manager.itemError(e)
                }
            }
            ), n, i)
        }
    }),
    pc.prototype = Object.assign(Object.create(qs.prototype), {
        constructor: pc,
        isHemisphereLightProbe: !0,
        copy: function(e) {
            return qs.prototype.copy.call(this, e),
            this
        },
        toJSON: function(e) {
            return qs.prototype.toJSON.call(this, e)
        }
    }),
    dc.prototype = Object.assign(Object.create(qs.prototype), {
        constructor: dc,
        isAmbientLightProbe: !0,
        copy: function(e) {
            return qs.prototype.copy.call(this, e),
            this
        },
        toJSON: function(e) {
            return qs.prototype.toJSON.call(this, e)
        }
    });
    var fc = new L
      , mc = new L;
    function vc(e) {
        this.autoStart = void 0 === e || e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    Object.assign(function() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new Vt,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new Vt,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    .prototype, {
        update: function(e) {
            var t = this._cache;
            if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                t.focus = e.focus,
                t.fov = e.fov,
                t.aspect = e.aspect * this.aspect,
                t.near = e.near,
                t.far = e.far,
                t.zoom = e.zoom,
                t.eyeSep = this.eyeSep;
                var n, i, r = e.projectionMatrix.clone(), a = t.eyeSep / 2, o = a * t.near / t.focus, s = t.near * Math.tan(c.DEG2RAD * t.fov * .5) / t.zoom;
                mc.elements[12] = -a,
                fc.elements[12] = a,
                n = -s * t.aspect + o,
                i = s * t.aspect + o,
                r.elements[0] = 2 * t.near / (i - n),
                r.elements[8] = (i + n) / (i - n),
                this.cameraL.projectionMatrix.copy(r),
                n = -s * t.aspect - o,
                i = s * t.aspect - o,
                r.elements[0] = 2 * t.near / (i - n),
                r.elements[8] = (i + n) / (i - n),
                this.cameraR.projectionMatrix.copy(r)
            }
            this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(mc),
            this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(fc)
        }
    }),
    Object.assign(vc.prototype, {
        start: function() {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(),
            this.oldTime = this.startTime,
            this.elapsedTime = 0,
            this.running = !0
        },
        stop: function() {
            this.getElapsedTime(),
            this.running = !1,
            this.autoStart = !1
        },
        getElapsedTime: function() {
            return this.getDelta(),
            this.elapsedTime
        },
        getDelta: function() {
            var e = 0;
            if (this.autoStart && !this.running)
                return this.start(),
                0;
            if (this.running) {
                var t = ("undefined" == typeof performance ? Date : performance).now();
                e = (t - this.oldTime) / 1e3,
                this.oldTime = t,
                this.elapsedTime += e
            }
            return e
        }
    });
    var gc = new b
      , yc = new g
      , xc = new b
      , bc = new b;
    function _c() {
        q.call(this),
        this.type = "AudioListener",
        this.context = lc(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new vc
    }
    function wc(e) {
        q.call(this),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this.filters = []
    }
    _c.prototype = Object.assign(Object.create(q.prototype), {
        constructor: _c,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null),
            this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(e) {
            return null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = e,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
            this
        },
        updateMatrixWorld: function(e) {
            q.prototype.updateMatrixWorld.call(this, e);
            var t = this.context.listener
              , n = this.up;
            if (this.timeDelta = this._clock.getDelta(),
            this.matrixWorld.decompose(gc, yc, xc),
            bc.set(0, 0, -1).applyQuaternion(yc),
            t.positionX) {
                var i = this.context.currentTime + this.timeDelta;
                t.positionX.linearRampToValueAtTime(gc.x, i),
                t.positionY.linearRampToValueAtTime(gc.y, i),
                t.positionZ.linearRampToValueAtTime(gc.z, i),
                t.forwardX.linearRampToValueAtTime(bc.x, i),
                t.forwardY.linearRampToValueAtTime(bc.y, i),
                t.forwardZ.linearRampToValueAtTime(bc.z, i),
                t.upX.linearRampToValueAtTime(n.x, i),
                t.upY.linearRampToValueAtTime(n.y, i),
                t.upZ.linearRampToValueAtTime(n.z, i)
            } else
                t.setPosition(gc.x, gc.y, gc.z),
                t.setOrientation(bc.x, bc.y, bc.z, n.x, n.y, n.z)
        }
    }),
    wc.prototype = Object.assign(Object.create(q.prototype), {
        constructor: wc,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = e,
            this.connect(),
            this
        },
        setMediaElementSource: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaNode",
            this.source = this.context.createMediaElementSource(e),
            this.connect(),
            this
        },
        setMediaStreamSource: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaStreamNode",
            this.source = this.context.createMediaStreamSource(e),
            this.connect(),
            this
        },
        setBuffer: function(e) {
            return this.buffer = e,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        },
        play: function(e) {
            if (void 0 === e && (e = 0),
            !0 !== this.isPlaying) {
                if (!1 !== this.hasPlaybackControl) {
                    this._startedAt = this.context.currentTime + e;
                    var t = this.context.createBufferSource();
                    return t.buffer = this.buffer,
                    t.loop = this.loop,
                    t.loopStart = this.loopStart,
                    t.loopEnd = this.loopEnd,
                    t.onended = this.onEnded.bind(this),
                    t.start(this._startedAt, this._progress + this.offset, this.duration),
                    this.isPlaying = !0,
                    this.source = t,
                    this.setDetune(this.detune),
                    this.setPlaybackRate(this.playbackRate),
                    this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            } else
                console.warn("THREE.Audio: Audio is already playing.")
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl)
                return this._progress = 0,
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1,
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(e) {
            return e || (e = []),
            !0 === this.isPlaying ? (this.disconnect(),
            this.filters = e,
            this.connect()) : this.filters = e,
            this
        },
        setDetune: function(e) {
            if (this.detune = e,
            void 0 !== this.source.detune)
                return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                this
        },
        getDetune: function() {
            return this.detune
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(e) {
            return this.setFilters(e ? [e] : [])
        },
        setPlaybackRate: function(e) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = e,
                !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.loop
        },
        setLoop: function(e) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = e,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        setLoopStart: function(e) {
            return this.loopStart = e,
            this
        },
        setLoopEnd: function(e) {
            return this.loopEnd = e,
            this
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
            this
        }
    });
    var Mc = new b
      , Sc = new g
      , Tc = new b
      , Ec = new b;
    function Ac(e) {
        wc.call(this, e),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    function Lc(e, t) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = void 0 !== t ? t : 2048,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    function Rc(e, t, n) {
        var i, r, a;
        switch (this.binding = e,
        this.valueSize = n,
        t) {
        case "quaternion":
            i = this._slerp,
            r = this._slerpAdditive,
            a = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(6 * n),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            i = this._select,
            r = this._select,
            a = this._setAdditiveIdentityOther,
            this.buffer = new Array(5 * n);
            break;
        default:
            i = this._lerp,
            r = this._lerpAdditive,
            a = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(5 * n)
        }
        this._mixBufferRegion = i,
        this._mixBufferRegionAdditive = r,
        this._setIdentity = a,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    Ac.prototype = Object.assign(Object.create(wc.prototype), {
        constructor: Ac,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(e) {
            return this.panner.refDistance = e,
            this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(e) {
            return this.panner.rolloffFactor = e,
            this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(e) {
            return this.panner.distanceModel = e,
            this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(e) {
            return this.panner.maxDistance = e,
            this
        },
        setDirectionalCone: function(e, t, n) {
            return this.panner.coneInnerAngle = e,
            this.panner.coneOuterAngle = t,
            this.panner.coneOuterGain = n,
            this
        },
        updateMatrixWorld: function(e) {
            if (q.prototype.updateMatrixWorld.call(this, e),
            !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                this.matrixWorld.decompose(Mc, Sc, Tc),
                Ec.set(0, 0, 1).applyQuaternion(Sc);
                var t = this.panner;
                if (t.positionX) {
                    var n = this.context.currentTime + this.listener.timeDelta;
                    t.positionX.linearRampToValueAtTime(Mc.x, n),
                    t.positionY.linearRampToValueAtTime(Mc.y, n),
                    t.positionZ.linearRampToValueAtTime(Mc.z, n),
                    t.orientationX.linearRampToValueAtTime(Ec.x, n),
                    t.orientationY.linearRampToValueAtTime(Ec.y, n),
                    t.orientationZ.linearRampToValueAtTime(Ec.z, n)
                } else
                    t.setPosition(Mc.x, Mc.y, Mc.z),
                    t.setOrientation(Ec.x, Ec.y, Ec.z)
            }
        }
    }),
    Object.assign(Lc.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data),
            this.data
        },
        getAverageFrequency: function() {
            for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++)
                e += t[n];
            return e / t.length
        }
    }),
    Object.assign(Rc.prototype, {
        accumulate: function(e, t) {
            var n = this.buffer
              , i = this.valueSize
              , r = e * i + i
              , a = this.cumulativeWeight;
            if (0 === a) {
                for (var o = 0; o !== i; ++o)
                    n[r + o] = n[o];
                a = t
            } else {
                var s = t / (a += t);
                this._mixBufferRegion(n, r, 0, s, i)
            }
            this.cumulativeWeight = a
        },
        accumulateAdditive: function(e) {
            var t = this.buffer
              , n = this.valueSize
              , i = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(t, i, 0, e, n),
            this.cumulativeWeightAdditive += e
        },
        apply: function(e) {
            var t = this.valueSize
              , n = this.buffer
              , i = e * t + t
              , r = this.cumulativeWeight
              , a = this.cumulativeWeightAdditive
              , o = this.binding;
            if (this.cumulativeWeight = 0,
            this.cumulativeWeightAdditive = 0,
            r < 1) {
                var s = t * this._origIndex;
                this._mixBufferRegion(n, i, s, 1 - r, t)
            }
            a > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
            for (var c = t, h = t + t; c !== h; ++c)
                if (n[c] !== n[c + t]) {
                    o.setValue(n, i);
                    break
                }
        },
        saveOriginalState: function() {
            var e = this.binding
              , t = this.buffer
              , n = this.valueSize
              , i = n * this._origIndex;
            e.getValue(t, i);
            for (var r = n, a = i; r !== a; ++r)
                t[r] = t[i + r % n];
            this._setIdentity(),
            this.cumulativeWeight = 0,
            this.cumulativeWeightAdditive = 0
        },
        restoreOriginalState: function() {
            var e = 3 * this.valueSize;
            this.binding.setValue(this.buffer, e)
        },
        _setAdditiveIdentityNumeric: function() {
            for (var e = this._addIndex * this.valueSize, t = e + this.valueSize, n = e; n < t; n++)
                this.buffer[n] = 0
        },
        _setAdditiveIdentityQuaternion: function() {
            this._setAdditiveIdentityNumeric(),
            this.buffer[4 * this._addIndex + 3] = 1
        },
        _setAdditiveIdentityOther: function() {
            for (var e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize, n = 0; n < this.valueSize; n++)
                this.buffer[t + n] = this.buffer[e + n]
        },
        _select: function(e, t, n, i, r) {
            if (i >= .5)
                for (var a = 0; a !== r; ++a)
                    e[t + a] = e[n + a]
        },
        _slerp: function(e, t, n, i) {
            g.slerpFlat(e, t, e, t, e, n, i)
        },
        _slerpAdditive: function(e, t, n, i, r) {
            var a = this._workIndex * r;
            g.multiplyQuaternionsFlat(e, a, e, t, e, n),
            g.slerpFlat(e, t, e, t, e, a, i)
        },
        _lerp: function(e, t, n, i, r) {
            for (var a = 1 - i, o = 0; o !== r; ++o) {
                var s = t + o;
                e[s] = e[s] * a + e[n + o] * i
            }
        },
        _lerpAdditive: function(e, t, n, i, r) {
            for (var a = 0; a !== r; ++a) {
                var o = t + a;
                e[o] = e[o] + e[n + a] * i
            }
        }
    });
    var Pc = new RegExp("[\\[\\]\\.:\\/]","g")
      , Cc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]"
      , Oc = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]")
      , Ic = /(WCOD+)?/.source.replace("WCOD", Cc)
      , Dc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]")
      , Nc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]")
      , Uc = new RegExp("^" + Oc + Ic + Dc + Nc + "$")
      , zc = ["material", "materials", "bones"];
    function Bc(e, t, n) {
        var i = n || Fc.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, i)
    }
    function Fc(e, t, n) {
        this.path = t,
        this.parsedPath = n || Fc.parseTrackName(t),
        this.node = Fc.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e
    }
    function Hc(e, t, n, i) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = n || null,
        this.blendMode = i || t.blendMode;
        for (var r = t.tracks, a = r.length, o = new Array(a), s = {
            endingStart: 2400,
            endingEnd: 2400
        }, c = 0; c !== a; ++c) {
            var h = r[c].createInterpolant(null);
            o[c] = h,
            h.settings = s
        }
        this._interpolantSettings = s,
        this._interpolants = o,
        this._propertyBindings = new Array(a),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = 2201,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    function kc(e) {
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    function Gc(e) {
        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        e = arguments[1]),
        this.value = e
    }
    function Vc(e, t, n) {
        rr.call(this, e, t),
        this.meshPerAttribute = n || 1
    }
    function jc(e, t, n, i) {
        this.ray = new ye(e,t),
        this.near = n || 0,
        this.far = i || 1 / 0,
        this.camera = null,
        this.layers = new O,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points
                }
            }
        })
    }
    function Wc(e, t) {
        return e.distance - t.distance
    }
    function qc(e, t, n, i) {
        if (e.layers.test(t.layers) && e.raycast(t, n),
        !0 === i)
            for (var r = e.children, a = 0, o = r.length; a < o; a++)
                qc(r[a], t, n, !0)
    }
    Object.assign(Bc.prototype, {
        getValue: function(e, t) {
            this.bind();
            var n = this._targetGroup.nCachedObjects_
              , i = this._bindings[n];
            void 0 !== i && i.getValue(e, t)
        },
        setValue: function(e, t) {
            for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                n[i].setValue(e, t)
        },
        bind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                e[t].bind()
        },
        unbind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                e[t].unbind()
        }
    }),
    Object.assign(Fc, {
        Composite: Bc,
        create: function(e, t, n) {
            return e && e.isAnimationObjectGroup ? new Fc.Composite(e,t,n) : new Fc(e,t,n)
        },
        sanitizeNodeName: function(e) {
            return e.replace(/\s/g, "_").replace(Pc, "")
        },
        parseTrackName: function(e) {
            var t = Uc.exec(e);
            if (!t)
                throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            var n = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            }
              , i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
                var r = n.nodeName.substring(i + 1);
                -1 !== zc.indexOf(r) && (n.nodeName = n.nodeName.substring(0, i),
                n.objectName = r)
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
                throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n
        },
        findNode: function(e, t) {
            if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                return e;
            if (e.skeleton) {
                var n = e.skeleton.getBoneByName(t);
                if (void 0 !== n)
                    return n
            }
            if (e.children) {
                var i = function(e) {
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n];
                        if (r.name === t || r.uuid === t)
                            return r;
                        var a = i(r.children);
                        if (a)
                            return a
                    }
                    return null
                }
                  , r = i(e.children);
                if (r)
                    return r
            }
            return null
        }
    }),
    Object.assign(Fc.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(e, t) {
            e[t] = this.node[this.propertyName]
        }
        , function(e, t) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
                e[t++] = n[i]
        }
        , function(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }
        , function(e, t) {
            this.resolvedProperty.toArray(e, t)
        }
        ],
        SetterByBindingTypeAndVersioning: [[function(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }
        , function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
                n[i] = e[t++]
        }
        , function(e, t) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
                n[i] = e[t++];
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
                n[i] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }
        , function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }
        , function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ]],
        getValue: function(e, t) {
            this.bind(),
            this.getValue(e, t)
        },
        setValue: function(e, t) {
            this.bind(),
            this.setValue(e, t)
        },
        bind: function() {
            var e = this.node
              , t = this.parsedPath
              , n = t.objectName
              , i = t.propertyName
              , r = t.propertyIndex;
            if (e || (e = Fc.findNode(this.rootNode, t.nodeName) || this.rootNode,
            this.node = e),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            e) {
                if (n) {
                    var a = t.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!e.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        e = e.skeleton.bones;
                        for (var o = 0; o < e.length; o++)
                            if (e[o].name === a) {
                                a = o;
                                break
                            }
                        break;
                    default:
                        if (void 0 === e[n])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        e = e[n]
                    }
                    if (void 0 !== a) {
                        if (void 0 === e[a])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[a]
                    }
                }
                var s = e[i];
                if (void 0 !== s) {
                    var c = this.Versioning.None;
                    this.targetObject = e,
                    void 0 !== e.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                    var h = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === i) {
                            if (!e.geometry)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!e.geometry.isBufferGeometry)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                            if (!e.geometry.morphAttributes)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                        }
                        h = this.BindingType.ArrayElement,
                        this.resolvedProperty = s,
                        this.propertyIndex = r
                    } else
                        void 0 !== s.fromArray && void 0 !== s.toArray ? (h = this.BindingType.HasFromToArray,
                        this.resolvedProperty = s) : Array.isArray(s) ? (h = this.BindingType.EntireArray,
                        this.resolvedProperty = s) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[h],
                    this.setValue = this.SetterByBindingTypeAndVersioning[h][c]
                } else {
                    var l = t.nodeName;
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + i + " but it wasn't found.", e)
                }
            } else
                console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }),
    Object.assign(Fc.prototype, {
        _getValue_unbound: Fc.prototype.getValue,
        _setValue_unbound: Fc.prototype.setValue
    }),
    Object.assign(function() {
        this.uuid = c.generateUUID(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, n = arguments.length; t !== n; ++t)
            e[arguments[t].uuid] = t;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        var i = this;
        this.stats = {
            objects: {
                get total() {
                    return i._objects.length
                },
                get inUse() {
                    return this.total - i.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return i._bindings.length
            }
        }
    }
    .prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, c = void 0, h = 0, l = arguments.length; h !== l; ++h) {
                var u = arguments[h]
                  , p = u.uuid
                  , d = i[p];
                if (void 0 === d) {
                    d = t++,
                    i[p] = d,
                    e.push(u);
                    for (var f = 0, m = s; f !== m; ++f)
                        o[f].push(new Fc(u,r[f],a[f]))
                } else if (d < n) {
                    c = e[d];
                    var v = --n
                      , g = e[v];
                    i[g.uuid] = d,
                    e[d] = g,
                    i[p] = v,
                    e[v] = u;
                    for (f = 0,
                    m = s; f !== m; ++f) {
                        var y = o[f]
                          , x = y[v]
                          , b = y[d];
                        y[d] = x,
                        void 0 === b && (b = new Fc(u,r[f],a[f])),
                        y[v] = b
                    }
                } else
                    e[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = n
        },
        remove: function() {
            for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, a = 0, o = arguments.length; a !== o; ++a) {
                var s = arguments[a]
                  , c = s.uuid
                  , h = n[c];
                if (void 0 !== h && h >= t) {
                    var l = t++
                      , u = e[l];
                    n[u.uuid] = h,
                    e[h] = u,
                    n[c] = l,
                    e[l] = s;
                    for (var p = 0, d = r; p !== d; ++p) {
                        var f = i[p]
                          , m = f[l]
                          , v = f[h];
                        f[h] = m,
                        f[l] = v
                    }
                }
            }
            this.nCachedObjects_ = t
        },
        uncache: function() {
            for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) {
                var c = arguments[o]
                  , h = c.uuid
                  , l = i[h];
                if (void 0 !== l)
                    if (delete i[h],
                    l < n) {
                        var u = --n
                          , p = e[u]
                          , d = e[y = --t];
                        i[p.uuid] = l,
                        e[l] = p,
                        i[d.uuid] = u,
                        e[u] = d,
                        e.pop();
                        for (var f = 0, m = a; f !== m; ++f) {
                            var v = (x = r[f])[u]
                              , g = x[y];
                            x[l] = v,
                            x[u] = g,
                            x.pop()
                        }
                    } else {
                        var y;
                        i[(d = e[y = --t]).uuid] = l,
                        e[l] = d,
                        e.pop();
                        for (f = 0,
                        m = a; f !== m; ++f) {
                            var x;
                            (x = r[f])[l] = x[y],
                            x.pop()
                        }
                    }
            }
            this.nCachedObjects_ = n
        },
        subscribe_: function(e, t) {
            var n = this._bindingsIndicesByPath
              , i = n[e]
              , r = this._bindings;
            if (void 0 !== i)
                return r[i];
            var a = this._paths
              , o = this._parsedPaths
              , s = this._objects
              , c = s.length
              , h = this.nCachedObjects_
              , l = new Array(c);
            i = r.length,
            n[e] = i,
            a.push(e),
            o.push(t),
            r.push(l);
            for (var u = h, p = s.length; u !== p; ++u) {
                var d = s[u];
                l[u] = new Fc(d,e,t)
            }
            return l
        },
        unsubscribe_: function(e) {
            var t = this._bindingsIndicesByPath
              , n = t[e];
            if (void 0 !== n) {
                var i = this._paths
                  , r = this._parsedPaths
                  , a = this._bindings
                  , o = a.length - 1
                  , s = a[o];
                t[e[o]] = n,
                a[n] = s,
                a.pop(),
                r[n] = r[o],
                r.pop(),
                i[n] = i[o],
                i.pop()
            }
        }
    }),
    Object.assign(Hc.prototype, {
        play: function() {
            return this._mixer._activateAction(this),
            this
        },
        stop: function() {
            return this._mixer._deactivateAction(this),
            this.reset()
        },
        reset: function() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(e) {
            return this._startTime = e,
            this
        },
        setLoop: function(e, t) {
            return this.loop = e,
            this.repetitions = t,
            this
        },
        setEffectiveWeight: function(e) {
            return this.weight = e,
            this._effectiveWeight = this.enabled ? e : 0,
            this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(e) {
            return this._scheduleFading(e, 0, 1)
        },
        fadeOut: function(e) {
            return this._scheduleFading(e, 1, 0)
        },
        crossFadeFrom: function(e, t, n) {
            if (e.fadeOut(t),
            this.fadeIn(t),
            n) {
                var i = this._clip.duration
                  , r = e._clip.duration
                  , a = r / i
                  , o = i / r;
                e.warp(1, a, t),
                this.warp(o, 1, t)
            }
            return this
        },
        crossFadeTo: function(e, t, n) {
            return e.crossFadeFrom(this, t, n)
        },
        stopFading: function() {
            var e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(e)),
            this
        },
        setEffectiveTimeScale: function(e) {
            return this.timeScale = e,
            this._effectiveTimeScale = this.paused ? 0 : e,
            this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(e) {
            return this.timeScale = this._clip.duration / e,
            this.stopWarping()
        },
        syncWith: function(e) {
            return this.time = e.time,
            this.timeScale = e.timeScale,
            this.stopWarping()
        },
        halt: function(e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        },
        warp: function(e, t, n) {
            var i = this._mixer
              , r = i.time
              , a = this._timeScaleInterpolant
              , o = this.timeScale;
            null === a && (a = i._lendControlInterpolant(),
            this._timeScaleInterpolant = a);
            var s = a.parameterPositions
              , c = a.sampleValues;
            return s[0] = r,
            s[1] = r + n,
            c[0] = e / o,
            c[1] = t / o,
            this
        },
        stopWarping: function() {
            var e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(e)),
            this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(e, t, n, i) {
            if (this.enabled) {
                var r = this._startTime;
                if (null !== r) {
                    var a = (e - r) * n;
                    if (a < 0 || 0 === n)
                        return;
                    this._startTime = null,
                    t = n * a
                }
                t *= this._updateTimeScale(e);
                var o = this._updateTime(t)
                  , s = this._updateWeight(e);
                if (s > 0) {
                    var c = this._interpolants
                      , h = this._propertyBindings;
                    switch (this.blendMode) {
                    case 2501:
                        for (var l = 0, u = c.length; l !== u; ++l)
                            c[l].evaluate(o),
                            h[l].accumulateAdditive(s);
                        break;
                    case 2500:
                    default:
                        for (l = 0,
                        u = c.length; l !== u; ++l)
                            c[l].evaluate(o),
                            h[l].accumulate(i, s)
                    }
                }
            } else
                this._updateWeight(e)
        },
        _updateWeight: function(e) {
            var t = 0;
            if (this.enabled) {
                t = this.weight;
                var n = this._weightInterpolant;
                if (null !== n) {
                    var i = n.evaluate(e)[0];
                    t *= i,
                    e > n.parameterPositions[1] && (this.stopFading(),
                    0 === i && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = t,
            t
        },
        _updateTimeScale: function(e) {
            var t = 0;
            if (!this.paused) {
                t = this.timeScale;
                var n = this._timeScaleInterpolant;
                if (null !== n)
                    t *= n.evaluate(e)[0],
                    e > n.parameterPositions[1] && (this.stopWarping(),
                    0 === t ? this.paused = !0 : this.timeScale = t)
            }
            return this._effectiveTimeScale = t,
            t
        },
        _updateTime: function(e) {
            var t = this.time + e
              , n = this._clip.duration
              , i = this.loop
              , r = this._loopCount
              , a = 2202 === i;
            if (0 === e)
                return -1 === r ? t : a && 1 == (1 & r) ? n - t : t;
            if (2200 === i) {
                -1 === r && (this._loopCount = 0,
                this._setEndings(!0, !0, !1));
                e: {
                    if (t >= n)
                        t = n;
                    else {
                        if (!(t < 0)) {
                            this.time = t;
                            break e
                        }
                        t = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = t,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === r && (e >= 0 ? (r = 0,
                this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)),
                t >= n || t < 0) {
                    var o = Math.floor(t / n);
                    t -= n * o,
                    r += Math.abs(o);
                    var s = this.repetitions - r;
                    if (s <= 0)
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        t = e > 0 ? n : 0,
                        this.time = t,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1
                        });
                    else {
                        if (1 === s) {
                            var c = e < 0;
                            this._setEndings(c, !c, a)
                        } else
                            this._setEndings(!1, !1, a);
                        this._loopCount = r,
                        this.time = t,
                        this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: o
                        })
                    }
                } else
                    this.time = t;
                if (a && 1 == (1 & r))
                    return n - t
            }
            return t
        },
        _setEndings: function(e, t, n) {
            var i = this._interpolantSettings;
            n ? (i.endingStart = 2401,
            i.endingEnd = 2401) : (i.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402,
            i.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        },
        _scheduleFading: function(e, t, n) {
            var i = this._mixer
              , r = i.time
              , a = this._weightInterpolant;
            null === a && (a = i._lendControlInterpolant(),
            this._weightInterpolant = a);
            var o = a.parameterPositions
              , s = a.sampleValues;
            return o[0] = r,
            s[0] = t,
            o[1] = r + e,
            s[1] = n,
            this
        }
    }),
    kc.prototype = Object.assign(Object.create(r.prototype), {
        constructor: kc,
        _bindAction: function(e, t) {
            var n = e._localRoot || this._root
              , i = e._clip.tracks
              , r = i.length
              , a = e._propertyBindings
              , o = e._interpolants
              , s = n.uuid
              , c = this._bindingsByRootAndName
              , h = c[s];
            void 0 === h && (h = {},
            c[s] = h);
            for (var l = 0; l !== r; ++l) {
                var u = i[l]
                  , p = u.name
                  , d = h[p];
                if (void 0 !== d)
                    a[l] = d;
                else {
                    if (void 0 !== (d = a[l])) {
                        null === d._cacheIndex && (++d.referenceCount,
                        this._addInactiveBinding(d, s, p));
                        continue
                    }
                    var f = t && t._propertyBindings[l].binding.parsedPath;
                    ++(d = new Rc(Fc.create(n, p, f),u.ValueTypeName,u.getValueSize())).referenceCount,
                    this._addInactiveBinding(d, s, p),
                    a[l] = d
                }
                o[l].resultBuffer = d.buffer
            }
        },
        _activateAction: function(e) {
            if (!this._isActiveAction(e)) {
                if (null === e._cacheIndex) {
                    var t = (e._localRoot || this._root).uuid
                      , n = e._clip.uuid
                      , i = this._actionsByClip[n];
                    this._bindAction(e, i && i.knownActions[0]),
                    this._addInactiveAction(e, n, t)
                }
                for (var r = e._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
                    var s = r[a];
                    0 == s.useCount++ && (this._lendBinding(s),
                    s.saveOriginalState())
                }
                this._lendAction(e)
            }
        },
        _deactivateAction: function(e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) {
                    var r = t[n];
                    0 == --r.useCount && (r.restoreOriginalState(),
                    this._takeBackBinding(r))
                }
                this._takeBackAction(e)
            }
        },
        _initMemoryManager: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    },
                    get inUse() {
                        return e._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return e._bindings.length
                    },
                    get inUse() {
                        return e._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(e) {
            var t = e._cacheIndex;
            return null !== t && t < this._nActiveActions
        },
        _addInactiveAction: function(e, t, n) {
            var i = this._actions
              , r = this._actionsByClip
              , a = r[t];
            if (void 0 === a)
                a = {
                    knownActions: [e],
                    actionByRoot: {}
                },
                e._byClipCacheIndex = 0,
                r[t] = a;
            else {
                var o = a.knownActions;
                e._byClipCacheIndex = o.length,
                o.push(e)
            }
            e._cacheIndex = i.length,
            i.push(e),
            a.actionByRoot[n] = e
        },
        _removeInactiveAction: function(e) {
            var t = this._actions
              , n = t[t.length - 1]
              , i = e._cacheIndex;
            n._cacheIndex = i,
            t[i] = n,
            t.pop(),
            e._cacheIndex = null;
            var r = e._clip.uuid
              , a = this._actionsByClip
              , o = a[r]
              , s = o.knownActions
              , c = s[s.length - 1]
              , h = e._byClipCacheIndex;
            c._byClipCacheIndex = h,
            s[h] = c,
            s.pop(),
            e._byClipCacheIndex = null,
            delete o.actionByRoot[(e._localRoot || this._root).uuid],
            0 === s.length && delete a[r],
            this._removeInactiveBindingsForAction(e)
        },
        _removeInactiveBindingsForAction: function(e) {
            for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) {
                var r = t[n];
                0 == --r.referenceCount && this._removeInactiveBinding(r)
            }
        },
        _lendAction: function(e) {
            var t = this._actions
              , n = e._cacheIndex
              , i = this._nActiveActions++
              , r = t[i];
            e._cacheIndex = i,
            t[i] = e,
            r._cacheIndex = n,
            t[n] = r
        },
        _takeBackAction: function(e) {
            var t = this._actions
              , n = e._cacheIndex
              , i = --this._nActiveActions
              , r = t[i];
            e._cacheIndex = i,
            t[i] = e,
            r._cacheIndex = n,
            t[n] = r
        },
        _addInactiveBinding: function(e, t, n) {
            var i = this._bindingsByRootAndName
              , r = i[t]
              , a = this._bindings;
            void 0 === r && (r = {},
            i[t] = r),
            r[n] = e,
            e._cacheIndex = a.length,
            a.push(e)
        },
        _removeInactiveBinding: function(e) {
            var t = this._bindings
              , n = e.binding
              , i = n.rootNode.uuid
              , r = n.path
              , a = this._bindingsByRootAndName
              , o = a[i]
              , s = t[t.length - 1]
              , c = e._cacheIndex;
            s._cacheIndex = c,
            t[c] = s,
            t.pop(),
            delete o[r],
            0 === Object.keys(o).length && delete a[i]
        },
        _lendBinding: function(e) {
            var t = this._bindings
              , n = e._cacheIndex
              , i = this._nActiveBindings++
              , r = t[i];
            e._cacheIndex = i,
            t[i] = e,
            r._cacheIndex = n,
            t[n] = r
        },
        _takeBackBinding: function(e) {
            var t = this._bindings
              , n = e._cacheIndex
              , i = --this._nActiveBindings
              , r = t[i];
            e._cacheIndex = i,
            t[i] = e,
            r._cacheIndex = n,
            t[n] = r
        },
        _lendControlInterpolant: function() {
            var e = this._controlInterpolants
              , t = this._nActiveControlInterpolants++
              , n = e[t];
            return void 0 === n && ((n = new Ho(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex = t,
            e[t] = n),
            n
        },
        _takeBackControlInterpolant: function(e) {
            var t = this._controlInterpolants
              , n = e.__cacheIndex
              , i = --this._nActiveControlInterpolants
              , r = t[i];
            e.__cacheIndex = i,
            t[i] = e,
            r.__cacheIndex = n,
            t[n] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(e, t, n) {
            var i = t || this._root
              , r = i.uuid
              , a = "string" == typeof e ? Jo.findByName(i, e) : e
              , o = null !== a ? a.uuid : e
              , s = this._actionsByClip[o]
              , c = null;
            if (void 0 === n && (n = null !== a ? a.blendMode : 2500),
            void 0 !== s) {
                var h = s.actionByRoot[r];
                if (void 0 !== h && h.blendMode === n)
                    return h;
                c = s.knownActions[0],
                null === a && (a = c._clip)
            }
            if (null === a)
                return null;
            var l = new Hc(this,a,t,n);
            return this._bindAction(l, c),
            this._addInactiveAction(l, o, r),
            l
        },
        existingAction: function(e, t) {
            var n = t || this._root
              , i = n.uuid
              , r = "string" == typeof e ? Jo.findByName(n, e) : e
              , a = r ? r.uuid : e
              , o = this._actionsByClip[a];
            return void 0 !== o && o.actionByRoot[i] || null
        },
        stopAllAction: function() {
            for (var e = this._actions, t = this._nActiveActions - 1; t >= 0; --t)
                e[t].stop();
            return this
        },
        update: function(e) {
            e *= this.timeScale;
            for (var t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) {
                t[o]._update(i, e, r, a)
            }
            var s = this._bindings
              , c = this._nActiveBindings;
            for (o = 0; o !== c; ++o)
                s[o].apply(a);
            return this
        },
        setTime: function(e) {
            this.time = 0;
            for (var t = 0; t < this._actions.length; t++)
                this._actions[t].time = 0;
            return this.update(e)
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(e) {
            var t = this._actions
              , n = e.uuid
              , i = this._actionsByClip
              , r = i[n];
            if (void 0 !== r) {
                for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
                    var c = a[o];
                    this._deactivateAction(c);
                    var h = c._cacheIndex
                      , l = t[t.length - 1];
                    c._cacheIndex = null,
                    c._byClipCacheIndex = null,
                    l._cacheIndex = h,
                    t[h] = l,
                    t.pop(),
                    this._removeInactiveBindingsForAction(c)
                }
                delete i[n]
            }
        },
        uncacheRoot: function(e) {
            var t = e.uuid
              , n = this._actionsByClip;
            for (var i in n) {
                var r = n[i].actionByRoot[t];
                void 0 !== r && (this._deactivateAction(r),
                this._removeInactiveAction(r))
            }
            var a = this._bindingsByRootAndName[t];
            if (void 0 !== a)
                for (var o in a) {
                    var s = a[o];
                    s.restoreOriginalState(),
                    this._removeInactiveBinding(s)
                }
        },
        uncacheAction: function(e, t) {
            var n = this.existingAction(e, t);
            null !== n && (this._deactivateAction(n),
            this._removeInactiveAction(n))
        }
    }),
    Gc.prototype.clone = function() {
        return new Gc(void 0 === this.value.clone ? this.value : this.value.clone())
    }
    ,
    Vc.prototype = Object.assign(Object.create(rr.prototype), {
        constructor: Vc,
        isInstancedInterleavedBuffer: !0,
        copy: function(e) {
            return rr.prototype.copy.call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        }
    }),
    Object.assign(jc.prototype, {
        set: function(e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function(e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
            this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
            this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
            this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
            this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(e, t, n) {
            var i = n || [];
            return qc(e, this, i, t),
            i.sort(Wc),
            i
        },
        intersectObjects: function(e, t, n) {
            var i = n || [];
            if (!1 === Array.isArray(e))
                return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                i;
            for (var r = 0, a = e.length; r < a; r++)
                qc(e[r], this, i, t);
            return i.sort(Wc),
            i
        }
    }),
    Object.assign(function(e, t, n) {
        return this.radius = void 0 !== e ? e : 1,
        this.phi = void 0 !== t ? t : 0,
        this.theta = void 0 !== n ? n : 0,
        this
    }
    .prototype, {
        set: function(e, t, n) {
            return this.radius = e,
            this.phi = t,
            this.theta = n,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius,
            this.phi = e.phi,
            this.theta = e.theta,
            this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
            this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, n) {
            return this.radius = Math.sqrt(e * e + t * t + n * n),
            0 === this.radius ? (this.theta = 0,
            this.phi = 0) : (this.theta = Math.atan2(e, n),
            this.phi = Math.acos(c.clamp(t / this.radius, -1, 1))),
            this
        }
    }),
    Object.assign(function(e, t, n) {
        return this.radius = void 0 !== e ? e : 1,
        this.theta = void 0 !== t ? t : 0,
        this.y = void 0 !== n ? n : 0,
        this
    }
    .prototype, {
        set: function(e, t, n) {
            return this.radius = e,
            this.theta = t,
            this.y = n,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius,
            this.theta = e.theta,
            this.y = e.y,
            this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, n) {
            return this.radius = Math.sqrt(e * e + n * n),
            this.theta = Math.atan2(e, n),
            this.y = t,
            this
        }
    });
    var Xc = new h;
    function Yc(e, t) {
        this.min = void 0 !== e ? e : new h(1 / 0,1 / 0),
        this.max = void 0 !== t ? t : new h(-1 / 0,-1 / 0)
    }
    Object.assign(Yc.prototype, {
        set: function(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, n = e.length; t < n; t++)
                this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function(e, t) {
            var n = Xc.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n),
            this.max.copy(e).add(n),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"),
            e = new h),
            this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"),
            e = new h),
            this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        },
        expandByVector: function(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        },
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"),
            t = new h),
            t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        },
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"),
            t = new h),
            t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function(e) {
            return Xc.copy(e).clamp(this.min, this.max).sub(e).length()
        },
        intersect: function(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this
        },
        union: function(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        },
        translate: function(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    });
    var Zc = new b
      , Jc = new b;
    function Kc(e, t) {
        this.start = void 0 !== e ? e : new b,
        this.end = void 0 !== t ? t : new b
    }
    function Qc(e) {
        q.call(this),
        this.material = e,
        this.render = function() {}
        ,
        this.hasPositions = !1,
        this.hasNormals = !1,
        this.hasColors = !1,
        this.hasUvs = !1,
        this.positionArray = null,
        this.normalArray = null,
        this.colorArray = null,
        this.uvArray = null,
        this.count = 0
    }
    Object.assign(Kc.prototype, {
        set: function(e, t) {
            return this.start.copy(e),
            this.end.copy(t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.start.copy(e.start),
            this.end.copy(e.end),
            this
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"),
            e = new b),
            e.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"),
            e = new b),
            e.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"),
            t = new b),
            this.delta(t).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: function(e, t) {
            Zc.subVectors(e, this.start),
            Jc.subVectors(this.end, this.start);
            var n = Jc.dot(Jc)
              , i = Jc.dot(Zc) / n;
            return t && (i = c.clamp(i, 0, 1)),
            i
        },
        closestPointToPoint: function(e, t, n) {
            var i = this.closestPointToPointParameter(e, t);
            return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"),
            n = new b),
            this.delta(n).multiplyScalar(i).add(this.start)
        },
        applyMatrix4: function(e) {
            return this.start.applyMatrix4(e),
            this.end.applyMatrix4(e),
            this
        },
        equals: function(e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }),
    Qc.prototype = Object.create(q.prototype),
    Qc.prototype.constructor = Qc,
    Qc.prototype.isImmediateRenderObject = !0;
    var $c = new b;
    function eh(e, t) {
        q.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = t;
        for (var n = new ut, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, a = 1; r < 32; r++,
        a++) {
            var o = r / 32 * Math.PI * 2
              , s = a / 32 * Math.PI * 2;
            i.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1)
        }
        n.setAttribute("position", new et(i,3));
        var c = new kr({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new Jr(n,c),
        this.add(this.cone),
        this.update()
    }
    eh.prototype = Object.create(q.prototype),
    eh.prototype.constructor = eh,
    eh.prototype.dispose = function() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    ,
    eh.prototype.update = function() {
        this.light.updateMatrixWorld();
        var e = this.light.distance ? this.light.distance : 1e3
          , t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
        $c.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt($c),
        void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
    ;
    var th = new b
      , nh = new L
      , ih = new L;
    function rh(e) {
        for (var t = function e(t) {
            var n = [];
            t && t.isBone && n.push(t);
            for (var i = 0; i < t.children.length; i++)
                n.push.apply(n, e(t.children[i]));
            return n
        }(e), n = new ut, i = [], r = [], a = new ze(0,0,1), o = new ze(0,1,0), s = 0; s < t.length; s++) {
            var c = t[s];
            c.parent && c.parent.isBone && (i.push(0, 0, 0),
            i.push(0, 0, 0),
            r.push(a.r, a.g, a.b),
            r.push(o.r, o.g, o.b))
        }
        n.setAttribute("position", new et(i,3)),
        n.setAttribute("color", new et(r,3));
        var h = new kr({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        Jr.call(this, n, h),
        this.type = "SkeletonHelper",
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    function ah(e, t, n) {
        this.light = e,
        this.light.updateMatrixWorld(),
        this.color = n;
        var i = new ho(t,4,2)
          , r = new je({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        });
        Rt.call(this, i, r),
        this.type = "PointLightHelper",
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    rh.prototype = Object.create(Jr.prototype),
    rh.prototype.constructor = rh,
    rh.prototype.isSkeletonHelper = !0,
    rh.prototype.updateMatrixWorld = function(e) {
        var t = this.bones
          , n = this.geometry
          , i = n.getAttribute("position");
        ih.getInverse(this.root.matrixWorld);
        for (var r = 0, a = 0; r < t.length; r++) {
            var o = t[r];
            o.parent && o.parent.isBone && (nh.multiplyMatrices(ih, o.matrixWorld),
            th.setFromMatrixPosition(nh),
            i.setXYZ(a, th.x, th.y, th.z),
            nh.multiplyMatrices(ih, o.parent.matrixWorld),
            th.setFromMatrixPosition(nh),
            i.setXYZ(a + 1, th.x, th.y, th.z),
            a += 2)
        }
        n.getAttribute("position").needsUpdate = !0,
        q.prototype.updateMatrixWorld.call(this, e)
    }
    ,
    ah.prototype = Object.create(Rt.prototype),
    ah.prototype.constructor = ah,
    ah.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    ah.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
    ;
    var oh = new b
      , sh = new ze
      , ch = new ze;
    function hh(e, t, n) {
        q.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = n;
        var i = new ga(t);
        i.rotateY(.5 * Math.PI),
        this.material = new je({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }),
        void 0 === this.color && (this.material.vertexColors = !0);
        var r = i.getAttribute("position")
          , a = new Float32Array(3 * r.count);
        i.setAttribute("color", new qe(a,3)),
        this.add(new Rt(i,this.material)),
        this.update()
    }
    function lh(e, t, n, i) {
        e = e || 10,
        t = t || 10,
        n = new ze(void 0 !== n ? n : 4473924),
        i = new ze(void 0 !== i ? i : 8947848);
        for (var r = t / 2, a = e / t, o = e / 2, s = [], c = [], h = 0, l = 0, u = -o; h <= t; h++,
        u += a) {
            s.push(-o, 0, u, o, 0, u),
            s.push(u, 0, -o, u, 0, o);
            var p = h === r ? n : i;
            p.toArray(c, l),
            l += 3,
            p.toArray(c, l),
            l += 3,
            p.toArray(c, l),
            l += 3,
            p.toArray(c, l),
            l += 3
        }
        var d = new ut;
        d.setAttribute("position", new et(s,3)),
        d.setAttribute("color", new et(c,3));
        var f = new kr({
            vertexColors: !0,
            toneMapped: !1
        });
        Jr.call(this, d, f),
        this.type = "GridHelper"
    }
    function uh(e, t, n, i, r, a) {
        e = e || 10,
        t = t || 16,
        n = n || 8,
        i = i || 64,
        r = new ze(void 0 !== r ? r : 4473924),
        a = new ze(void 0 !== a ? a : 8947848);
        var o, s, c, h, l, u, p, d = [], f = [];
        for (h = 0; h <= t; h++)
            c = h / t * (2 * Math.PI),
            o = Math.sin(c) * e,
            s = Math.cos(c) * e,
            d.push(0, 0, 0),
            d.push(o, 0, s),
            p = 1 & h ? r : a,
            f.push(p.r, p.g, p.b),
            f.push(p.r, p.g, p.b);
        for (h = 0; h <= n; h++)
            for (p = 1 & h ? r : a,
            u = e - e / n * h,
            l = 0; l < i; l++)
                c = l / i * (2 * Math.PI),
                o = Math.sin(c) * u,
                s = Math.cos(c) * u,
                d.push(o, 0, s),
                f.push(p.r, p.g, p.b),
                c = (l + 1) / i * (2 * Math.PI),
                o = Math.sin(c) * u,
                s = Math.cos(c) * u,
                d.push(o, 0, s),
                f.push(p.r, p.g, p.b);
        var m = new ut;
        m.setAttribute("position", new et(d,3)),
        m.setAttribute("color", new et(f,3));
        var v = new kr({
            vertexColors: !0,
            toneMapped: !1
        });
        Jr.call(this, m, v),
        this.type = "PolarGridHelper"
    }
    hh.prototype = Object.create(q.prototype),
    hh.prototype.constructor = hh,
    hh.prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    hh.prototype.update = function() {
        var e = this.children[0];
        if (void 0 !== this.color)
            this.material.color.set(this.color);
        else {
            var t = e.geometry.getAttribute("color");
            sh.copy(this.light.color),
            ch.copy(this.light.groundColor);
            for (var n = 0, i = t.count; n < i; n++) {
                var r = n < i / 2 ? sh : ch;
                t.setXYZ(n, r.r, r.g, r.b)
            }
            t.needsUpdate = !0
        }
        e.lookAt(oh.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
    ,
    lh.prototype = Object.assign(Object.create(Jr.prototype), {
        constructor: lh,
        copy: function(e) {
            return Jr.prototype.copy.call(this, e),
            this.geometry.copy(e.geometry),
            this.material.copy(e.material),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    uh.prototype = Object.create(Jr.prototype),
    uh.prototype.constructor = uh;
    var ph = new b
      , dh = new b
      , fh = new b;
    function mh(e, t, n) {
        q.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = n,
        void 0 === t && (t = 1);
        var i = new ut;
        i.setAttribute("position", new et([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
        var r = new kr({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new Xr(i,r),
        this.add(this.lightPlane),
        (i = new ut).setAttribute("position", new et([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new Xr(i,r),
        this.add(this.targetLine),
        this.update()
    }
    mh.prototype = Object.create(q.prototype),
    mh.prototype.constructor = mh,
    mh.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    ,
    mh.prototype.update = function() {
        ph.setFromMatrixPosition(this.light.matrixWorld),
        dh.setFromMatrixPosition(this.light.target.matrixWorld),
        fh.subVectors(dh, ph),
        this.lightPlane.lookAt(dh),
        void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(dh),
        this.targetLine.scale.z = fh.length()
    }
    ;
    var vh = new b
      , gh = new Gt;
    function yh(e) {
        var t = new ut
          , n = new kr({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
        })
          , i = []
          , r = []
          , a = {}
          , o = new ze(16755200)
          , s = new ze(16711680)
          , c = new ze(43775)
          , h = new ze(16777215)
          , l = new ze(3355443);
        function u(e, t, n) {
            p(e, n),
            p(t, n)
        }
        function p(e, t) {
            i.push(0, 0, 0),
            r.push(t.r, t.g, t.b),
            void 0 === a[e] && (a[e] = []),
            a[e].push(i.length / 3 - 1)
        }
        u("n1", "n2", o),
        u("n2", "n4", o),
        u("n4", "n3", o),
        u("n3", "n1", o),
        u("f1", "f2", o),
        u("f2", "f4", o),
        u("f4", "f3", o),
        u("f3", "f1", o),
        u("n1", "f1", o),
        u("n2", "f2", o),
        u("n3", "f3", o),
        u("n4", "f4", o),
        u("p", "n1", s),
        u("p", "n2", s),
        u("p", "n3", s),
        u("p", "n4", s),
        u("u1", "u2", c),
        u("u2", "u3", c),
        u("u3", "u1", c),
        u("c", "t", h),
        u("p", "c", l),
        u("cn1", "cn2", l),
        u("cn3", "cn4", l),
        u("cf1", "cf2", l),
        u("cf3", "cf4", l),
        t.setAttribute("position", new et(i,3)),
        t.setAttribute("color", new et(r,3)),
        Jr.call(this, t, n),
        this.type = "CameraHelper",
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = a,
        this.update()
    }
    function xh(e, t, n, i, r, a, o) {
        vh.set(r, a, o).unproject(i);
        var s = t[e];
        if (void 0 !== s)
            for (var c = n.getAttribute("position"), h = 0, l = s.length; h < l; h++)
                c.setXYZ(s[h], vh.x, vh.y, vh.z)
    }
    yh.prototype = Object.create(Jr.prototype),
    yh.prototype.constructor = yh,
    yh.prototype.update = function() {
        var e = this.geometry
          , t = this.pointMap;
        gh.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        xh("c", t, e, gh, 0, 0, -1),
        xh("t", t, e, gh, 0, 0, 1),
        xh("n1", t, e, gh, -1, -1, -1),
        xh("n2", t, e, gh, 1, -1, -1),
        xh("n3", t, e, gh, -1, 1, -1),
        xh("n4", t, e, gh, 1, 1, -1),
        xh("f1", t, e, gh, -1, -1, 1),
        xh("f2", t, e, gh, 1, -1, 1),
        xh("f3", t, e, gh, -1, 1, 1),
        xh("f4", t, e, gh, 1, 1, 1),
        xh("u1", t, e, gh, .7, 1.1, -1),
        xh("u2", t, e, gh, -.7, 1.1, -1),
        xh("u3", t, e, gh, 0, 2, -1),
        xh("cf1", t, e, gh, -1, 0, 1),
        xh("cf2", t, e, gh, 1, 0, 1),
        xh("cf3", t, e, gh, 0, -1, 1),
        xh("cf4", t, e, gh, 0, 1, 1),
        xh("cn1", t, e, gh, -1, 0, -1),
        xh("cn2", t, e, gh, 1, 0, -1),
        xh("cn3", t, e, gh, 0, -1, -1),
        xh("cn4", t, e, gh, 0, 1, -1),
        e.getAttribute("position").needsUpdate = !0
    }
    ;
    var bh = new se;
    function _h(e, t) {
        this.object = e,
        void 0 === t && (t = 16776960);
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , i = new Float32Array(24)
          , r = new ut;
        r.setIndex(new qe(n,1)),
        r.setAttribute("position", new qe(i,3)),
        Jr.call(this, r, new kr({
            color: t,
            toneMapped: !1
        })),
        this.type = "BoxHelper",
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function wh(e, t) {
        this.type = "Box3Helper",
        this.box = e,
        t = t || 16776960;
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , i = new ut;
        i.setIndex(new qe(n,1)),
        i.setAttribute("position", new et([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
        Jr.call(this, i, new kr({
            color: t,
            toneMapped: !1
        })),
        this.type = "Box3Helper",
        this.geometry.computeBoundingSphere()
    }
    function Mh(e, t, n) {
        this.plane = e,
        this.size = void 0 === t ? 1 : t;
        var i = void 0 !== n ? n : 16776960
          , r = new ut;
        r.setAttribute("position", new et([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],3)),
        r.computeBoundingSphere(),
        Xr.call(this, r, new kr({
            color: i,
            toneMapped: !1
        })),
        this.type = "PlaneHelper";
        var a = new ut;
        a.setAttribute("position", new et([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],3)),
        a.computeBoundingSphere(),
        this.add(new Rt(a,new je({
            color: i,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    _h.prototype = Object.create(Jr.prototype),
    _h.prototype.constructor = _h,
    _h.prototype.update = function(e) {
        if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
        void 0 !== this.object && bh.setFromObject(this.object),
        !bh.isEmpty()) {
            var t = bh.min
              , n = bh.max
              , i = this.geometry.attributes.position
              , r = i.array;
            r[0] = n.x,
            r[1] = n.y,
            r[2] = n.z,
            r[3] = t.x,
            r[4] = n.y,
            r[5] = n.z,
            r[6] = t.x,
            r[7] = t.y,
            r[8] = n.z,
            r[9] = n.x,
            r[10] = t.y,
            r[11] = n.z,
            r[12] = n.x,
            r[13] = n.y,
            r[14] = t.z,
            r[15] = t.x,
            r[16] = n.y,
            r[17] = t.z,
            r[18] = t.x,
            r[19] = t.y,
            r[20] = t.z,
            r[21] = n.x,
            r[22] = t.y,
            r[23] = t.z,
            i.needsUpdate = !0,
            this.geometry.computeBoundingSphere()
        }
    }
    ,
    _h.prototype.setFromObject = function(e) {
        return this.object = e,
        this.update(),
        this
    }
    ,
    _h.prototype.copy = function(e) {
        return Jr.prototype.copy.call(this, e),
        this.object = e.object,
        this
    }
    ,
    _h.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    wh.prototype = Object.create(Jr.prototype),
    wh.prototype.constructor = wh,
    wh.prototype.updateMatrixWorld = function(e) {
        var t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        q.prototype.updateMatrixWorld.call(this, e))
    }
    ,
    Mh.prototype = Object.create(Xr.prototype),
    Mh.prototype.constructor = Mh,
    Mh.prototype.updateMatrixWorld = function(e) {
        var t = -this.plane.constant;
        Math.abs(t) < 1e-8 && (t = 1e-8),
        this.scale.set(.5 * this.size, .5 * this.size, t),
        this.children[0].material.side = t < 0 ? 1 : 0,
        this.lookAt(this.plane.normal),
        q.prototype.updateMatrixWorld.call(this, e)
    }
    ;
    var Sh, Th, Eh = new b;
    function Ah(e, t, n, i, r, a) {
        q.call(this),
        this.type = "ArrowHelper",
        void 0 === e && (e = new b(0,0,1)),
        void 0 === t && (t = new b(0,0,0)),
        void 0 === n && (n = 1),
        void 0 === i && (i = 16776960),
        void 0 === r && (r = .2 * n),
        void 0 === a && (a = .2 * r),
        void 0 === Sh && ((Sh = new ut).setAttribute("position", new et([0, 0, 0, 0, 1, 0],3)),
        (Th = new bo(0,.5,1,5,1)).translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new Xr(Sh,new kr({
            color: i,
            toneMapped: !1
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new Rt(Th,new je({
            color: i,
            toneMapped: !1
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(n, r, a)
    }
    function Lh(e) {
        var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , n = new ut;
        n.setAttribute("position", new et(t,3)),
        n.setAttribute("color", new et([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3));
        var i = new kr({
            vertexColors: !0,
            toneMapped: !1
        });
        Jr.call(this, n, i),
        this.type = "AxesHelper"
    }
    Ah.prototype = Object.create(q.prototype),
    Ah.prototype.constructor = Ah,
    Ah.prototype.setDirection = function(e) {
        if (e.y > .99999)
            this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999)
            this.quaternion.set(1, 0, 0, 0);
        else {
            Eh.set(e.z, 0, -e.x).normalize();
            var t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(Eh, t)
        }
    }
    ,
    Ah.prototype.setLength = function(e, t, n) {
        void 0 === t && (t = .2 * e),
        void 0 === n && (n = .2 * t),
        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(n, t, n),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    ,
    Ah.prototype.setColor = function(e) {
        this.line.material.color.set(e),
        this.cone.material.color.set(e)
    }
    ,
    Ah.prototype.copy = function(e) {
        return q.prototype.copy.call(this, e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    ,
    Ah.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    Lh.prototype = Object.create(Jr.prototype),
    Lh.prototype.constructor = Lh;
    var Rh = [.125, .215, .35, .446, .526, .582]
      , Ph = 5 + Rh.length
      , {_lodPlanes: Ch, _sizeLods: Oh, _sigmas: Ih} = (new Hs,
    function() {
        for (var e = [], t = [], n = [], i = 8, r = 0; r < Ph; r++) {
            var a = Math.pow(2, i);
            t.push(a);
            var o = 1 / a;
            r > 4 ? o = Rh[r - 8 + 4 - 1] : 0 == r && (o = 0),
            n.push(o);
            for (var s = 1 / (a - 1), c = -s / 2, h = 1 + s / 2, l = [c, c, h, c, h, h, c, c, h, h, c, h], u = new Float32Array(108), p = new Float32Array(72), d = new Float32Array(36), f = 0; f < 6; f++) {
                var m = f % 3 * 2 / 3 - 1
                  , v = f > 2 ? 0 : -1
                  , g = [m, v, 0, m + 2 / 3, v, 0, m + 2 / 3, v + 1, 0, m, v, 0, m + 2 / 3, v + 1, 0, m, v + 1, 0];
                u.set(g, 18 * f),
                p.set(l, 12 * f);
                var y = [f, f, f, f, f, f];
                d.set(y, 6 * f)
            }
            var x = new ut;
            x.setAttribute("position", new qe(u,3)),
            x.setAttribute("uv", new qe(p,2)),
            x.setAttribute("faceIndex", new qe(d,1)),
            e.push(x),
            i > 4 && i--
        }
        return {
            _lodPlanes: e,
            _sizeLods: t,
            _sigmas: n
        }
    }());
    function Dh(e) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),
        ys.call(this, e),
        this.type = "catmullrom"
    }
    ls.create = function(e, t) {
        return console.log("THREE.Curve.create() has been deprecated"),
        e.prototype = Object.create(ls.prototype),
        e.prototype.constructor = e,
        e.prototype.getPoint = t,
        e
    }
    ,
    Object.assign(Ps.prototype, {
        createPointsGeometry: function(e) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var t = this.getPoints(e);
            return this.createGeometry(t)
        },
        createSpacedPointsGeometry: function(e) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var t = this.getSpacedPoints(e);
            return this.createGeometry(t)
        },
        createGeometry: function(e) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var t = new Ut, n = 0, i = e.length; n < i; n++) {
                var r = e[n];
                t.vertices.push(new b(r.x,r.y,r.z || 0))
            }
            return t
        }
    }),
    Object.assign(Cs.prototype, {
        fromPoints: function(e) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
            this.setFromPoints(e)
        }
    }),
    Dh.prototype = Object.create(ys.prototype),
    Object.assign(Dh.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }),
    lh.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }
    ,
    rh.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }
    ,
    Object.assign(ts.prototype, {
        extractUrlBase: function(e) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
            Zs(e)
        }
    }),
    ts.Handlers = {
        add: function() {
            console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
        },
        get: function() {
            console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
        }
    },
    Object.assign(ec.prototype, {
        setTexturePath: function(e) {
            return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),
            this.setResourcePath(e)
        }
    }),
    Object.assign(Yc.prototype, {
        center: function(e) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
            this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        },
        size: function(e) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(e)
        }
    }),
    Object.assign(se.prototype, {
        center: function(e) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
            this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(e)
        },
        size: function(e) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(e)
        }
    }),
    Object.assign(le.prototype, {
        empty: function() {
            return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
    }),
    Zt.prototype.setFromMatrix = function(e) {
        return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
        this.setFromProjectionMatrix(e)
    }
    ,
    Kc.prototype.center = function(e) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
        this.getCenter(e)
    }
    ,
    Object.assign(c, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
            Math.random()
        },
        nearestPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
            c.floorPowerOfTwo(e)
        },
        nextPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
            c.ceilPowerOfTwo(e)
        }
    }),
    Object.assign(l.prototype, {
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(e, t)
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            e.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBufferAttribute: function(e) {
            return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
            e.applyMatrix3(this)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }),
    Object.assign(L.prototype, {
        extractPosition: function(e) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(e)
        },
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(e, t)
        },
        getPosition: function() {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
            (new b).setFromMatrixColumn(this, 3)
        },
        setRotationFromQuaternion: function(e) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        multiplyVector4: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(e) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            e.transformDirection(this)
        },
        crossVector: function(e) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBufferAttribute: function(e) {
            return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(e, t, n, i, r, a) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
            this.makePerspective(e, t, i, n, r, a)
        }
    }),
    we.prototype.isIntersectionLine = function(e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
        this.intersectsLine(e)
    }
    ,
    g.prototype.multiplyVector3 = function(e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
        e.applyQuaternion(this)
    }
    ,
    Object.assign(ye.prototype, {
        isIntersectionBox: function(e) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        },
        isIntersectionPlane: function(e) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(e)
        }
    }),
    Object.assign(Ie.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
            this.getArea()
        },
        barycoordFromPoint: function(e, t) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            this.getBarycoord(e, t)
        },
        midpoint: function(e) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
            this.getMidpoint(e)
        },
        normal: function(e) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            this.getNormal(e)
        },
        plane: function(e) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
            this.getPlane(e)
        }
    }),
    Object.assign(Ie, {
        barycoordFromPoint: function(e, t, n, i, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            Ie.getBarycoord(e, t, n, i, r)
        },
        normal: function(e, t, n, i) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            Ie.getNormal(e, t, n, i)
        }
    }),
    Object.assign(Os.prototype, {
        extractAllPoints: function(e) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
            this.extractPoints(e)
        },
        extrude: function(e) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
            new no(this,e)
        },
        makeGeometry: function(e) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
            new mo(this,e)
        }
    }),
    Object.assign(h.prototype, {
        fromAttribute: function(e, t, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(e, t, n)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(b.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function(e, t) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(t, e)
        },
        applyProjection: function(e) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
            this.applyMatrix4(e)
        },
        fromAttribute: function(e, t, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(e, t, n)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(f.prototype, {
        fromAttribute: function(e, t, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(e, t, n)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(Ut.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        },
        applyMatrix: function(e) {
            return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),
            this.applyMatrix4(e)
        }
    }),
    Object.assign(q.prototype, {
        getChildByName: function(e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(e)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(e, t) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(t, e)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        },
        applyMatrix: function(e) {
            return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
            this.applyMatrix4(e)
        }
    }),
    Object.defineProperties(q.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order
            },
            set: function(e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }),
    Object.assign(Rt.prototype, {
        setDrawMode: function() {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
    }),
    Object.defineProperties(Rt.prototype, {
        drawMode: {
            get: function() {
                return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
                0
            },
            set: function() {
                console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }
    }),
    Object.defineProperties(Pr.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                this.levels
            }
        }
    }),
    Object.defineProperty(Dr.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }),
    Cr.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }
    ,
    Object.defineProperty(ls.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions
        },
        set: function(e) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions = e
        }
    }),
    Vt.prototype.setLens = function(e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
        void 0 !== t && (this.filmGauge = t),
        this.setFocalLength(e)
    }
    ,
    Object.defineProperties(Is.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                this.shadow.mapSize.height = e
            }
        }
    }),
    Object.defineProperties(qe.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                this.array.length
            }
        },
        dynamic: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                35048 === this.usage
            },
            set: function() {
                console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                this.setUsage(35048)
            }
        }
    }),
    Object.assign(qe.prototype, {
        setDynamic: function(e) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
            this.setUsage(!0 === e ? 35048 : 35044),
            this
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        },
        setArray: function() {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }),
    Object.assign(ut.prototype, {
        addIndex: function(e) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(e)
        },
        addAttribute: function(e, t) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
            t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
            this.setIndex(t),
            this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
            this.setAttribute(e, new qe(t,arguments[2])))
        },
        addDrawCall: function(e, t, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
            this.addGroup(e, t)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        },
        removeAttribute: function(e) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
            this.deleteAttribute(e)
        },
        applyMatrix: function(e) {
            return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
            this.applyMatrix4(e)
        }
    }),
    Object.defineProperties(ut.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                this.groups
            }
        }
    }),
    Object.defineProperties(Js.prototype, {
        maxInstancedCount: {
            get: function() {
                return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
                this.instanceCount
            },
            set: function(e) {
                console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
                this.instanceCount = e
            }
        }
    }),
    Object.defineProperties(jc.prototype, {
        linePrecision: {
            get: function() {
                return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
                this.params.Line.threshold
            },
            set: function(e) {
                console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
                this.params.Line.threshold = e
            }
        }
    }),
    Object.defineProperties(rr.prototype, {
        dynamic: {
            get: function() {
                return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                35048 === this.usage
            },
            set: function(e) {
                console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                this.setUsage(e)
            }
        }
    }),
    Object.assign(rr.prototype, {
        setDynamic: function(e) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
            this.setUsage(!0 === e ? 35048 : 35044),
            this
        },
        setArray: function() {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }),
    Object.assign(io.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }),
    Object.defineProperties(Gc.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
                this
            }
        }
    }),
    Object.defineProperties(Ve.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."),
                new ze
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(e) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = 1 === e
            }
        },
        stencilMask: {
            get: function() {
                return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                this.stencilFuncMask
            },
            set: function(e) {
                console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                this.stencilFuncMask = e
            }
        }
    }),
    Object.defineProperties(Po.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }),
    Object.defineProperties(kt.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives
            },
            set: function(e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives = e
            }
        }
    }),
    Object.assign(tr.prototype, {
        clearTarget: function(e, t, n, i) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
            this.setRenderTarget(e),
            this.clear(t, n, i)
        },
        animate: function(e) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
            this.setAnimationLoop(e)
        },
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
            this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
            this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
            this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
            this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
            this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(e) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(e)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        },
        allocTextureUnit: function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        },
        setTexture: function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        },
        setTexture2D: function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        },
        setTextureCube: function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        },
        getActiveMipMapLevel: function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
            this.getActiveMipmapLevel()
        }
    }),
    Object.defineProperties(tr.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        context: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
                this.getContext()
            }
        },
        vr: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
                this.xr
            }
        },
        gammaInput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
                !1
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
            }
        },
        gammaOutput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                !1
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                this.outputEncoding = !0 === e ? 3001 : 3e3
            }
        }
    }),
    Object.defineProperties(qi.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(m.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy = e
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset = e
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat = e
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format = e
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps = e
            }
        }
    }),
    Object.defineProperties(wc.prototype, {
        load: {
            value: function(e) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var t = this;
                return (new uc).load(e, (function(e) {
                    t.setBuffer(e)
                }
                )),
                this
            }
        },
        startTime: {
            set: function() {
                console.warn("THREE.Audio: .startTime is now .play( delay ).")
            }
        }
    }),
    Lc.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
        this.getFrequencyData()
    }
    ,
    jt.prototype.updateCubeMap = function(e, t) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(e, t)
    }
    ,
    u.crossOrigin = void 0,
    u.loadTexture = function(e, t, n, i) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var r = new hs;
        r.setCrossOrigin(this.crossOrigin);
        var a = r.load(e, n, void 0, i);
        return t && (a.mapping = t),
        a
    }
    ,
    u.loadTextureCube = function(e, t, n, i) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var r = new cs;
        r.setCrossOrigin(this.crossOrigin);
        var a = r.load(e, n, void 0, i);
        return t && (a.mapping = t),
        a
    }
    ,
    u.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    u.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
        detail: {
            revision: "117"
        }
    }));
    var Nh = function() {
        function e(n, i) {
            t(this, e),
            this.fileLoaded = this.fileLoaded.bind(this),
            this.callback = i,
            this.loader = new hs,
            this.mesh = null,
            this.loader.load(n, this.fileLoaded)
        }
        return i(e, [{
            key: "fileLoaded",
            value: function(e) {
                var t = new ho(500,60,40);
                t.scale(-1, 1, 1);
                var n = new je({
                    map: e
                });
                this.mesh = new Rt(t,n),
                this.mesh.rotation.y = -45,
                this.callback()
            }
        }, {
            key: "destroy",
            value: function() {
                null !== this.mesh && (this.mesh.parent && this.mesh.parent.remove(this.mesh),
                this.mesh.geometry.dispose(),
                this.mesh.material.dispose()),
                delete this.callback,
                delete this.loader,
                delete this.mesh
            }
        }, {
            key: "addTo",
            value: function(e) {
                null !== this.mesh && e.add(this.mesh)
            }
        }, {
            key: "removeFrom",
            value: function(e) {
                null !== this.mesh && e.remove(this.mesh)
            }
        }]),
        e
    }()
      , Uh = function() {
        function e(n, i, r, a) {
            t(this, e),
            this.canvas = document.createElement("canvas"),
            this.canvas.setAttribute("id","canvas");
            this.canvas.id = "canvas1",
            this.canvas.className = "hidden-canvas",
            this.canvas.width = 1024,
            this.canvas.height = 512,
            this.context = this.canvas.getContext("2d"),
            this.texture = new sa(this.canvas);
            var o = new $t(.1,.05)
              , s = new je({
                map: this.texture,
                transparent: !0
            });
            this.mesh = new Rt(o,s),
            this.mesh.name = i,
            this.mesh.position.set(a.x, a.y, a.z),
            n.add(this.mesh),
            this.buttonText = r,
            this.isActive = !1,
            this.isLoading = !1,
            this.isHover = !1,
            this.animActive = 0,
            this.animHover = 0
        }
        return i(e, [{
            key: "destroy",
            value: function() {
                null !== this.mesh && (this.mesh.parent && this.mesh.parent.remove(this.mesh),
                this.mesh.geometry.dispose(),
                this.mesh.material.dispose()),
                delete this.animActive,
                delete this.animHover,
                delete this.buttonText,
                delete this.canvas,
                delete this.context,
                delete this.isActive,
                delete this.isHover,
                delete this.mesh,
                delete this.texture
            }
        }, {
            key: "isVisible",
            value: function() {
                return this.isActive
            }
        }, {
            key: "hide",
            value: function() {
                this.isActive = !1
            }
        }, {
            key: "show",
            value: function() {
                this.isActive = !0
            }
        }, {
            key: "setButtonText",
            value: function(e) {
                this.buttonText = e
            }
        }, {
            key: "setHover",
            value: function(e) {
                this.isHover = e
            }
        }, {
            key: "setLoading",
            value: function(e) {
                this.isLoading = e
            }
        }, {
            key: "update",
            value: function() {
                var e = this.isActive ? 1 : 0;
                this.animActive += .1 * (e - this.animActive);
                var t = this.isActive && this.animActive < .9 ? 1 : 0
                  , n = this.isActive && (this.isHover || this.isLoading) ? 1 : t;
                this.animHover += .2 * (n - this.animHover);
                var i = this.canvas.width
                  , r = this.canvas.height
                  , a = this.animActive >= .5 ? 100 * this.animActive - 20 * this.animHover : 0
                  , o = 20 * this.animHover
                  , s = 75 * this.animActive
                  , c = 10 + 10 * this.animHover
                  , h = (i + 200 - 80) * this.animHover;
                this.context.clearRect(0, 0, i, r),
                h > 0 && (this.context.fillStyle = "rgba(255, 255, 255, 0.15)",
                this.context.beginPath(),
                this.context.moveTo(i / 2 - 100 - h / 2, 40),
                this.context.lineTo(i / 2 - 100 + h / 2, 40),
                this.context.lineTo(i / 2 + 100 + h / 2, r - 40),
                this.context.lineTo(i / 2 + 100 - h / 2, r - 40),
                this.context.fill(),
                this.context.clearRect(0, 0, 40, r),
                this.context.clearRect(i - 40, 0, 40, r)),
                s > o && (this.context.fillStyle = "#fff",
                this.context.fillRect(o, o, s - o, c),
                this.context.fillRect(o, o, c, s - o),
                this.context.fillRect(o, r - o - c, s - o, c),
                this.context.fillRect(o, r - s, c, s - o),
                this.context.fillRect(i - s, o, s - o, c),
                this.context.fillRect(i - o - c, o, c, s - o),
                this.context.fillRect(i - s, r - o - c, s - o, c),
                this.context.fillRect(i - o - c, r - s, c, s - o)),
                a > 0 && (this.context.fillStyle = "#fff",
                this.context.font = "bold " + a + 'px "Roboto Mono", monospace',
                this.context.textAlign = "center",
                this.context.textBaseline = "middle",
                this.context.fillText(this.buttonText, i / 2, r / 2)),
                this.texture.needsUpdate = !0,
                this.isHover = !1
            }
        }]),
        e
    }()
      , zh = function() {
        function e(n, i, r) {
            t(this, e);
            var a = new $t(.15,.07)
              , o = new je({
                color: 0,
                transparent: !0,
                opacity: 0
            });
            this.mesh = new Rt(a,o),
            this.mesh.name = i,
            this.mesh.position.set(r.x, r.y, r.z),
            n.add(this.mesh)
        }
        return i(e, [{
            key: "destroy",
            value: function() {
                null !== this.mesh && (this.mesh.parent && this.mesh.parent.remove(this.mesh),
                this.mesh.geometry.dispose(),
                this.mesh.material.dispose()),
                delete this.mesh
            }
        }]),
        e
    }()
      , Bh = function() {
        function e(n, i, r, a, o) {
            t(this, e),
            this.element = n || document.body,
            this.callbackDown = i || function() {}
            ,
            this.callbackMove = r || function() {}
            ,
            this.callbackUp = a || function() {}
            ,
            this.callbackLeave = o || function() {}
            ,
            this.active = !1,
            this.offset = {
                x: 0,
                y: 0
            },
            this.origin = {
                x: 0,
                y: 0
            },
            this.point = {
                x: 0,
                y: 0
            },
            this.mouseDown = this.mouseDown.bind(this),
            this.mouseMove = this.mouseMove.bind(this),
            this.mouseUp = this.mouseUp.bind(this),
            this.mouseLeave = this.mouseLeave.bind(this),
            this.touchDown = this.touchDown.bind(this),
            this.touchMove = this.touchMove.bind(this),
            this.touchUp = this.touchUp.bind(this)
        }
        return i(e, [{
            key: "destroy",
            value: function() {
                this.disable(),
                delete this.element,
                delete this.callbackDown,
                delete this.callbackMove,
                delete this.callbackUp,
                delete this.active,
                delete this.offset,
                delete this.origin,
                delete this.point
            }
        }, {
            key: "enable",
            value: function() {
                this.element.addEventListener("mousedown", this.mouseDown),
                this.element.addEventListener("mousemove", this.mouseMove),
                this.element.addEventListener("mouseup", this.mouseUp),
                this.element.addEventListener("mouseleave", this.mouseLeave),
                this.element.addEventListener("touchstart", this.touchDown),
                this.element.addEventListener("touchmove", this.touchMove),
                this.element.addEventListener("touchend", this.touchUp),
                this.element.addEventListener("touchcancel", this.touchUp)
            }
        }, {
            key: "disable",
            value: function() {
                this.element.removeEventListener("mousedown", this.mouseDown),
                this.element.removeEventListener("mousemove", this.mouseMove),
                this.element.removeEventListener("mouseup", this.mouseUp),
                this.element.removeEventListener("mouseleave", this.mouseLeave),
                this.element.removeEventListener("touchstart", this.touchDown),
                this.element.removeEventListener("touchmove", this.touchMove),
                this.element.removeEventListener("touchend", this.touchUp),
                this.element.removeEventListener("touchcancel", this.touchUp)
            }
        }, {
            key: "mouseDown",
            value: function(e) {
                "A" === e.target.nodeName || "BUTTON" === e.target.nodeName ? this.active = !1 : (e.preventDefault(),
                this.active = !0,
                this.point.x = e.pageX - e.currentTarget.offsetLeft,
                this.point.y = e.pageY - e.currentTarget.offsetTop,
                this.origin.x = this.point.x,
                this.origin.y = this.point.y,
                this.updateOffset(),
                this.callbackDown({
                    active: this.active,
                    offset: this.offset,
                    origin: this.origin,
                    point: this.point,
                    type: "mouse"
                }))
            }
        }, {
            key: "mouseMove",
            value: function(e) {
                this.active && e.preventDefault(),
                this.point.x = e.pageX - e.currentTarget.offsetLeft,
                this.point.y = e.pageY - e.currentTarget.offsetTop,
                this.updateOffset(),
                this.callbackMove({
                    active: this.active,
                    offset: this.offset,
                    origin: this.origin,
                    point: this.point,
                    type: "mouse"
                })
            }
        }, {
            key: "mouseUp",
            value: function(e) {
                this.active && (e.preventDefault(),
                this.active = !1,
                this.updateOffset(),
                this.callbackUp({
                    active: this.active,
                    offset: this.offset,
                    origin: this.origin,
                    point: this.point,
                    type: "mouse"
                }))
            }
        }, {
            key: "mouseLeave",
            value: function() {
                this.active = !1,
                this.updateOffset(),
                this.callbackLeave({
                    active: this.active,
                    offset: this.offset,
                    origin: this.origin,
                    point: this.point,
                    type: "mouse"
                })
            }
        }, {
            key: "touchDown",
            value: function(e) {
                "A" === e.target.nodeName || "BUTTON" === e.target.nodeName ? this.active = !1 : 1 === e.touches.length ? (e.preventDefault(),
                this.active = !0,
                this.point.x = e.touches[0].pageX - e.currentTarget.offsetLeft,
                this.point.y = e.touches[0].pageY - e.currentTarget.offsetTop,
                this.origin.x = this.point.x,
                this.origin.y = this.point.y,
                this.updateOffset(),
                this.callbackDown({
                    active: this.active,
                    offset: this.offset,
                    origin: this.origin,
                    point: this.point,
                    type: "touch"
                })) : this.touchUp(e)
            }
        }, {
            key: "touchMove",
            value: function(e) {
                this.active && 1 === e.touches.length ? (e.preventDefault(),
                this.point.x = e.touches[0].pageX - e.currentTarget.offsetLeft,
                this.point.y = e.touches[0].pageY - e.currentTarget.offsetTop,
                this.updateOffset(),
                this.callbackMove({
                    active: this.active,
                    offset: this.offset,
                    origin: this.origin,
                    point: this.point,
                    type: "touch"
                })) : this.touchUp(e)
            }
        }, {
            key: "touchUp",
            value: function(e) {
                this.active && (e.preventDefault(),
                this.active = !1,
                this.updateOffset(),
                this.callbackUp({
                    active: this.active,
                    offset: this.offset,
                    origin: this.origin,
                    point: this.point,
                    type: "touch"
                }))
            }
        }, {
            key: "updateOffset",
            value: function() {
                this.offset.x = this.point.x - this.origin.x,
                this.offset.y = this.point.y - this.origin.y
            }
        }]),
        e
    }()
      , Fh = function() {
        function e(e) {
            ts.call(this, e),
            this.dracoLoader = null,
            this.ddsLoader = null
        }
        function t() {
            var e = {};
            return {
                get: function(t) {
                    return e[t]
                },
                add: function(t, n) {
                    e[t] = n
                },
                remove: function(t) {
                    delete e[t]
                },
                removeAll: function() {
                    e = {}
                }
            }
        }
        e.prototype = Object.assign(Object.create(ts.prototype), {
            constructor: e,
            load: function(e, t, n, i) {
                var r, a = this;
                r = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Zs(e),
                a.manager.itemStart(e);
                var o = function(t) {
                    i ? i(t) : console.error(t),
                    a.manager.itemError(e),
                    a.manager.itemEnd(e)
                }
                  , s = new is(a.manager);
                s.setPath(this.path),
                s.setResponseType("arraybuffer"),
                s.setRequestHeader(this.requestHeader),
                "use-credentials" === a.crossOrigin && s.setWithCredentials(!0),
                s.load(e, (function(n) {
                    try {
                        a.parse(n, r, (function(n) {
                            t(n),
                            a.manager.itemEnd(e)
                        }
                        ), o)
                    } catch (e) {
                        o(e)
                    }
                }
                ), n, o)
            },
            setDRACOLoader: function(e) {
                return this.dracoLoader = e,
                this
            },
            setDDSLoader: function(e) {
                return this.ddsLoader = e,
                this
            },
            parse: function(e, t, c, h) {
                var l, u = {};
                if ("string" == typeof e)
                    l = e;
                else if (Ys(new Uint8Array(e,0,4)) === s) {
                    try {
                        u[n.KHR_BINARY_GLTF] = new p(e)
                    } catch (e) {
                        return void (h && h(e))
                    }
                    l = u[n.KHR_BINARY_GLTF].content
                } else
                    l = Ys(new Uint8Array(e));
                var m = JSON.parse(l);
                if (void 0 === m.asset || m.asset.version[0] < 2)
                    h && h(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                else {
                    if (m.extensionsUsed)
                        for (var y = 0; y < m.extensionsUsed.length; ++y) {
                            var x = m.extensionsUsed[y]
                              , b = m.extensionsRequired || [];
                            switch (x) {
                            case n.KHR_LIGHTS_PUNCTUAL:
                                u[x] = new r(m);
                                break;
                            case n.KHR_MATERIALS_CLEARCOAT:
                                u[x] = new o;
                                break;
                            case n.KHR_MATERIALS_UNLIT:
                                u[x] = new a;
                                break;
                            case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                u[x] = new v;
                                break;
                            case n.KHR_DRACO_MESH_COMPRESSION:
                                u[x] = new d(m,this.dracoLoader);
                                break;
                            case n.MSFT_TEXTURE_DDS:
                                u[x] = new i(this.ddsLoader);
                                break;
                            case n.KHR_TEXTURE_TRANSFORM:
                                u[x] = new f;
                                break;
                            case n.KHR_MESH_QUANTIZATION:
                                u[x] = new g;
                                break;
                            default:
                                b.indexOf(x) >= 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + x + '".')
                            }
                        }
                    var _ = new j(m,u,{
                        path: t || this.resourcePath || "",
                        crossOrigin: this.crossOrigin,
                        manager: this.manager
                    });
                    _.fileLoader.setRequestHeader(this.requestHeader),
                    _.parse(c, h)
                }
            }
        });
        var n = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            MSFT_TEXTURE_DDS: "MSFT_texture_dds"
        };
        function i(e) {
            if (!e)
                throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader");
            this.name = n.MSFT_TEXTURE_DDS,
            this.ddsLoader = e
        }
        function r(e) {
            this.name = n.KHR_LIGHTS_PUNCTUAL;
            var t = e.extensions && e.extensions[n.KHR_LIGHTS_PUNCTUAL] || {};
            this.lightDefs = t.lights || []
        }
        function a() {
            this.name = n.KHR_MATERIALS_UNLIT
        }
        function o() {
            this.name = n.KHR_MATERIALS_CLEARCOAT
        }
        r.prototype.loadLight = function(e) {
            var t, n = this.lightDefs[e], i = new ze(16777215);
            void 0 !== n.color && i.fromArray(n.color);
            var r = void 0 !== n.range ? n.range : 0;
            switch (n.type) {
            case "directional":
                (t = new Gs(i)).target.position.set(0, 0, -1),
                t.add(t.target);
                break;
            case "point":
                (t = new Fs(i)).distance = r;
                break;
            case "spot":
                (t = new zs(i)).distance = r,
                n.spot = n.spot || {},
                n.spot.innerConeAngle = void 0 !== n.spot.innerConeAngle ? n.spot.innerConeAngle : 0,
                n.spot.outerConeAngle = void 0 !== n.spot.outerConeAngle ? n.spot.outerConeAngle : Math.PI / 4,
                t.angle = n.spot.outerConeAngle,
                t.penumbra = 1 - n.spot.innerConeAngle / n.spot.outerConeAngle,
                t.target.position.set(0, 0, -1),
                t.add(t.target);
                break;
            default:
                throw new Error('THREE.GLTFLoader: Unexpected light type, "' + n.type + '".')
            }
            return t.position.set(0, 0, 0),
            t.decay = 2,
            void 0 !== n.intensity && (t.intensity = n.intensity),
            t.name = n.name || "light_" + e,
            Promise.resolve(t)
        }
        ,
        a.prototype.getMaterialType = function() {
            return je
        }
        ,
        a.prototype.extendParams = function(e, t, n) {
            var i = [];
            e.color = new ze(1,1,1),
            e.opacity = 1;
            var r = t.pbrMetallicRoughness;
            if (r) {
                if (Array.isArray(r.baseColorFactor)) {
                    var a = r.baseColorFactor;
                    e.color.fromArray(a),
                    e.opacity = a[3]
                }
                void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture))
            }
            return Promise.all(i)
        }
        ,
        o.prototype.getMaterialType = function() {
            return Ro
        }
        ,
        o.prototype.extendParams = function(e, t, n) {
            var i = []
              , r = t.extensions[this.name];
            if (void 0 !== r.clearcoatFactor && (e.clearcoat = r.clearcoatFactor),
            void 0 !== r.clearcoatTexture && i.push(n.assignTexture(e, "clearcoatMap", r.clearcoatTexture)),
            void 0 !== r.clearcoatRoughnessFactor && (e.clearcoatRoughness = r.clearcoatRoughnessFactor),
            void 0 !== r.clearcoatRoughnessTexture && i.push(n.assignTexture(e, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)),
            void 0 !== r.clearcoatNormalTexture && (i.push(n.assignTexture(e, "clearcoatNormalMap", r.clearcoatNormalTexture)),
            void 0 !== r.clearcoatNormalTexture.scale)) {
                var a = r.clearcoatNormalTexture.scale;
                e.clearcoatNormalScale = new h(a,a)
            }
            return Promise.all(i)
        }
        ;
        var s = "glTF"
          , l = 1313821514
          , u = 5130562;
        function p(e) {
            this.name = n.KHR_BINARY_GLTF,
            this.content = null,
            this.body = null;
            var t = new DataView(e,0,12);
            if (this.header = {
                magic: Ys(new Uint8Array(e.slice(0, 4))),
                version: t.getUint32(4, !0),
                length: t.getUint32(8, !0)
            },
            this.header.magic !== s)
                throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2)
                throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            for (var i = new DataView(e,12), r = 0; r < i.byteLength; ) {
                var a = i.getUint32(r, !0);
                r += 4;
                var o = i.getUint32(r, !0);
                if (r += 4,
                o === l) {
                    var c = new Uint8Array(e,12 + r,a);
                    this.content = Ys(c)
                } else if (o === u) {
                    var h = 12 + r;
                    this.body = e.slice(h, h + a)
                }
                r += a
            }
            if (null === this.content)
                throw new Error("THREE.GLTFLoader: JSON content not found.")
        }
        function d(e, t) {
            if (!t)
                throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = n.KHR_DRACO_MESH_COMPRESSION,
            this.json = e,
            this.dracoLoader = t,
            this.dracoLoader.preload()
        }
        function f() {
            this.name = n.KHR_TEXTURE_TRANSFORM
        }
        function m(e) {
            Lo.call(this),
            this.isGLTFSpecularGlossinessMaterial = !0;
            var t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n")
              , n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n")
              , i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n")
              , r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n")
              , a = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb;", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor.rgb;"].join("\n")
              , o = {
                specular: {
                    value: (new ze).setHex(16777215)
                },
                glossiness: {
                    value: 1
                },
                specularMap: {
                    value: null
                },
                glossinessMap: {
                    value: null
                }
            };
            this._extraUniforms = o,
            this.onBeforeCompile = function(e) {
                for (var s in o)
                    e.uniforms[s] = o[s];
                e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;"),
                e.fragmentShader = e.fragmentShader.replace("uniform float metalness;", "uniform float glossiness;"),
                e.fragmentShader = e.fragmentShader.replace("#include <roughnessmap_pars_fragment>", t),
                e.fragmentShader = e.fragmentShader.replace("#include <metalnessmap_pars_fragment>", n),
                e.fragmentShader = e.fragmentShader.replace("#include <roughnessmap_fragment>", i),
                e.fragmentShader = e.fragmentShader.replace("#include <metalnessmap_fragment>", r),
                e.fragmentShader = e.fragmentShader.replace("#include <lights_physical_fragment>", a)
            }
            ,
            Object.defineProperties(this, {
                specular: {
                    get: function() {
                        return o.specular.value
                    },
                    set: function(e) {
                        o.specular.value = e
                    }
                },
                specularMap: {
                    get: function() {
                        return o.specularMap.value
                    },
                    set: function(e) {
                        o.specularMap.value = e
                    }
                },
                glossiness: {
                    get: function() {
                        return o.glossiness.value
                    },
                    set: function(e) {
                        o.glossiness.value = e
                    }
                },
                glossinessMap: {
                    get: function() {
                        return o.glossinessMap.value
                    },
                    set: function(e) {
                        o.glossinessMap.value = e,
                        e ? (this.defines.USE_GLOSSINESSMAP = "",
                        this.defines.USE_ROUGHNESSMAP = "") : (delete this.defines.USE_ROUGHNESSMAP,
                        delete this.defines.USE_GLOSSINESSMAP)
                    }
                }
            }),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this.setValues(e)
        }
        function v() {
            return {
                name: n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"],
                getMaterialType: function() {
                    return m
                },
                extendParams: function(e, t, n) {
                    var i = t.extensions[this.name];
                    e.color = new ze(1,1,1),
                    e.opacity = 1;
                    var r = [];
                    if (Array.isArray(i.diffuseFactor)) {
                        var a = i.diffuseFactor;
                        e.color.fromArray(a),
                        e.opacity = a[3]
                    }
                    if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(e, "map", i.diffuseTexture)),
                    e.emissive = new ze(0,0,0),
                    e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1,
                    e.specular = new ze(1,1,1),
                    Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor),
                    void 0 !== i.specularGlossinessTexture) {
                        var o = i.specularGlossinessTexture;
                        r.push(n.assignTexture(e, "glossinessMap", o)),
                        r.push(n.assignTexture(e, "specularMap", o))
                    }
                    return Promise.all(r)
                },
                createMaterial: function(e) {
                    var t = new m(e);
                    return t.fog = !0,
                    t.color = e.color,
                    t.map = void 0 === e.map ? null : e.map,
                    t.lightMap = null,
                    t.lightMapIntensity = 1,
                    t.aoMap = void 0 === e.aoMap ? null : e.aoMap,
                    t.aoMapIntensity = 1,
                    t.emissive = e.emissive,
                    t.emissiveIntensity = 1,
                    t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap,
                    t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap,
                    t.bumpScale = 1,
                    t.normalMap = void 0 === e.normalMap ? null : e.normalMap,
                    t.normalMapType = 0,
                    e.normalScale && (t.normalScale = e.normalScale),
                    t.displacementMap = null,
                    t.displacementScale = 1,
                    t.displacementBias = 0,
                    t.specularMap = void 0 === e.specularMap ? null : e.specularMap,
                    t.specular = e.specular,
                    t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap,
                    t.glossiness = e.glossiness,
                    t.alphaMap = null,
                    t.envMap = void 0 === e.envMap ? null : e.envMap,
                    t.envMapIntensity = 1,
                    t.refractionRatio = .98,
                    t
                }
            }
        }
        function g() {
            this.name = n.KHR_MESH_QUANTIZATION
        }
        function y(e, t, n, i) {
            Bo.call(this, e, t, n, i)
        }
        d.prototype.decodePrimitive = function(e, t) {
            var n = this.json
              , i = this.dracoLoader
              , r = e.extensions[this.name].bufferView
              , a = e.extensions[this.name].attributes
              , o = {}
              , s = {}
              , c = {};
            for (var h in a) {
                var l = O[h] || h.toLowerCase();
                o[l] = a[h]
            }
            for (h in e.attributes) {
                l = O[h] || h.toLowerCase();
                if (void 0 !== a[h]) {
                    var u = n.accessors[e.attributes[h]]
                      , p = A[u.componentType];
                    c[l] = p,
                    s[l] = !0 === u.normalized
                }
            }
            return t.getDependency("bufferView", r).then((function(e) {
                return new Promise((function(t) {
                    i.decodeDracoFile(e, (function(e) {
                        for (var n in e.attributes) {
                            var i = e.attributes[n]
                              , r = s[n];
                            void 0 !== r && (i.normalized = r)
                        }
                        t(e)
                    }
                    ), o, c)
                }
                ))
            }
            ))
        }
        ,
        f.prototype.extendTexture = function(e, t) {
            return e = e.clone(),
            void 0 !== t.offset && e.offset.fromArray(t.offset),
            void 0 !== t.rotation && (e.rotation = t.rotation),
            void 0 !== t.scale && e.repeat.fromArray(t.scale),
            void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
            e.needsUpdate = !0,
            e
        }
        ,
        m.prototype = Object.create(Lo.prototype),
        m.prototype.constructor = m,
        m.prototype.copy = function(e) {
            return Lo.prototype.copy.call(this, e),
            this.specularMap = e.specularMap,
            this.specular.copy(e.specular),
            this.glossinessMap = e.glossinessMap,
            this.glossiness = e.glossiness,
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this
        }
        ,
        y.prototype = Object.create(Bo.prototype),
        y.prototype.constructor = y,
        y.prototype.copySampleValue_ = function(e) {
            for (var t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i * 3 + i, a = 0; a !== i; a++)
                t[a] = n[r + a];
            return t
        }
        ,
        y.prototype.beforeStart_ = y.prototype.copySampleValue_,
        y.prototype.afterEnd_ = y.prototype.copySampleValue_,
        y.prototype.interpolate_ = function(e, t, n, i) {
            for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = 2 * o, c = 3 * o, h = i - t, l = (n - t) / h, u = l * l, p = u * l, d = e * c, f = d - c, m = -2 * p + 3 * u, v = p - u, g = 1 - m, y = v - u + l, x = 0; x !== o; x++) {
                var b = a[f + x + o]
                  , _ = a[f + x + s] * h
                  , w = a[d + x + o]
                  , M = a[d + x] * h;
                r[x] = g * b + y * _ + m * w + v * M
            }
            return r
        }
        ;
        var x = 0
          , _ = 1
          , w = 2
          , M = 3
          , S = 4
          , T = 5
          , E = 6
          , A = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }
          , R = {
            9728: 1003,
            9729: 1006,
            9984: 1004,
            9985: 1007,
            9986: 1005,
            9987: 1008
        }
          , P = {
            33071: 1001,
            33648: 1002,
            10497: 1e3
        }
          , C = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        }
          , O = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        }
          , I = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        }
          , D = {
            CUBICSPLINE: void 0,
            LINEAR: 2301,
            STEP: 2300
        }
          , N = "OPAQUE"
          , U = "MASK"
          , z = "BLEND"
          , B = {
            "image/png": 1023,
            "image/jpeg": 1022
        };
        function F(e, t) {
            return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
            /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
        }
        function H(e, t, n) {
            for (var i in n.extensions)
                void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {},
                t.userData.gltfExtensions[i] = n.extensions[i])
        }
        function k(e, t) {
            void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
        }
        function G(e, t) {
            if (e.updateMorphTargets(),
            void 0 !== t.weights)
                for (var n = 0, i = t.weights.length; n < i; n++)
                    e.morphTargetInfluences[n] = t.weights[n];
            if (t.extras && Array.isArray(t.extras.targetNames)) {
                var r = t.extras.targetNames;
                if (e.morphTargetInfluences.length === r.length) {
                    e.morphTargetDictionary = {};
                    for (n = 0,
                    i = r.length; n < i; n++)
                        e.morphTargetDictionary[r[n]] = n
                } else
                    console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }
        function V(e) {
            for (var t = "", n = Object.keys(e).sort(), i = 0, r = n.length; i < r; i++)
                t += n[i] + ":" + e[n[i]] + ";";
            return t
        }
        function j(e, n, i) {
            this.json = e || {},
            this.extensions = n || {},
            this.options = i || {},
            this.cache = new t,
            this.associations = new Map,
            this.primitiveCache = {},
            this.textureLoader = new hs(this.options.manager),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.fileLoader = new is(this.options.manager),
            this.fileLoader.setResponseType("arraybuffer"),
            "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
        }
        function W(e, t, n) {
            var i = t.attributes
              , r = [];
            function a(t, i) {
                return n.getDependency("accessor", t).then((function(t) {
                    e.setAttribute(i, t)
                }
                ))
            }
            for (var o in i) {
                var s = O[o] || o.toLowerCase();
                s in e.attributes || r.push(a(i[o], s))
            }
            if (void 0 !== t.indices && !e.index) {
                var c = n.getDependency("accessor", t.indices).then((function(t) {
                    e.setIndex(t)
                }
                ));
                r.push(c)
            }
            return k(e, t),
            function(e, t, n) {
                var i = t.attributes
                  , r = new se;
                if (void 0 !== i.POSITION) {
                    var a = (d = n.json.accessors[i.POSITION]).min
                      , o = d.max;
                    if (void 0 !== a && void 0 !== o) {
                        r.set(new b(a[0],a[1],a[2]), new b(o[0],o[1],o[2]));
                        var s = t.targets;
                        if (void 0 !== s) {
                            for (var c = new b, h = new b, l = 0, u = s.length; l < u; l++) {
                                var p = s[l];
                                if (void 0 !== p.POSITION) {
                                    var d;
                                    a = (d = n.json.accessors[p.POSITION]).min,
                                    o = d.max;
                                    void 0 !== a && void 0 !== o ? (h.setX(Math.max(Math.abs(a[0]), Math.abs(o[0]))),
                                    h.setY(Math.max(Math.abs(a[1]), Math.abs(o[1]))),
                                    h.setZ(Math.max(Math.abs(a[2]), Math.abs(o[2]))),
                                    c.max(h)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                }
                            }
                            r.expandByVector(c)
                        }
                        e.boundingBox = r;
                        var f = new le;
                        r.getCenter(f.center),
                        f.radius = r.min.distanceTo(r.max) / 2,
                        e.boundingSphere = f
                    } else
                        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                }
            }(e, t, n),
            Promise.all(r).then((function() {
                return void 0 !== t.targets ? function(e, t, n) {
                    for (var i = !1, r = !1, a = 0, o = t.length; a < o; a++) {
                        if (void 0 !== (h = t[a]).POSITION && (i = !0),
                        void 0 !== h.NORMAL && (r = !0),
                        i && r)
                            break
                    }
                    if (!i && !r)
                        return Promise.resolve(e);
                    var s = []
                      , c = [];
                    for (a = 0,
                    o = t.length; a < o; a++) {
                        var h = t[a];
                        if (i) {
                            var l = void 0 !== h.POSITION ? n.getDependency("accessor", h.POSITION) : e.attributes.position;
                            s.push(l)
                        }
                        if (r) {
                            l = void 0 !== h.NORMAL ? n.getDependency("accessor", h.NORMAL) : e.attributes.normal;
                            c.push(l)
                        }
                    }
                    return Promise.all([Promise.all(s), Promise.all(c)]).then((function(t) {
                        var n = t[0]
                          , a = t[1];
                        return i && (e.morphAttributes.position = n),
                        r && (e.morphAttributes.normal = a),
                        e.morphTargetsRelative = !0,
                        e
                    }
                    ))
                }(e, t.targets, n) : e
            }
            ))
        }
        function X(e, t) {
            var n = e.getIndex();
            if (null === n) {
                var i = []
                  , r = e.getAttribute("position");
                if (void 0 === r)
                    return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                    e;
                for (var a = 0; a < r.count; a++)
                    i.push(a);
                e.setIndex(i),
                n = e.getIndex()
            }
            var o = n.count - 2
              , s = [];
            if (2 === t)
                for (a = 1; a <= o; a++)
                    s.push(n.getX(0)),
                    s.push(n.getX(a)),
                    s.push(n.getX(a + 1));
            else
                for (a = 0; a < o; a++)
                    a % 2 == 0 ? (s.push(n.getX(a)),
                    s.push(n.getX(a + 1)),
                    s.push(n.getX(a + 2))) : (s.push(n.getX(a + 2)),
                    s.push(n.getX(a + 1)),
                    s.push(n.getX(a)));
            s.length / 3 !== o && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            var c = e.clone();
            return c.setIndex(s),
            c
        }
        return j.prototype.parse = function(e, t) {
            var n = this
              , i = this.json
              , r = this.extensions;
            this.cache.removeAll(),
            this.markDefs(),
            Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then((function(t) {
                var a = {
                    scene: t[0][i.scene || 0],
                    scenes: t[0],
                    animations: t[1],
                    cameras: t[2],
                    asset: i.asset,
                    parser: n,
                    userData: {}
                };
                H(r, a, i),
                k(a, i),
                e(a)
            }
            )).catch(t)
        }
        ,
        j.prototype.markDefs = function() {
            for (var e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [], i = {}, r = {}, a = 0, o = t.length; a < o; a++)
                for (var s = t[a].joints, c = 0, h = s.length; c < h; c++)
                    e[s[c]].isBone = !0;
            for (var l = 0, u = e.length; l < u; l++) {
                var p = e[l];
                void 0 !== p.mesh && (void 0 === i[p.mesh] && (i[p.mesh] = r[p.mesh] = 0),
                i[p.mesh]++,
                void 0 !== p.skin && (n[p.mesh].isSkinnedMesh = !0))
            }
            this.json.meshReferences = i,
            this.json.meshUses = r
        }
        ,
        j.prototype.getDependency = function(e, t) {
            var i = e + ":" + t
              , r = this.cache.get(i);
            if (!r) {
                switch (e) {
                case "scene":
                    r = this.loadScene(t);
                    break;
                case "node":
                    r = this.loadNode(t);
                    break;
                case "mesh":
                    r = this.loadMesh(t);
                    break;
                case "accessor":
                    r = this.loadAccessor(t);
                    break;
                case "bufferView":
                    r = this.loadBufferView(t);
                    break;
                case "buffer":
                    r = this.loadBuffer(t);
                    break;
                case "material":
                    r = this.loadMaterial(t);
                    break;
                case "texture":
                    r = this.loadTexture(t);
                    break;
                case "skin":
                    r = this.loadSkin(t);
                    break;
                case "animation":
                    r = this.loadAnimation(t);
                    break;
                case "camera":
                    r = this.loadCamera(t);
                    break;
                case "light":
                    r = this.extensions[n.KHR_LIGHTS_PUNCTUAL].loadLight(t);
                    break;
                default:
                    throw new Error("Unknown type: " + e)
                }
                this.cache.add(i, r)
            }
            return r
        }
        ,
        j.prototype.getDependencies = function(e) {
            var t = this.cache.get(e);
            if (!t) {
                var n = this
                  , i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                t = Promise.all(i.map((function(t, i) {
                    return n.getDependency(e, i)
                }
                ))),
                this.cache.add(e, t)
            }
            return t
        }
        ,
        j.prototype.loadBuffer = function(e) {
            var t = this.json.buffers[e]
              , i = this.fileLoader;
            if (t.type && "arraybuffer" !== t.type)
                throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
            if (void 0 === t.uri && 0 === e)
                return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);
            var r = this.options;
            return new Promise((function(e, n) {
                i.load(F(t.uri, r.path), e, void 0, (function() {
                    n(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                }
                ))
            }
            ))
        }
        ,
        j.prototype.loadBufferView = function(e) {
            var t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then((function(e) {
                var n = t.byteLength || 0
                  , i = t.byteOffset || 0;
                return e.slice(i, i + n)
            }
            ))
        }
        ,
        j.prototype.loadAccessor = function(e) {
            var t = this
              , n = this.json
              , i = this.json.accessors[e];
            if (void 0 === i.bufferView && void 0 === i.sparse)
                return Promise.resolve(null);
            var r = [];
            return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null),
            void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
            r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
            Promise.all(r).then((function(e) {
                var r, a = e[0], o = C[i.type], s = A[i.componentType], c = s.BYTES_PER_ELEMENT, h = c * o, l = i.byteOffset || 0, u = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0, p = !0 === i.normalized;
                if (u && u !== h) {
                    var d = Math.floor(l / u)
                      , f = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + d + ":" + i.count
                      , m = t.cache.get(f);
                    m || (m = new rr(new s(a,d * u,i.count * u / c),u / c),
                    t.cache.add(f, m)),
                    r = new sr(m,o,l % u / c,p)
                } else
                    r = new qe(null === a ? new s(i.count * o) : new s(a,l,i.count * o),o,p);
                if (void 0 !== i.sparse) {
                    var v = C.SCALAR
                      , g = A[i.sparse.indices.componentType]
                      , y = i.sparse.indices.byteOffset || 0
                      , x = i.sparse.values.byteOffset || 0
                      , b = new g(e[1],y,i.sparse.count * v)
                      , _ = new s(e[2],x,i.sparse.count * o);
                    null !== a && (r = new qe(r.array.slice(),r.itemSize,r.normalized));
                    for (var w = 0, M = b.length; w < M; w++) {
                        var S = b[w];
                        if (r.setX(S, _[w * o]),
                        o >= 2 && r.setY(S, _[w * o + 1]),
                        o >= 3 && r.setZ(S, _[w * o + 2]),
                        o >= 4 && r.setW(S, _[w * o + 3]),
                        o >= 5)
                            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                    }
                }
                return r
            }
            ))
        }
        ,
        j.prototype.loadTexture = function(e) {
            var t, i = this, r = this.json, a = this.options, o = this.textureLoader, s = self.URL || self.webkitURL, c = r.textures[e], h = c.extensions || {}, l = (t = h[n.MSFT_TEXTURE_DDS] ? r.images[h[n.MSFT_TEXTURE_DDS].source] : r.images[c.source]).uri, u = !1;
            return void 0 !== t.bufferView && (l = i.getDependency("bufferView", t.bufferView).then((function(e) {
                u = !0;
                var n = new Blob([e],{
                    type: t.mimeType
                });
                return l = s.createObjectURL(n)
            }
            ))),
            Promise.resolve(l).then((function(e) {
                var t = a.manager.getHandler(e);
                return t || (t = h[n.MSFT_TEXTURE_DDS] ? i.extensions[n.MSFT_TEXTURE_DDS].ddsLoader : o),
                new Promise((function(n, i) {
                    t.load(F(e, a.path), n, void 0, i)
                }
                ))
            }
            )).then((function(n) {
                !0 === u && s.revokeObjectURL(l),
                n.flipY = !1,
                c.name && (n.name = c.name),
                t.mimeType in B && (n.format = B[t.mimeType]);
                var a = (r.samplers || {})[c.sampler] || {};
                return n.magFilter = R[a.magFilter] || 1006,
                n.minFilter = R[a.minFilter] || 1008,
                n.wrapS = P[a.wrapS] || 1e3,
                n.wrapT = P[a.wrapT] || 1e3,
                i.associations.set(n, {
                    type: "textures",
                    index: e
                }),
                n
            }
            ))
        }
        ,
        j.prototype.assignTexture = function(e, t, i) {
            var r = this;
            return this.getDependency("texture", i.index).then((function(a) {
                if (!a.isCompressedTexture)
                    switch (t) {
                    case "aoMap":
                    case "emissiveMap":
                    case "metalnessMap":
                    case "normalMap":
                    case "roughnessMap":
                        a.format = 1022
                    }
                if (void 0 === i.texCoord || 0 == i.texCoord || "aoMap" === t && 1 == i.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + t + " not yet supported."),
                r.extensions[n.KHR_TEXTURE_TRANSFORM]) {
                    var o = void 0 !== i.extensions ? i.extensions[n.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (o) {
                        var s = r.associations.get(a);
                        a = r.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(a, o),
                        r.associations.set(a, s)
                    }
                }
                e[t] = a
            }
            ))
        }
        ,
        j.prototype.assignFinalMaterial = function(e) {
            var t = e.geometry
              , n = e.material
              , i = void 0 !== t.attributes.tangent
              , r = void 0 !== t.attributes.color
              , a = void 0 === t.attributes.normal
              , o = !0 === e.isSkinnedMesh
              , s = Object.keys(t.morphAttributes).length > 0
              , c = s && void 0 !== t.morphAttributes.normal;
            if (e.isPoints) {
                var h = "PointsMaterial:" + n.uuid
                  , l = this.cache.get(h);
                l || (l = new Qr,
                Ve.prototype.copy.call(l, n),
                l.color.copy(n.color),
                l.map = n.map,
                l.sizeAttenuation = !1,
                this.cache.add(h, l)),
                n = l
            } else if (e.isLine) {
                h = "LineBasicMaterial:" + n.uuid;
                var u = this.cache.get(h);
                u || (u = new kr,
                Ve.prototype.copy.call(u, n),
                u.color.copy(n.color),
                this.cache.add(h, u)),
                n = u
            }
            if (i || r || a || o || s) {
                h = "ClonedMaterial:" + n.uuid + ":";
                n.isGLTFSpecularGlossinessMaterial && (h += "specular-glossiness:"),
                o && (h += "skinning:"),
                i && (h += "vertex-tangents:"),
                r && (h += "vertex-colors:"),
                a && (h += "flat-shading:"),
                s && (h += "morph-targets:"),
                c && (h += "morph-normals:");
                var p = this.cache.get(h);
                p || (p = n.clone(),
                o && (p.skinning = !0),
                i && (p.vertexTangents = !0),
                r && (p.vertexColors = !0),
                a && (p.flatShading = !0),
                s && (p.morphTargets = !0),
                c && (p.morphNormals = !0),
                this.cache.add(h, p),
                this.associations.set(p, this.associations.get(n))),
                n = p
            }
            n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv),
            n.normalScale && !i && (n.normalScale.y = -n.normalScale.y),
            n.clearcoatNormalScale && !i && (n.clearcoatNormalScale.y = -n.clearcoatNormalScale.y),
            e.material = n
        }
        ,
        j.prototype.loadMaterial = function(e) {
            var t, i = this, r = this.json, a = this.extensions, o = r.materials[e], s = {}, c = o.extensions || {}, l = [];
            if (c[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                var u = a[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                t = u.getMaterialType(),
                l.push(u.extendParams(s, o, i))
            } else if (c[n.KHR_MATERIALS_UNLIT]) {
                var p = a[n.KHR_MATERIALS_UNLIT];
                t = p.getMaterialType(),
                l.push(p.extendParams(s, o, i))
            } else {
                t = Lo;
                var d = o.pbrMetallicRoughness || {};
                if (s.color = new ze(1,1,1),
                s.opacity = 1,
                Array.isArray(d.baseColorFactor)) {
                    var f = d.baseColorFactor;
                    s.color.fromArray(f),
                    s.opacity = f[3]
                }
                void 0 !== d.baseColorTexture && l.push(i.assignTexture(s, "map", d.baseColorTexture)),
                s.metalness = void 0 !== d.metallicFactor ? d.metallicFactor : 1,
                s.roughness = void 0 !== d.roughnessFactor ? d.roughnessFactor : 1,
                void 0 !== d.metallicRoughnessTexture && (l.push(i.assignTexture(s, "metalnessMap", d.metallicRoughnessTexture)),
                l.push(i.assignTexture(s, "roughnessMap", d.metallicRoughnessTexture)))
            }
            !0 === o.doubleSided && (s.side = 2);
            var v = o.alphaMode || N;
            if (v === z ? (s.transparent = !0,
            s.depthWrite = !1) : (s.transparent = !1,
            v === U && (s.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : .5)),
            void 0 !== o.normalTexture && t !== je && (l.push(i.assignTexture(s, "normalMap", o.normalTexture)),
            s.normalScale = new h(1,1),
            void 0 !== o.normalTexture.scale && s.normalScale.set(o.normalTexture.scale, o.normalTexture.scale)),
            void 0 !== o.occlusionTexture && t !== je && (l.push(i.assignTexture(s, "aoMap", o.occlusionTexture)),
            void 0 !== o.occlusionTexture.strength && (s.aoMapIntensity = o.occlusionTexture.strength)),
            void 0 !== o.emissiveFactor && t !== je && (s.emissive = (new ze).fromArray(o.emissiveFactor)),
            void 0 !== o.emissiveTexture && t !== je && l.push(i.assignTexture(s, "emissiveMap", o.emissiveTexture)),
            c[n.KHR_MATERIALS_CLEARCOAT]) {
                var g = a[n.KHR_MATERIALS_CLEARCOAT];
                t = g.getMaterialType(),
                l.push(g.extendParams(s, {
                    extensions: c
                }, i))
            }
            return Promise.all(l).then((function() {
                var r;
                return r = t === m ? a[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s) : new t(s),
                o.name && (r.name = o.name),
                r.map && (r.map.encoding = 3001),
                r.emissiveMap && (r.emissiveMap.encoding = 3001),
                k(r, o),
                i.associations.set(r, {
                    type: "materials",
                    index: e
                }),
                o.extensions && H(a, r, o),
                r
            }
            ))
        }
        ,
        j.prototype.loadGeometries = function(e) {
            var t = this
              , i = this.extensions
              , r = this.primitiveCache;
            function a(e) {
                return i[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                    return W(n, e, t)
                }
                ))
            }
            for (var o, s, c = [], h = 0, l = e.length; h < l; h++) {
                var u, p = e[h], d = (s = void 0,
                (s = (o = p).extensions && o.extensions[n.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + s.bufferView + ":" + s.indices + ":" + V(s.attributes) : o.indices + ":" + V(o.attributes) + ":" + o.mode), f = r[d];
                if (f)
                    c.push(f.promise);
                else
                    u = p.extensions && p.extensions[n.KHR_DRACO_MESH_COMPRESSION] ? a(p) : W(new ut, p, t),
                    r[d] = {
                        primitive: p,
                        promise: u
                    },
                    c.push(u)
            }
            return Promise.all(c)
        }
        ,
        j.prototype.loadMesh = function(e) {
            for (var t, n = this, i = this.json.meshes[e], r = i.primitives, a = [], o = 0, s = r.length; o < s; o++) {
                var c = void 0 === r[o].material ? (void 0 === (t = this.cache).DefaultMaterial && (t.DefaultMaterial = new Lo({
                    color: 16777215,
                    emissive: 0,
                    metalness: 1,
                    roughness: 1,
                    transparent: !1,
                    depthTest: !0,
                    side: 0
                })),
                t.DefaultMaterial) : this.getDependency("material", r[o].material);
                a.push(c)
            }
            return a.push(n.loadGeometries(r)),
            Promise.all(a).then((function(t) {
                for (var a = t.slice(0, t.length - 1), o = t[t.length - 1], s = [], c = 0, h = o.length; c < h; c++) {
                    var l, u = o[c], p = r[c], d = a[c];
                    if (p.mode === S || p.mode === T || p.mode === E || void 0 === p.mode)
                        !0 !== (l = !0 === i.isSkinnedMesh ? new Cr(u,d) : new Rt(u,d)).isSkinnedMesh || l.geometry.attributes.skinWeight.normalized || l.normalizeSkinWeights(),
                        p.mode === T ? l.geometry = X(l.geometry, 1) : p.mode === E && (l.geometry = X(l.geometry, 2));
                    else if (p.mode === _)
                        l = new Jr(u,d);
                    else if (p.mode === M)
                        l = new Xr(u,d);
                    else if (p.mode === w)
                        l = new Kr(u,d);
                    else {
                        if (p.mode !== x)
                            throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
                        l = new ia(u,d)
                    }
                    Object.keys(l.geometry.morphAttributes).length > 0 && G(l, i),
                    l.name = i.name || "mesh_" + e,
                    o.length > 1 && (l.name += "_" + c),
                    k(l, i),
                    n.assignFinalMaterial(l),
                    s.push(l)
                }
                if (1 === s.length)
                    return s[0];
                var f = new Ki;
                for (c = 0,
                h = s.length; c < h; c++)
                    f.add(s[c]);
                return f
            }
            ))
        }
        ,
        j.prototype.loadCamera = function(e) {
            var t, n = this.json.cameras[e], i = n[n.type];
            if (i)
                return "perspective" === n.type ? t = new Vt(c.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : "orthographic" === n.type && (t = new Hs(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
                n.name && (t.name = n.name),
                k(t, n),
                Promise.resolve(t);
            console.warn("THREE.GLTFLoader: Missing camera parameters.")
        }
        ,
        j.prototype.loadSkin = function(e) {
            var t = this.json.skins[e]
              , n = {
                joints: t.joints
            };
            return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function(e) {
                return n.inverseBindMatrices = e,
                n
            }
            ))
        }
        ,
        j.prototype.loadAnimation = function(e) {
            for (var t = this.json.animations[e], n = [], i = [], r = [], a = [], o = [], s = 0, c = t.channels.length; s < c; s++) {
                var h = t.channels[s]
                  , l = t.samplers[h.sampler]
                  , u = h.target
                  , p = void 0 !== u.node ? u.node : u.id
                  , d = void 0 !== t.parameters ? t.parameters[l.input] : l.input
                  , f = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
                n.push(this.getDependency("node", p)),
                i.push(this.getDependency("accessor", d)),
                r.push(this.getDependency("accessor", f)),
                a.push(l),
                o.push(u)
            }
            return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(a), Promise.all(o)]).then((function(n) {
                for (var i = n[0], r = n[1], a = n[2], o = n[3], s = n[4], c = [], h = 0, l = i.length; h < l; h++) {
                    var u = i[h]
                      , p = r[h]
                      , d = a[h]
                      , f = o[h]
                      , m = s[h];
                    if (void 0 !== u) {
                        var v;
                        switch (u.updateMatrix(),
                        u.matrixAutoUpdate = !0,
                        I[m.path]) {
                        case I.weights:
                            v = Wo;
                            break;
                        case I.rotation:
                            v = Xo;
                            break;
                        case I.position:
                        case I.scale:
                        default:
                            v = Zo
                        }
                        var g = u.name ? u.name : u.uuid
                          , x = void 0 !== f.interpolation ? D[f.interpolation] : 2301
                          , b = [];
                        I[m.path] === I.weights ? u.traverse((function(e) {
                            !0 === e.isMesh && e.morphTargetInfluences && b.push(e.name ? e.name : e.uuid)
                        }
                        )) : b.push(g);
                        var _ = d.array;
                        if (d.normalized) {
                            var w;
                            if (_.constructor === Int8Array)
                                w = 1 / 127;
                            else if (_.constructor === Uint8Array)
                                w = 1 / 255;
                            else if (_.constructor == Int16Array)
                                w = 1 / 32767;
                            else {
                                if (_.constructor !== Uint16Array)
                                    throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
                                w = 1 / 65535
                            }
                            for (var M = new Float32Array(_.length), S = 0, T = _.length; S < T; S++)
                                M[S] = _[S] * w;
                            _ = M
                        }
                        for (S = 0,
                        T = b.length; S < T; S++) {
                            var E = new v(b[S] + "." + I[m.path],p.array,_,x);
                            "CUBICSPLINE" === f.interpolation && (E.createInterpolant = function(e) {
                                return new y(this.times,this.values,this.getValueSize() / 3,e)
                            }
                            ,
                            E.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                            c.push(E)
                        }
                    }
                }
                return new Jo(t.name ? t.name : "animation_" + e,void 0,c)
            }
            ))
        }
        ,
        j.prototype.loadNode = function(e) {
            var t, i = this.json, r = this.extensions, a = this, o = i.meshReferences, s = i.meshUses, c = i.nodes[e];
            return (t = [],
            void 0 !== c.mesh && t.push(a.getDependency("mesh", c.mesh).then((function(e) {
                var t;
                if (o[c.mesh] > 1) {
                    var n = s[c.mesh]++;
                    (t = e.clone()).name += "_instance_" + n
                } else
                    t = e;
                return void 0 !== c.weights && t.traverse((function(e) {
                    if (e.isMesh)
                        for (var t = 0, n = c.weights.length; t < n; t++)
                            e.morphTargetInfluences[t] = c.weights[t]
                }
                )),
                t
            }
            ))),
            void 0 !== c.camera && t.push(a.getDependency("camera", c.camera)),
            c.extensions && c.extensions[n.KHR_LIGHTS_PUNCTUAL] && void 0 !== c.extensions[n.KHR_LIGHTS_PUNCTUAL].light && t.push(a.getDependency("light", c.extensions[n.KHR_LIGHTS_PUNCTUAL].light)),
            Promise.all(t)).then((function(t) {
                var n;
                if ((n = !0 === c.isBone ? new Nr : t.length > 1 ? new Ki : 1 === t.length ? t[0] : new q) !== t[0])
                    for (var i = 0, o = t.length; i < o; i++)
                        n.add(t[i]);
                if (c.name && (n.userData.name = c.name,
                n.name = Fc.sanitizeNodeName(c.name)),
                k(n, c),
                c.extensions && H(r, n, c),
                void 0 !== c.matrix) {
                    var s = new L;
                    s.fromArray(c.matrix),
                    n.applyMatrix4(s)
                } else
                    void 0 !== c.translation && n.position.fromArray(c.translation),
                    void 0 !== c.rotation && n.quaternion.fromArray(c.rotation),
                    void 0 !== c.scale && n.scale.fromArray(c.scale);
                return a.associations.set(n, {
                    type: "nodes",
                    index: e
                }),
                n
            }
            ))
        }
        ,
        j.prototype.loadScene = function() {
            function e(t, n, i, r) {
                var a = i.nodes[t];
                return r.getDependency("node", t).then((function(e) {
                    return void 0 === a.skin ? e : r.getDependency("skin", a.skin).then((function(e) {
                        for (var n = [], i = 0, a = (t = e).joints.length; i < a; i++)
                            n.push(r.getDependency("node", t.joints[i]));
                        return Promise.all(n)
                    }
                    )).then((function(n) {
                        return e.traverse((function(e) {
                            if (e.isMesh) {
                                for (var i = [], r = [], a = 0, o = n.length; a < o; a++) {
                                    var s = n[a];
                                    if (s) {
                                        i.push(s);
                                        var c = new L;
                                        void 0 !== t.inverseBindMatrices && c.fromArray(t.inverseBindMatrices.array, 16 * a),
                                        r.push(c)
                                    } else
                                        console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[a])
                                }
                                e.bind(new Dr(i,r), e.matrixWorld)
                            }
                        }
                        )),
                        e
                    }
                    ));
                    var t
                }
                )).then((function(t) {
                    n.add(t);
                    var o = [];
                    if (a.children)
                        for (var s = a.children, c = 0, h = s.length; c < h; c++) {
                            var l = s[c];
                            o.push(e(l, t, i, r))
                        }
                    return Promise.all(o)
                }
                ))
            }
            return function(t) {
                var n = this.json
                  , i = this.extensions
                  , r = this.json.scenes[t]
                  , a = new Ki;
                r.name && (a.name = r.name),
                k(a, r),
                r.extensions && H(i, a, r);
                for (var o = r.nodes || [], s = [], c = 0, h = o.length; c < h; c++)
                    s.push(e(o[c], a, n, this));
                return Promise.all(s).then((function() {
                    return a
                }
                ))
            }
        }(),
        e
    }()
      , Hh = function() {
        function e(n, i) {
            t(this, e),
            this.blinkComplete = this.blinkComplete.bind(this),
            this.eyebrowFlashComplete = this.eyebrowFlashComplete.bind(this),
            this.fileLoaded = this.fileLoaded.bind(this),
            this.callback = i,
            this.loader = new Fh,
            this.mesh = null,
            this.stateBlink = !1,
            this.stateBlinkTimer = 0,
            this.stateEyebrowFlash = !1,
            this.stateEyebrowFlashTimer = 0,
            this.stateLookX = 0,
            this.stateLookY = 0,
            this.stateMouthIsOpen = !1,
            this.stateSmile = 0,
            this.loader.load(n, this.fileLoaded)
        }
        return i(e, [{
            key: "fileLoaded",
            value: function(e) {
                this.mesh = e.scene.children[0],
                this.callback()
            }
        }, {
            key: "destroy",
            value: function() {
                null !== this.mesh && (this.mesh.parent && this.mesh.parent.remove(this.mesh),
                this.mesh.geometry.dispose(),
                this.mesh.material.dispose()),
                delete this.callback,
                delete this.loader,
                delete this.mesh,
                delete this.stateBlink,
                delete this.stateBlinkTimer,
                delete this.stateEyebrowFlash,
                delete this.stateEyebrowFlashTimer,
                delete this.stateLookX,
                delete this.stateLookY,
                delete this.stateMouthIsOpen,
                delete this.stateSmile
            }
        }, {
            key: "addTo",
            value: function(e) {
                null !== this.mesh && e.add(this.mesh)
            }
        }, {
            key: "removeFrom",
            value: function(e) {
                null !== this.mesh && e.remove(this.mesh)
            }
        }, {
            key: "update",
            value: function() {
                if (null !== this.mesh) {
                    var e, t;
                    e = this.mesh.morphTargetDictionary.Blink,
                    t = this.stateBlink ? 1 : 0,
                    this.mesh.morphTargetInfluences[e] += .5 * (t - this.mesh.morphTargetInfluences[e]),
                    e = this.mesh.morphTargetDictionary.Eyebrows,
                    t = this.stateEyebrowFlash ? 1 : 0,
                    t = this.stateBlink ? 0 : t,
                    this.mesh.morphTargetInfluences[e] += .5 * (t - this.mesh.morphTargetInfluences[e]),
                    e = this.mesh.morphTargetDictionary["Look Left"],
                    t = this.stateLookX > 0 ? this.stateLookX : 0,
                    t = this.stateBlink ? 0 : t,
                    this.mesh.morphTargetInfluences[e] += .5 * (t - this.mesh.morphTargetInfluences[e]),
                    e = this.mesh.morphTargetDictionary["Look Right"],
                    t = this.stateLookX < 0 ? Math.abs(this.stateLookX) : 0,
                    t = this.stateBlink ? 0 : t,
                    this.mesh.morphTargetInfluences[e] += .5 * (t - this.mesh.morphTargetInfluences[e]),
                    e = this.mesh.morphTargetDictionary["Look Up"],
                    t = this.stateLookY < 0 ? Math.abs(this.stateLookY) : 0,
                    t = this.stateBlink ? 0 : t,
                    this.mesh.morphTargetInfluences[e] += .5 * (t - this.mesh.morphTargetInfluences[e]),
                    e = this.mesh.morphTargetDictionary["Look Down"],
                    t = this.stateLookY > 0 ? this.stateLookY : 0,
                    t = this.stateBlink ? 0 : t,
                    this.mesh.morphTargetInfluences[e] += .5 * (t - this.mesh.morphTargetInfluences[e]),
                    e = this.mesh.morphTargetDictionary["Open Mouth"],
                    t = this.stateMouthIsOpen ? 1 : 0,
                    this.mesh.morphTargetInfluences[e] += .5 * (t - this.mesh.morphTargetInfluences[e]),
                    e = this.mesh.morphTargetDictionary.Smile,
                    t = this.stateSmile,
                    this.mesh.morphTargetInfluences[e] += .5 * (t - this.mesh.morphTargetInfluences[e])
                }
            }
        }, {
            key: "blink",
            value: function() {
                clearTimeout(this.stateBlinkTimer),
                this.stateBlink = !0,
                this.stateBlinkTimer = setTimeout(this.blinkComplete, 100)
            }
        }, {
            key: "eyebrowFlash",
            value: function() {
                clearTimeout(this.stateEyebrowFlashTimer),
                this.stateEyebrowFlash = !0,
                this.stateEyebrowFlashTimer = setTimeout(this.eyebrowFlashComplete, 100)
            }
        }, {
            key: "look",
            value: function(e, t) {
                this.stateLookX = e,
                this.stateLookY = t
            }
        }, {
            key: "mouthClose",
            value: function() {
                this.stateMouthIsOpen = !1
            }
        }, {
            key: "mouthOpen",
            value: function() {
                this.stateMouthIsOpen = !0
            }
        }, {
            key: "smile",
            value: function(e) {
                this.stateSmile = e
            }
        }, {
            key: "blinkComplete",
            value: function() {
                clearTimeout(this.stateBlinkTimer),
                this.stateBlink = !1
            }
        }, {
            key: "eyebrowFlashComplete",
            value: function() {
                clearTimeout(this.stateEyebrowFlashTimer),
                this.stateEyebrowFlash = !1
            }
        }]),
        e
    }()
      , kh = ["Samantha", "Nicky", "Victoria", "Martha", "Karen", "Moira", "Microsoft Zira Desktop - English (United States)", "Microsoft Zira - English (United States)", "English United States", "Google US English"]
      , Gh = ["Aaron", "Alex", "Fred", "Daniel", "Microsoft David Desktop - English (United States)", "Microsoft David - English (United States)", "Microsoft Mark - English (United States)", "English United States", "Google US English"]
      , Vh = function() {
        function e(n, i, r, a) {
            t(this, e),
            this.preferredVoice = n ? Gh : kh,
            this.onBoundary = this.onBoundary.bind(this),
            this.onEnd = this.onEnd.bind(this),
            this.onError = this.onError.bind(this),
            this.onLeave = this.onLeave.bind(this),
            this.onStart = this.onStart.bind(this),
            this.mouthOpen = this.mouthOpen.bind(this),
            this.mouthClose = this.mouthClose.bind(this),
            this.setVoice = this.setVoice.bind(this),
            this.charDuration = 25,
            this.charIndex = 0,
            this.isSpeaking = !1,
            this.mouthIsOpen = !1,
            this.mouthTimer = 0,
            this.syllablesCurrent = 0,
            this.syllablesDuration = 0,
            this.syllablesTotal = 0,
            this.text = "",
            this.utter = new SpeechSynthesisUtterance,
            this.utterTimer = 0,
            this.voice = null,
            this.callbackComplete = a,
            this.callbackStart = i,
            this.callbackStop = r,
            this.utter.addEventListener("boundary", this.onBoundary),
            this.utter.addEventListener("end", this.onEnd),
            this.utter.addEventListener("error", this.onError),
            this.utter.addEventListener("start", this.onStart),
            window.addEventListener("beforeunload", this.onLeave),
            void 0 !== window.speechSynthesis.addEventListener && 0 == window.speechSynthesis.getVoices().length ? window.speechSynthesis.addEventListener("voiceschanged", this.setVoice) : this.setVoice()
        }
        return i(e, [{
            key: "destroy",
            value: function() {
                this.stop(),
                this.utter.removeEventListener("boundary", this.onBoundary),
                this.utter.removeEventListener("end", this.onEnd),
                this.utter.removeEventListener("error", this.onError),
                this.utter.removeEventListener("start", this.onStart),
                window.removeEventListener("beforeunload", this.onLeave),
                void 0 !== window.speechSynthesis.addEventListener && window.speechSynthesis.removeEventListener("voiceschanged", this.setVoice),
                delete this.callbackComplete,
                delete this.callbackStart,
                delete this.callbackStop,
                delete this.charDuration,
                delete this.charIndex,
                delete this.isSpeaking,
                delete this.mouthIsOpen,
                delete this.mouthTimer,
                delete this.preferredVoice,
                delete this.syllablesCurrent,
                delete this.syllablesDuration,
                delete this.syllablesTotal,
                delete this.text,
                delete this.utter,
                delete this.utterTimer,
                delete this.voice
            }
        }, {
            key: "getIsSpeaking",
            value: function() {
                return this.isSpeaking
            }
        }, {
            key: "say",
            value: function(e) {
                this.stop(),
                this.setVoice(),
                this.charIndex = 0,
                this.isSpeaking = !0,
                this.mouthIsOpen = !1,
                this.text = e,
                this.utter.lang = "en-US",
                this.utter.pitch = 1,
                this.utter.rate = 1,
                this.utter.text = e,
                this.utter.voice = this.voice,
                this.utter.volume = .1,
                this.callbackStart(),
                this.syllablesDuration = 4 * this.text.length * this.charDuration,
                this.utterTimer = setTimeout(this.onEnd, this.syllablesDuration),
                window.speechSynthesis.speak(this.utter)
            }
        }, {
            key: "stop",
            value: function() {
                clearTimeout(this.utterTimer),
                window.speechSynthesis.cancel(this.utter),
                this.isSpeaking = !1,
                this.syllablesCurrent = 0,
                this.syllablesDuration = 0,
                this.syllablesTotal = 0,
                this.mouthClose(),
                this.callbackStop()
            }
        }, {
            key: "countSyllables",
            value: function(e) {
                if ((e = e.toLowerCase()).length <= 3)
                    return 1;
                var t = (e = (e = e.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, "")).replace(/^y/, "")).match(/[aeiouy]{1,2}/g);
                return null === t ? 1 : t.length
            }
        }, {
            key: "getMouthIsOpen",
            value: function() {
                return this.mouthIsOpen
            }
        }, {
            key: "getCharacterIndex",
            value: function() {
                return this.charIndex
            }
        }, {
            key: "getWordIndex",
            value: function() {
                for (var e = this.getWords(), t = 0, n = 0, i = e.length; n < i; n++) {
                    if (t >= this.charIndex)
                        return n;
                    t += e[n].length + 1
                }
                return e.length - 1
            }
        }, {
            key: "getWord",
            value: function() {
                return this.getWords()[this.getWordIndex()]
            }
        }, {
            key: "getWords",
            value: function() {
                return this.text.split(" ")
            }
        }, {
            key: "onStart",
            value: function() {
                this.charIndex = 0,
                this.mouthIsOpen = !0
            }
        }, {
            key: "onBoundary",
            value: function(e) {
                this.charIndex = e.charIndex;
                var t = this.text.charAt(this.charIndex);
                -1 === [".", "!", "?", ",", ";", ":", "-", "”", "’", '"', "'", "]", "/", ")"].indexOf(t) && (this.syllablesCurrent = 0,
                this.syllablesTotal = 0,
                this.mouthOpen())
            }
        }, {
            key: "onEnd",
            value: function() {
                clearTimeout(this.utterTimer),
                this.charIndex = this.text.length - 1,
                this.isSpeaking = !1,
                this.mouthIsOpen = !1,
                this.callbackStop(),
                this.callbackComplete()
            }
        }, {
            key: "onError",
            value: function() {
                if (this.stop(),
                null !== this.voice) {
                    var e = this.preferredVoice.indexOf(this.voice.name);
                    -1 !== e && (this.preferredVoice.splice(e, 1),
                    this.voice = null)
                }
            }
        }, {
            key: "onLeave",
            value: function() {
                this.stop()
            }
        }, {
            key: "mouthOpen",
            value: function() {
                clearTimeout(this.mouthTimer);
                var e = this.getWords()[this.getWordIndex()]
                  , t = e.length;
                this.syllablesTotal = this.countSyllables(e),
                this.syllablesDuration = t * this.charDuration / this.syllablesTotal,
                this.syllablesCurrent += 1,
                this.mouthIsOpen = !0,
                this.mouthTimer = setTimeout(this.mouthClose, this.syllablesDuration)
            }
        }, {
            key: "mouthClose",
            value: function() {
                clearTimeout(this.mouthTimer),
                this.mouthIsOpen = !1,
                this.syllablesCurrent < this.syllablesTotal && (this.mouthTimer = setTimeout(this.mouthOpen, this.syllablesDuration))
            }
        }, {
            key: "setVoice",
            value: function() {
                if (null === this.voice) {
                    var e, t, n = window.speechSynthesis.getVoices();
                    if (n && n.length > 0) {
                        for (e = 0,
                        t = n.length; e < t; e++)
                            if (-1 !== this.preferredVoice.indexOf(n[e].name))
                                return void (this.voice = n[e]);
                        for (e = 0,
                        t = n.length; e < t; e++)
                            if ("en-US" === n[e].lang) {
                                this.voice = n[e];
                                break
                            }
                        null === this.voice && (this.voice = n[0])
                    }
                }
            }
        }]),
        e
    }();
    "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;
    var jh = function(e, t, n) {
        return e(n = {
            path: t,
            exports: {},
            require: function(e, t) {
                return function() {
                    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
                }(null == t && n.path)
            }
        }, n.exports),
        n.exports
    }((function(e, t) {
        var n;
        e.exports = ((n = function() {
            function e(e) {
                return r.appendChild(e.dom),
                e
            }
            function t(e) {
                for (var t = 0; t < r.children.length; t++)
                    r.children[t].style.display = t === e ? "block" : "none";
                i = e
            }
            var i = 0
              , r = document.createElement("div");
            r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",
            r.addEventListener("click", (function(e) {
                e.preventDefault(),
                t(++i % r.children.length)
            }
            ), !1);
            var a = (performance || Date).now()
              , o = a
              , s = 0
              , c = e(new n.Panel("FPS","#0ff","#002"))
              , h = e(new n.Panel("MS","#0f0","#020"));
            if (self.performance && self.performance.memory)
                var l = e(new n.Panel("MB","#f08","#201"));
            return t(0),
            {
                REVISION: 16,
                dom: r,
                addPanel: e,
                showPanel: t,
                begin: function() {
                    a = (performance || Date).now()
                },
                end: function() {
                    s++;
                    var e = (performance || Date).now();
                    if (h.update(e - a, 200),
                    e > o + 1e3 && (c.update(1e3 * s / (e - o), 100),
                    o = e,
                    s = 0,
                    l)) {
                        var t = performance.memory;
                        l.update(t.usedJSHeapSize / 1048576, t.jsHeapSizeLimit / 1048576)
                    }
                    return e
                },
                update: function() {
                    a = this.end()
                },
                domElement: r,
                setMode: t
            }
        }
        ).Panel = function(e, t, n) {
            var i = 1 / 0
              , r = 0
              , a = Math.round
              , o = a(window.devicePixelRatio || 1)
              , s = 80 * o
              , c = 48 * o
              , h = 3 * o
              , l = 2 * o
              , u = 3 * o
              , p = 15 * o
              , d = 74 * o
              , f = 30 * o
              , m = document.createElement("canvas");
            m.width = s,
            m.id = "canvas1",
            m.height = c,
            m.style.cssText = "width:80px;height:48px";
            var v = m.getContext("2d");
            return v.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif",
            v.textBaseline = "top",
            v.fillStyle = n,
            v.fillRect(0, 0, s, c),
            v.fillStyle = t,
            v.fillText(e, h, l),
            v.fillRect(u, p, d, f),
            v.fillStyle = n,
            v.globalAlpha = .9,
            v.fillRect(u, p, d, f),
            {
                dom: m,
                update: function(c, g) {
                    i = Math.min(i, c),
                    r = Math.max(r, c),
                    v.fillStyle = n,
                    v.globalAlpha = 1,
                    v.fillRect(0, 0, s, p),
                    v.fillStyle = t,
                    v.fillText(a(c) + " " + e + " (" + a(i) + "-" + a(r) + ")", h, l),
                    v.drawImage(m, u + o, p, d - o, f, u, p, d - o, f),
                    v.fillRect(u + d - o, p, o, f),
                    v.fillStyle = n,
                    v.globalAlpha = .9,
                    v.fillRect(u + d - o, p, o, a((1 - c / g) * f))
                }
            }
        }
        ,
        n)
    }
    ))
      , Wh = function() {
        function n(e) {
            t(this, n),
            this.data = JSON.parse(document.getElementById("data").innerHTML),
            this.queueAbout = [],
            this.queueTwitter = [],
            this.element = document.createElement("div"),
            this.element.className = "webgl-scene",
            this.element.idName = 'webcanvas';
            e.appendChild(this.element),
            this.camera = new Vt(45,window.innerWidth / window.innerHeight,.1,1e3),
            this.camera.position.set(0, 0, .6),
            this.renderer = new tr( { alpha: true } ),
            this.renderer.setClearColor( 0x000000, 0 ),
            this.renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1),
            this.renderer.setSize(window.innerWidth, window.innerHeight),
            this.element.appendChild(this.renderer.domElement),
            this.scene = new X;
            var i, r, a, o = new Vs(16777215,1);
            this.scene.add(o),
            this.stats = new jh,
            this.animationFrame = null,
            this.onAnimationFrame = this.onAnimationFrame.bind(this),
            this.cursorResetTimer = null,
            this.onCursorDown = this.onCursorDown.bind(this),
            this.onCursorMove = this.onCursorMove.bind(this),
            this.onCursorUp = this.onCursorUp.bind(this),
            this.onCursorLeave = this.onCursorLeave.bind(this),
            this.onCursorReset = this.onCursorReset.bind(this),
            this.onSpeechComplete = this.onSpeechComplete.bind(this),
            this.onSpeechStart = this.onSpeechStart.bind(this),
            this.onSpeechStop = this.onSpeechStop.bind(this),
            this.onRandomBlink = this.onRandomBlink.bind(this),
            this.cursor = new Bh(this.element,this.onCursorDown,this.onCursorMove,this.onCursorUp,this.onCursorLeave),
            this.mouse = new h,
            this.mouseDown = !1,
            this.mouseDownOn = [],
            this.mouseMoved = !1,
            this.mouseZero = new h,
            this.raycaster = new jc,
           // this.onBackgroundLoaded = this.onBackgroundLoaded.bind(this),
            this.onHeadLoaded = this.onHeadLoaded.bind(this),
            this.showEnterButton = this.showEnterButton.bind(this),
            this.beginIntroAnimation = this.beginIntroAnimation.bind(this),
            this.onWindowResize = this.onWindowResize.bind(this),
            this.onWindowResizeDebounce = (i = this.onWindowResize,
            r = 250,
            function() {
                var e = this
                  , t = arguments;
                clearTimeout(a),
                a = setTimeout((function() {
                    return i.apply(e, t)
                }
                ), r)
            }
            ),
            this.onVisibilityChange = this.onVisibilityChange.bind(this),
            this.headGroup = new Ki,
            this.headGroup.scale.set(.7, .7, .7),
            this.scene.add(this.headGroup),
            
            this.buttons = {
                ButtonLoading: new Uh(this.headGroup,"ButtonLoading","LOADING...",{
                    x: 0,
                    y: 0,
                    z: .2
                })
            },
            this.buttonEyes = null,
            this.headSmile = 0,
           // this.background = null,
            this.speech = new Vh(!0,this.onSpeechStart,this.onSpeechStop,this.onSpeechComplete),
            this.head = new Hh("assets/glb/will1.glb",this.onHeadLoaded),
            this.enable(),
            this.buttons.ButtonLoading.setLoading(!0),
             console.log(this.head)
            this.buttons.ButtonLoading.show()
        }
       
        return i(n, [{
            key: "enable",
            value: function() {
                this.mouse.set(0, 0),
                this.mouseDown = !1,
                this.mouseDownOn = [],
                this.mouseMoved = !1,
                window.addEventListener("orientationchange", this.onWindowResizeDebounce),
                window.addEventListener("resize", this.onWindowResizeDebounce),
                document.addEventListener("visibilitychange", this.onVisibilityChange, !1),
                this.onWindowResizeDebounce(),
                this.cursor.enable(),
                this.onAnimationFrame()
            }
        }, {
            key: "disable",
            value: function() {
                clearTimeout(this.cursorResetTimer),
                cancelAnimationFrame(this.animationFrame),
                window.removeEventListener("orientationchange", this.onWindowResizeDebounce),
                window.removeEventListener("resize", this.onWindowResizeDebounce),
                document.removeEventListener("visibilitychange", this.onVisibilityChange, !1),
                this.cursor.disable()
            }
        }, {
            key: "destroy",
            value: function() {
                for (var e in this.disable(),
                this.element.removeChild(this.renderer.domElement),
                this.element.parentNode.removeChild(this.element),
                this.buttons)
                    this.buttons[e].destroy(),
                    delete this.buttons[e];
                this.buttonEyes && this.buttonEyes.destroy(),
               // this.background && this.background.destroy(),
                this.cursor.destroy(),
                this.head.destroy(),
                this.speech.destroy(),
                this.scene.dispose(),
                delete this.animationFrame,
              //  delete this.background,
                delete this.buttons,
                delete this.buttonEyes,
                delete this.camera,
                delete this.cursor,
                delete this.cursorResetTimer,
                delete this.data,
                delete this.element,
                delete this.head,
                delete this.headGroup,
                delete this.mouse,
                delete this.mouseDown,
                delete this.mouseDownOn,
                delete this.mouseMoved,
                delete this.mouseZero,
                delete this.onWindowResizeDebounce,
                delete this.queueAbout,
                delete this.queueTwitter,
                delete this.raycaster,
                delete this.renderer,
                delete this.scene,
                delete this.speech,
                delete this.stats
            }
        }, {
            key: "render",
            value: function() {
                var t = 1.25 - this.mouseZero.distanceTo(this.mouse);
                this.headSmile += .2 * (t - this.headSmile),
                this.headGroup.rotation.y += .025 * (.5 * this.mouse.x - this.headGroup.rotation.y),
                this.headGroup.rotation.x += .025 * (-.5 * this.mouse.y - this.headGroup.rotation.x);
                var n = !1;
                if (this.mouseMoved) {
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    var i, r, a = this.raycaster.intersectObjects(this.scene.children, !0);
                    for (i = 0,
                    r = a.length; i < r; i++)
                        this.mouseDown && 0 === a[i].object.name.indexOf("Button") && this.mouseDownOn.push(a[i].object.name),
                        this.buttons.hasOwnProperty(a[i].object.name) && this.buttons[a[i].object.name].isVisible() && (n = !0,
                        this.buttons[a[i].object.name].setHover(!0))
                }
                for (var o in this.mouseDown = !1,
                n ? e.addClass(document.body, "cursor-pointer") : e.removeClass(document.body, "cursor-pointer"),
                this.speech.getMouthIsOpen() ? this.head.mouthOpen() : this.head.mouthClose(),
                this.head.look(this.mouse.x, -1 * this.mouse.y),
                this.head.smile(this.headSmile),
                this.head.update(),
                this.buttons)
                    this.buttons[o].update();
                this.stats.update(),
                this.renderer.render(this.scene, this.camera)
            }
        }, {
            key: "onHeadLoaded",
            value: function() {
            //    this.background = new Nh("",this.onBackgroundLoaded)
            }
        },/* {
            key: "onBackgroundLoaded",
            value: function() {
                setTimeout(this.showEnterButton, 1e3)
            }
        }, */{
            key: "showEnterButton",
            value: function() {
                this.buttons.ButtonLoading.setButtonText("ENTER"),
                this.buttons.ButtonLoading.setLoading(!1)
            }
        }, {
            key: "enterButtonClicked",
            value: function() {
                this.buttons.ButtonLoading.hide(),
                setTimeout(this.beginIntroAnimation, 700)
            }
        }, {
            key: "beginIntroAnimation",
            value: function() {
                for (var e in this.buttons)
                    this.buttons[e].destroy(),
                    delete this.buttons[e];
               // this.background.addTo(this.headGroup),
                this.onRandomBlink(),
                this.head.addTo(this.headGroup),
                this.buttonEyes = new zh(this.headGroup,"ButtonEyes",{
                    x: 0,
                    y: .04,
                    z: .16
                }),
                this.buttons.ButtonAbout = new Uh(this.headGroup,"ButtonAbout","ABOUT ME",{
                    x: 0,
                    y: .1,
                    z: .165
                }),
                this.buttons.ButtonAbout.show(),
                this.buttons.ButtonTweet = new Uh(this.headGroup,"ButtonTweet","READ TWEET",{
                    x: 0,
                    y: -.05,
                    z: .165
                }),
                this.buttons.ButtonTweet.show()
            }
        }, {
            key: "onAnimationFrame",
            value: function() {
                this.render(),
                this.animationFrame = requestAnimationFrame(this.onAnimationFrame)
            }
        }, {
            key: "onRandomBlink",
            value: function() {
                this.head.blink();
                var e = Math.floor(5001 * Math.random() + 3e3);
                setTimeout(this.onRandomBlink, e)
            }
        }, {
            key: "onWindowResize",
            value: function() {
                this.camera.aspect = this.element.clientWidth / this.element.clientHeight,
                this.camera.updateProjectionMatrix(),
                this.renderer.setSize(this.element.clientWidth, this.element.clientHeight)
            }
        }, {
            key: "onVisibilityChange",
            value: function() {
                document.hidden && this.speech.stop()
            }
        }, {
            key: "onCursorDown",
            value: function(e) {
                if (this.mouseDown = !0,
                this.mouseDownOn = [],
                "touch" === e.type) {
                    clearTimeout(this.cursorResetTimer);
                    var t = this.element.clientHeight / 2
                      , n = this.element.clientWidth / 2;
                    this.mouse.x = (e.point.x - n) / n,
                    this.mouse.y = (e.point.y - t) / t * -1,
                    this.mouseMoved = !0
                }
            }
        }, {
            key: "onCursorMove",
            value: function(e) {
                if (e.active || "mouse" === e.type) {
                    clearTimeout(this.cursorResetTimer);
                    var t = this.element.clientHeight / 2
                      , n = this.element.clientWidth / 2;
                    this.mouse.x = (e.point.x - n) / n,
                    this.mouse.y = (e.point.y - t) / t * -1,
                    this.mouseMoved = !0
                }
            }
        }, {
            key: "onCursorUp",
            value: function(e) {
                if (this.mouseDownOn.length > 0) {
                    var t = this.element.clientHeight / 2
                      , n = this.element.clientWidth / 2;
                    this.mouse.x = (e.point.x - n) / n,
                    this.mouse.y = (e.point.y - t) / t * -1,
                    this.handleMouseClick()
                }
                "touch" === e.type && (clearTimeout(this.cursorResetTimer),
                this.mouse.x = 0,
                this.mouse.y = 0,
                this.mouseMoved = !1)
            }
        }, {
            key: "onCursorLeave",
            value: function() {
                clearTimeout(this.cursorResetTimer),
                this.cursorResetTimer = setTimeout(this.onCursorReset, 1e3)
            }
        }, {
            key: "onCursorReset",
            value: function() {
                this.mouse.x = 0,
                this.mouse.y = 0,
                this.mouseMoved = !1
            }
        }, {
            key: "handleMouseClick",
            value: function() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                for (var e = this.raycaster.intersectObjects(this.scene.children, !0), t = 0, n = e.length; t < n; t++)
                    if (-1 !== this.mouseDownOn.indexOf(e[t].object.name))
                        switch (e[t].object.name) {
                        case "ButtonEyes":
                            this.head.eyebrowFlash();
                            break;
                        case "ButtonLoading":
                            this.buttons.ButtonLoading && this.buttons.ButtonLoading.isVisible() && this.enterButtonClicked();
                            break;
                        case "ButtonAbout":
                            this.playRandomAbout();
                            break;
                        case "ButtonTweet":
                            this.playRandomTweet()
                        }
            }
        }, {
            key: "onSpeechStart",
            value: function() {
                this.buttons.ButtonAbout && this.buttons.ButtonAbout.hide(),
                this.buttons.ButtonTweet && this.buttons.ButtonTweet.hide()
            }
        }, {
            key: "onSpeechStop",
            value: function() {
                this.buttons.ButtonAbout && this.buttons.ButtonAbout.show(),
                this.buttons.ButtonTweet && this.buttons.ButtonTweet.show()
            }
        }, {
            key: "onSpeechComplete",
            value: function() {}
        }, {
            key: "playRandomAbout",
            value: function() {
                if (this.speech.getIsSpeaking())
                    this.speech.stop();
                else {
                    this.queueAbout.length <= 0 && (this.queueAbout = this.data.about.slice(),
                    this.shuffleArray(this.queueAbout));
                    var e = this.queueAbout.shift();
                    this.speech.say(e)
                }
            }
        }, {
            key: "playRandomTweet",
            value: function() {
                if (this.speech.getIsSpeaking())
                    this.speech.stop();
                else {
                    this.queueTwitter.length <= 0 && (this.queueTwitter = this.data.tweets.slice(),
                    this.shuffleArray(this.queueTwitter));
                    var e = this.queueTwitter.shift();
                    this.speech.say(e)
                }
            }
        }, {
            key: "shuffleArray",
            value: function(e) {
                for (var t, n, i = e.length - 1; i > 0; i--)
                    t = Math.floor(Math.random() * i),
                    n = e[i],
                    e[i] = e[t],
                    e[t] = n
            }
        }]),
        n
    }()
      , qh = function() {
        try {
            var e = document.createElement("canvas",{"id":"canvas1"});
            
            return !(!window.WebGLRenderingContext || !e.getContext("webgl") && !e.getContext("experimental-webgl"))
        } catch (e) {
            return !1
        }
    };
    function Xh() {
        if (document.removeEventListener("DOMContentLoaded", Xh),
        e.setBrowserClasses(),
        function() {
            if ("createTouch"in document)
                try {
                    for (var e = /:hover/, t = 0; t < document.styleSheets.length; t++)
                        for (var n = document.styleSheets[t], i = n.cssRules.length - 1; i >= 0; i--) {
                            var r = n.cssRules[i];
                            r.type === CSSRule.STYLE_RULE && e.test(r.selectorText) && n.deleteRule(i)
                        }
                } catch (e) {}
        }(),
        "speechSynthesis"in window && qh())
            new Wh(document.body);
        else {
            var t = document.createElement("p");
            t.className = "error",
            t.innerHTML = '<strong>Oh no!</strong> You’ll need to use a browser that supports <em>WebGL</em> and <em>Speech Synthesis</em> to experience this website. I recommend using the latest version of <a href="https://www.google.com/chrome/" target="_blank">Google Chrome</a>.',
            e.prependChild(document.querySelector(".alt"), t),
            e.addClass(document.body, "show-alt")
        }
    }
    "complete" === document.readyState ? Xh() : document.addEventListener("DOMContentLoaded", Xh)
}();
